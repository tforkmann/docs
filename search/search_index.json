{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the SAFE documentation site! This site contains all the documentation you'll need to quickly starting creating SAFE apps in F#. If you've not heard of SAFE before, please feel free to start with the introduction . Alternatively, you can immediately try out the quick start guide and tutorial, or simply browse through the documentation. If there's anything missing from here, please feel free to add the documentation directly (or supply an issue) to the GitHub repository . We hope you enjoy using SAFE as much as we do! The SAFE team.","title":"Home"},{"location":"awesome-safe-components/","text":"A set of SAFE-ready wrappers around existing React and JS UI Components. How can I contribute my library to this list? Required Adding a README with installation instructions Adding femto metadata to the projects Nice to have Adding documentation with sample code on the various use cases Adding live documentation website with sample code React bindings Fable.React Fable bindings and helpers for React and React Native. Get it! Feliz A fresh retake of the React API in Fable and a collection of high-quality components to build React applications in F#, optimized for happiness. Get it! UI Frameworks Feliz.MaterialUI Feliz-style Fable bindings for Material-UI . Get it! Feliz.Reactstrap Fable binding for reactstrap . Get it! Fable.MaterialUI Fable bindings for Material-UI . Get it! Feliz.Bulma Bulma UI wrapper for amazing Feliz DSL. Get it! Fulma Fulma provides a wrapper around Bulma 0.9.0 , an open source CSS framework, for fable-react. Get it! Fable.AntD Fable bindings for Ant Design React components . Get it! Fable.FontAwesome.Free Bindings for the Free icons of Font Awesome, should be used with Fable.FontAwesome. Get it! Fable.FluentUI FluentUI (React) to Fable bindings. Get it! Fable.ReactGridSystem React Grid System to Fable bindings. Get it! UI Controls Feliz.Popover Feliz-style Fable bindings for react-popover . Get it! Feliz.SelectSearch A binding for react-select-search that implements a searchable and customizable dropdown for Feliz applications. Get it! Feliz.Kawaii Feliz-style Fable bindings for react-kawaii which contains lovely SVG components. Get it! Feliz.SweetAlert Feliz-style Fable bindings for sweetalert2 and sweetalert2-react-content with Feliz style api for use within React applications. Implemented as both normal functions and Elmish commands, for maximum flexibility. Get it! Elmish.SweetAlert SweetAlert integration for Fable, made with love to work in Elmish apps. Get it! Elmish.Toastr Toastr integration with Fable, implemented as Elmish commands. Get it! Elmish.AnimatedTree A fork and binding of react-animated-tree , adapted to properly work within Elmish applications. Get it! Feliz.ReactHamburger Feliz-style Fable bindings for hamburger-react . Get it! Feliz.ReactAwesomeSlider Feliz-style Fable bindings for react-awesome-slider . Get it! Feliz.ReactSelect Feliz-style Fable bindings for react-select . Get it! Fable.React.Flatpickr Fable binding for react-flatpickr that is ready to use within Elmish applications. Get it! Feliz.Tippy Feliz-style Fable bindings for tippyjs-react . Get it! Feliz.ReactSpeedometer Feliz-style Fable bindings for react-d3-speedometer . Get it! Fable.ReactKanban React Kanban bindings for Fable React. Get it! Fable.React.DrawingCanvas This is a Fable React wrapper for canvas that allows you to declare a drawing. Get it! Fable.GroupingPanel An F# computation expression that groups Fable UI data into one or more collapsable panels. Get it! Data Visualisation Feliz.AgGrid Feliz-style Fable bindings for ag-grid . Get it! Fable.ReactAgGrid Fable bindings for ag-grid . Get it! Feliz.Reactflow Feliz-style Fable bindings for react flow . Get it! Maps Fable.ReactGoogleMaps Feliz-style Fable bindings for react-google-maps . Get it! Feliz.PigeonMaps Feliz-style bindings for pigeon-maps , React maps without external dependencies. This binding includes it's own custom PigeonMaps.marker component to build map markers manually. Get it! Charting Feliz.AgChart Feliz-style bindings for ag-charts . Get it! Feliz.Plotly Fable bindings for plotly.js and react-plotly.js with Feliz style api for use within React applications. Lets you build visualizations in an easy, discoverable, and safe fashion. Get it! Feliz.Recharts Feliz-style bindings for recharts , a composable charting library built on React components. The binding translates the original API of recharts in a one-to-one fashion but makes it type-safe and easily discoverable. Get it! Feliz.RoughViz Feliz-style Fable bindings for roughViz visualisation library . It is a fun project when your data visualisations don't need to be formal. This binding is actually made to work with original rough-viz library than renders to the DOM rather than an existing third-party React library which makes it a nice example to learn from. Get it! State management Feliz.Recoil Fable bindings in Feliz style for Facebook's experimental state management library recoil . Get it! Testing Fable.Jester Fable bindings for jest and friends for delightful Fable testing. Get it! Fable.Mocha Fable library for testing. Inspired by the popular Expecto library for F# and adopts the testList, testCase and testCaseAsync primitives for defining tests. Get it! Fable.ReactTestingLibrary Fable bindings for react-testing-library and user-event. Get it! Animation Fun.ReactSpring Fable bindings for react spring . Get it!","title":"SAFE-Compatible UI Components"},{"location":"awesome-safe-components/#how-can-i-contribute-my-library-to-this-list","text":"","title":"How can I contribute my library to this list?"},{"location":"awesome-safe-components/#required","text":"Adding a README with installation instructions Adding femto metadata to the projects","title":"Required"},{"location":"awesome-safe-components/#nice-to-have","text":"Adding documentation with sample code on the various use cases Adding live documentation website with sample code","title":"Nice to have"},{"location":"awesome-safe-components/#react-bindings","text":"","title":"React bindings"},{"location":"awesome-safe-components/#fablereact","text":"Fable bindings and helpers for React and React Native. Get it!","title":"Fable.React"},{"location":"awesome-safe-components/#feliz","text":"A fresh retake of the React API in Fable and a collection of high-quality components to build React applications in F#, optimized for happiness. Get it!","title":"Feliz"},{"location":"awesome-safe-components/#ui-frameworks","text":"","title":"UI Frameworks"},{"location":"awesome-safe-components/#felizmaterialui","text":"Feliz-style Fable bindings for Material-UI . Get it!","title":"Feliz.MaterialUI"},{"location":"awesome-safe-components/#felizreactstrap","text":"Fable binding for reactstrap . Get it!","title":"Feliz.Reactstrap"},{"location":"awesome-safe-components/#fablematerialui","text":"Fable bindings for Material-UI . Get it!","title":"Fable.MaterialUI"},{"location":"awesome-safe-components/#felizbulma","text":"Bulma UI wrapper for amazing Feliz DSL. Get it!","title":"Feliz.Bulma"},{"location":"awesome-safe-components/#fulma","text":"Fulma provides a wrapper around Bulma 0.9.0 , an open source CSS framework, for fable-react. Get it!","title":"Fulma"},{"location":"awesome-safe-components/#fableantd","text":"Fable bindings for Ant Design React components . Get it!","title":"Fable.AntD"},{"location":"awesome-safe-components/#fablefontawesomefree","text":"Bindings for the Free icons of Font Awesome, should be used with Fable.FontAwesome. Get it!","title":"Fable.FontAwesome.Free"},{"location":"awesome-safe-components/#fablefluentui","text":"FluentUI (React) to Fable bindings. Get it!","title":"Fable.FluentUI"},{"location":"awesome-safe-components/#fablereactgridsystem","text":"React Grid System to Fable bindings. Get it!","title":"Fable.ReactGridSystem"},{"location":"awesome-safe-components/#ui-controls","text":"","title":"UI Controls"},{"location":"awesome-safe-components/#felizpopover","text":"Feliz-style Fable bindings for react-popover . Get it!","title":"Feliz.Popover"},{"location":"awesome-safe-components/#felizselectsearch","text":"A binding for react-select-search that implements a searchable and customizable dropdown for Feliz applications. Get it!","title":"Feliz.SelectSearch"},{"location":"awesome-safe-components/#felizkawaii","text":"Feliz-style Fable bindings for react-kawaii which contains lovely SVG components. Get it!","title":"Feliz.Kawaii"},{"location":"awesome-safe-components/#felizsweetalert","text":"Feliz-style Fable bindings for sweetalert2 and sweetalert2-react-content with Feliz style api for use within React applications. Implemented as both normal functions and Elmish commands, for maximum flexibility. Get it!","title":"Feliz.SweetAlert"},{"location":"awesome-safe-components/#elmishsweetalert","text":"SweetAlert integration for Fable, made with love to work in Elmish apps. Get it!","title":"Elmish.SweetAlert"},{"location":"awesome-safe-components/#elmishtoastr","text":"Toastr integration with Fable, implemented as Elmish commands. Get it!","title":"Elmish.Toastr"},{"location":"awesome-safe-components/#elmishanimatedtree","text":"A fork and binding of react-animated-tree , adapted to properly work within Elmish applications. Get it!","title":"Elmish.AnimatedTree"},{"location":"awesome-safe-components/#felizreacthamburger","text":"Feliz-style Fable bindings for hamburger-react . Get it!","title":"Feliz.ReactHamburger"},{"location":"awesome-safe-components/#felizreactawesomeslider","text":"Feliz-style Fable bindings for react-awesome-slider . Get it!","title":"Feliz.ReactAwesomeSlider"},{"location":"awesome-safe-components/#felizreactselect","text":"Feliz-style Fable bindings for react-select . Get it!","title":"Feliz.ReactSelect"},{"location":"awesome-safe-components/#fablereactflatpickr","text":"Fable binding for react-flatpickr that is ready to use within Elmish applications. Get it!","title":"Fable.React.Flatpickr"},{"location":"awesome-safe-components/#feliztippy","text":"Feliz-style Fable bindings for tippyjs-react . Get it!","title":"Feliz.Tippy"},{"location":"awesome-safe-components/#felizreactspeedometer","text":"Feliz-style Fable bindings for react-d3-speedometer . Get it!","title":"Feliz.ReactSpeedometer"},{"location":"awesome-safe-components/#fablereactkanban","text":"React Kanban bindings for Fable React. Get it!","title":"Fable.ReactKanban"},{"location":"awesome-safe-components/#fablereactdrawingcanvas","text":"This is a Fable React wrapper for canvas that allows you to declare a drawing. Get it!","title":"Fable.React.DrawingCanvas"},{"location":"awesome-safe-components/#fablegroupingpanel","text":"An F# computation expression that groups Fable UI data into one or more collapsable panels. Get it!","title":"Fable.GroupingPanel"},{"location":"awesome-safe-components/#data-visualisation","text":"","title":"Data Visualisation"},{"location":"awesome-safe-components/#felizaggrid","text":"Feliz-style Fable bindings for ag-grid . Get it!","title":"Feliz.AgGrid"},{"location":"awesome-safe-components/#fablereactaggrid","text":"Fable bindings for ag-grid . Get it!","title":"Fable.ReactAgGrid"},{"location":"awesome-safe-components/#felizreactflow","text":"Feliz-style Fable bindings for react flow . Get it!","title":"Feliz.Reactflow"},{"location":"awesome-safe-components/#maps","text":"","title":"Maps"},{"location":"awesome-safe-components/#fablereactgooglemaps","text":"Feliz-style Fable bindings for react-google-maps . Get it!","title":"Fable.ReactGoogleMaps"},{"location":"awesome-safe-components/#felizpigeonmaps","text":"Feliz-style bindings for pigeon-maps , React maps without external dependencies. This binding includes it's own custom PigeonMaps.marker component to build map markers manually. Get it!","title":"Feliz.PigeonMaps"},{"location":"awesome-safe-components/#charting","text":"","title":"Charting"},{"location":"awesome-safe-components/#felizagchart","text":"Feliz-style bindings for ag-charts . Get it!","title":"Feliz.AgChart"},{"location":"awesome-safe-components/#felizplotly","text":"Fable bindings for plotly.js and react-plotly.js with Feliz style api for use within React applications. Lets you build visualizations in an easy, discoverable, and safe fashion. Get it!","title":"Feliz.Plotly"},{"location":"awesome-safe-components/#felizrecharts","text":"Feliz-style bindings for recharts , a composable charting library built on React components. The binding translates the original API of recharts in a one-to-one fashion but makes it type-safe and easily discoverable. Get it!","title":"Feliz.Recharts"},{"location":"awesome-safe-components/#felizroughviz","text":"Feliz-style Fable bindings for roughViz visualisation library . It is a fun project when your data visualisations don't need to be formal. This binding is actually made to work with original rough-viz library than renders to the DOM rather than an existing third-party React library which makes it a nice example to learn from. Get it!","title":"Feliz.RoughViz"},{"location":"awesome-safe-components/#state-management","text":"","title":"State management"},{"location":"awesome-safe-components/#felizrecoil","text":"Fable bindings in Feliz style for Facebook's experimental state management library recoil . Get it!","title":"Feliz.Recoil"},{"location":"awesome-safe-components/#testing","text":"","title":"Testing"},{"location":"awesome-safe-components/#fablejester","text":"Fable bindings for jest and friends for delightful Fable testing. Get it!","title":"Fable.Jester"},{"location":"awesome-safe-components/#fablemocha","text":"Fable library for testing. Inspired by the popular Expecto library for F# and adopts the testList, testCase and testCaseAsync primitives for defining tests. Get it!","title":"Fable.Mocha"},{"location":"awesome-safe-components/#fablereacttestinglibrary","text":"Fable bindings for react-testing-library and user-event. Get it!","title":"Fable.ReactTestingLibrary"},{"location":"awesome-safe-components/#animation","text":"","title":"Animation"},{"location":"awesome-safe-components/#funreactspring","text":"Fable bindings for react spring . Get it!","title":"Fun.ReactSpring"},{"location":"component-azure/","text":"Azure in SAFE What is Azure? Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions. How does Azure integrate with SAFE? Azure provides a number of flexible services for SAFE applications, including (but not only): Hosting Services Azure comes with several ready-made hosting services, including App Service , which enables seamless hosting of web applications, including ASP.NET Core applications (which Saturn is built on top of). In addition, Azure supports a number of managed hosting services for Docker and Kubernetes , which work fantastically well with SAFE. Platform Services Azure comes with a large number of ready-made platform services that can dramatically lower the cost of developing bespoke systems, including: Compute services such as Azure Functions , for hosting F# code that can dynamically scale based on load, as well as Service Fabric or Virtual Machines . Storage services such as Azure Storage and Data Lake , for storing virtually limitless volumes of data in unstructured or structure form. Database services, including managed SQL Server , MySQL and Postgres , as well as CosmosDB for document and graph stores, Redis and more. Messaging services including Queues , Service Bus and Event Hub . Analytical services such as Stream Analytics , Databricks , Machine Learning and Analysis Services . Security services such as Key Vault and Active Directory . Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the Azure Storage Type Provider provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F# (currently not yet supported on .NET Core) .","title":"Learn about Azure"},{"location":"component-azure/#azure-in-safe","text":"","title":"Azure in SAFE"},{"location":"component-azure/#what-is-azure","text":"Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.","title":"What is Azure?"},{"location":"component-azure/#how-does-azure-integrate-with-safe","text":"Azure provides a number of flexible services for SAFE applications, including (but not only):","title":"How does Azure integrate with SAFE?"},{"location":"component-azure/#hosting-services","text":"Azure comes with several ready-made hosting services, including App Service , which enables seamless hosting of web applications, including ASP.NET Core applications (which Saturn is built on top of). In addition, Azure supports a number of managed hosting services for Docker and Kubernetes , which work fantastically well with SAFE.","title":"Hosting Services"},{"location":"component-azure/#platform-services","text":"Azure comes with a large number of ready-made platform services that can dramatically lower the cost of developing bespoke systems, including: Compute services such as Azure Functions , for hosting F# code that can dynamically scale based on load, as well as Service Fabric or Virtual Machines . Storage services such as Azure Storage and Data Lake , for storing virtually limitless volumes of data in unstructured or structure form. Database services, including managed SQL Server , MySQL and Postgres , as well as CosmosDB for document and graph stores, Redis and more. Messaging services including Queues , Service Bus and Event Hub . Analytical services such as Stream Analytics , Databricks , Machine Learning and Analysis Services . Security services such as Key Vault and Active Directory . Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the Azure Storage Type Provider provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F# (currently not yet supported on .NET Core) .","title":"Platform Services"},{"location":"component-elmish/","text":"Elmish in SAFE What is Elmish? Elmish is a library for building single page applications in F# applications, following the model-view-update architecture made famous by Elm . The following diagram is a simplified, high-level view of the MVU pattern. Model in this case refers to your application's state, with Update and View the two functions that handle the flow of messaging. If you wish to read more, we also recommend reading the excellent Elmish Book . stateDiagram-v2 [*] --> Update : Current model and Command Update --> View : Updated model View --> [*] : HTML rendered on page How does Elmish integrate with SAFE? Elmish is the library used to build the front-end application in SAFE and that application is compiled to Javascript by Fable to run in the browser. The SAFE Stack template comes pre-bundled with the Elmish React module, which (as the name suggests) uses the React library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface. Because Elmish works alongside React, it is possible to use the vast number of available React components from the Javascript ecosystem within our Elmish applications. This conceptual diagram illustrates how the different pieces of Elmish, React and Fable fit together to make the front-end part of your SAFE application which runs in the browser. flowchart RL subgraph Browser React(React - Handles DOM updates) Fable(Fable - Translates F# to JS) ER(Elmish React - Elmish to React bridge) Elmish(Elmish - Provides MVU abstractions) You(Your F# domain logic) You --- Elmish --- ER --- Fable --- React end Learn Elmish The official Elmish docs The Elmish Book","title":"Learn about Elmish"},{"location":"component-elmish/#elmish-in-safe","text":"","title":"Elmish in SAFE"},{"location":"component-elmish/#what-is-elmish","text":"Elmish is a library for building single page applications in F# applications, following the model-view-update architecture made famous by Elm . The following diagram is a simplified, high-level view of the MVU pattern. Model in this case refers to your application's state, with Update and View the two functions that handle the flow of messaging. If you wish to read more, we also recommend reading the excellent Elmish Book . stateDiagram-v2 [*] --> Update : Current model and Command Update --> View : Updated model View --> [*] : HTML rendered on page","title":"What is Elmish?"},{"location":"component-elmish/#how-does-elmish-integrate-with-safe","text":"Elmish is the library used to build the front-end application in SAFE and that application is compiled to Javascript by Fable to run in the browser. The SAFE Stack template comes pre-bundled with the Elmish React module, which (as the name suggests) uses the React library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface. Because Elmish works alongside React, it is possible to use the vast number of available React components from the Javascript ecosystem within our Elmish applications. This conceptual diagram illustrates how the different pieces of Elmish, React and Fable fit together to make the front-end part of your SAFE application which runs in the browser. flowchart RL subgraph Browser React(React - Handles DOM updates) Fable(Fable - Translates F# to JS) ER(Elmish React - Elmish to React bridge) Elmish(Elmish - Provides MVU abstractions) You(Your F# domain logic) You --- Elmish --- ER --- Fable --- React end","title":"How does Elmish integrate with SAFE?"},{"location":"component-elmish/#learn-elmish","text":"The official Elmish docs The Elmish Book","title":"Learn Elmish"},{"location":"component-fable/","text":"Fable in SAFE What is Fable? Fable is an F#-to-JavaScript (JS) compiler, designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well as the most commonly used .NET APIs. It also provides rich integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools. How does Fable integrate with SAFE? Fable is a .NET tool that generates JavaScript files directly this allows us to write full front end applications using F#. Being able to write both the Server and Client in the same language offers huge benefits especially when you can share code between the two, without the need for duplication. More information on code sharing can be found here . Fable and webpack As Fable allows us to integrate into the JS Ecosystem it allows us to use webpack and features like Hot Module replacement and Source Maps. Creating a webpack config file isn't the easiest thing in the world, so the SAFE Template already has one pre-built that contains the basics to get you up and running immediately. Learn more about Fable here .","title":"Learn about Fable"},{"location":"component-fable/#fable-in-safe","text":"","title":"Fable in SAFE"},{"location":"component-fable/#what-is-fable","text":"Fable is an F#-to-JavaScript (JS) compiler, designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well as the most commonly used .NET APIs. It also provides rich integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools.","title":"What is Fable?"},{"location":"component-fable/#how-does-fable-integrate-with-safe","text":"Fable is a .NET tool that generates JavaScript files directly this allows us to write full front end applications using F#. Being able to write both the Server and Client in the same language offers huge benefits especially when you can share code between the two, without the need for duplication. More information on code sharing can be found here .","title":"How does Fable integrate with SAFE?"},{"location":"component-fable/#fable-and-webpack","text":"As Fable allows us to integrate into the JS Ecosystem it allows us to use webpack and features like Hot Module replacement and Source Maps. Creating a webpack config file isn't the easiest thing in the world, so the SAFE Template already has one pre-built that contains the basics to get you up and running immediately. Learn more about Fable here .","title":"Fable and webpack"},{"location":"component-saturn/","text":"Saturn in SAFE Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components: Giraffe , an F#-specific library for writing functional-first web applications. Microsoft's ASP.NET Core . Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication. Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's Phoenix . How does Saturn integrate with SAFE? Saturn provides the ability to drive your SAFE applications from the server. It enables: Routing and hosting of your server-side APIs through a set of simple-to-use abstractions. Hosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable. Other cross cutting concerns e.g. authentication etc. It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this here . flowchart TB outputs>JSON, HTML etc.] subgraph host[.NET Core Host] saturn[Saturn - Routers, Controllers etc.] giraffe[Giraffe - Core F# abstractions] aspnet[ASP.NET Core - HTTP Context etc.] kestrel[Kestrel - Web Server] saturn --- giraffe --- aspnet --- kestrel end data[(Transactional Data e.g. SQL)] content>Static Content e.g. HTML, CSS, Javascript] outputs -- serves --- host kestrel -- reads --- data kestrel -- reads --- content Learn more about Saturn here .","title":"Learn about Saturn"},{"location":"component-saturn/#saturn-in-safe","text":"Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components: Giraffe , an F#-specific library for writing functional-first web applications. Microsoft's ASP.NET Core . Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication. Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's Phoenix .","title":"Saturn in SAFE"},{"location":"component-saturn/#how-does-saturn-integrate-with-safe","text":"Saturn provides the ability to drive your SAFE applications from the server. It enables: Routing and hosting of your server-side APIs through a set of simple-to-use abstractions. Hosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable. Other cross cutting concerns e.g. authentication etc. It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this here . flowchart TB outputs>JSON, HTML etc.] subgraph host[.NET Core Host] saturn[Saturn - Routers, Controllers etc.] giraffe[Giraffe - Core F# abstractions] aspnet[ASP.NET Core - HTTP Context etc.] kestrel[Kestrel - Web Server] saturn --- giraffe --- aspnet --- kestrel end data[(Transactional Data e.g. SQL)] content>Static Content e.g. HTML, CSS, Javascript] outputs -- serves --- host kestrel -- reads --- data kestrel -- reads --- content Learn more about Saturn here .","title":"How does Saturn integrate with SAFE?"},{"location":"events/","text":"Upcoming events Title Type Date Location Who Cost Past events 2019 Title Type Date Location Who Cost SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 22 2019 Dresden, Germany Compositional IT Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 23 2019 Prague, Czech Republic Compositional IT Free Web development with SAFE Stack Conference Jan 26 2019 Minsk, Belarus Mikhail Smal Paid Hacking F# in JS ecosystem Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free Reinventing MVC pattern for web programming with F# Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Feb 12 2019 Osnabr\u00fcck, Germany Compositional IT Free SAFE web development with F# User Group Mar 28 2019 Prague, Czech Republic Mikhail Smal Free SAFE Stack: Current State Conference April 4-5 2019 London, UK Tomasz Heimowski Paid Workshop: Up and Running with the SAFE Stack Conference April 4-5 2019 London, UK Compositional IT Paid The Pit of Success with SAFE Stack User Group April 11 2019 Berlin, Germany Isaac Abraham Free Workshop: Hands on with F# Conference workshop April 27 2019 Berlin, Germany Isaac Abraham Free Workshop: SAFE Web development with F# Conference May 14 2019 Vilnius, Lithuania Mikhail Smal Paid Write Your Own Domain Specific Language with F# Conference May 15-16 2019 Vilnius, Lithuania Mikhail Smal Paid Full Stack Web in F# Conference June 8 2019 Minsk, Belarus Tomasz Heimowski Paid Write Your Own Domain Specific Language with F# Conference Jun 18 2019 Oslo, Norway Mikhail Smal Paid FableConf Conference Sep 6-7 2019 Antwerp, Belgium Paid Functional Web Programming with the SAFE Stack Training Sep 12-13 2019 London, UK Isaac Abraham / Compositional IT Paid Hands-on with SAFE Stack Conference Oct 17-18 2019 C\u00e1diz, Spain Tomasz Heimowski Paid Full Stack Web in F# Conference November 6-8 2019 Malm\u00f6, Sweden Tomasz Heimowski Paid 2018 Title Type Date Location Who Cost SAFE apps with F# web stack Conference Feb 23 2018 Krak\u00f3w, Poland Tomasz Heimowski Paid SAFE apps with F# web stack Conference April 5 2018 London, UK Tomasz Heimowski Paid SAFE Stack Workshop User Group Aug 22 2018 Bristol, UK Compositional IT Free SAFE apps with F# web stack Conference Sep 21 2018 Gda\u0144sk, Poland Tomasz Heimowski Free SAFE Stack: Functional Web Programming in .NET Conference Sep 22 2018 Cambridge, UK Compositional IT Free F# Full Stack with SAFE Training Sep 26 2018 San Francisco, USA Lambda Factory Paid SAFE Hackday Training Oct 6 2018 Birmingham, UK Ian Russel Free Cloud Programming with F# Training Oct 25 2018 Berlin, Germany Compositional IT Paid FableConf / RemmiDemmi Conference Oct 26/27 2018 Berlin, Germany Paid F# development with SAFE Training Nov 7 2018 Vienna, Austria Lambda Factory Paid","title":"Events"},{"location":"events/#upcoming-events","text":"Title Type Date Location Who Cost","title":"Upcoming events"},{"location":"events/#past-events","text":"","title":"Past events"},{"location":"events/#2019","text":"Title Type Date Location Who Cost SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 22 2019 Dresden, Germany Compositional IT Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Jan 23 2019 Prague, Czech Republic Compositional IT Free Web development with SAFE Stack Conference Jan 26 2019 Minsk, Belarus Mikhail Smal Paid Hacking F# in JS ecosystem Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free Reinventing MVC pattern for web programming with F# Conference Feb 2 2019 Brussels, Belgium Krzysztof Cieslak Free SAFE Stack - The Pit of Success for Functional Web Programming User Group Feb 12 2019 Osnabr\u00fcck, Germany Compositional IT Free SAFE web development with F# User Group Mar 28 2019 Prague, Czech Republic Mikhail Smal Free SAFE Stack: Current State Conference April 4-5 2019 London, UK Tomasz Heimowski Paid Workshop: Up and Running with the SAFE Stack Conference April 4-5 2019 London, UK Compositional IT Paid The Pit of Success with SAFE Stack User Group April 11 2019 Berlin, Germany Isaac Abraham Free Workshop: Hands on with F# Conference workshop April 27 2019 Berlin, Germany Isaac Abraham Free Workshop: SAFE Web development with F# Conference May 14 2019 Vilnius, Lithuania Mikhail Smal Paid Write Your Own Domain Specific Language with F# Conference May 15-16 2019 Vilnius, Lithuania Mikhail Smal Paid Full Stack Web in F# Conference June 8 2019 Minsk, Belarus Tomasz Heimowski Paid Write Your Own Domain Specific Language with F# Conference Jun 18 2019 Oslo, Norway Mikhail Smal Paid FableConf Conference Sep 6-7 2019 Antwerp, Belgium Paid Functional Web Programming with the SAFE Stack Training Sep 12-13 2019 London, UK Isaac Abraham / Compositional IT Paid Hands-on with SAFE Stack Conference Oct 17-18 2019 C\u00e1diz, Spain Tomasz Heimowski Paid Full Stack Web in F# Conference November 6-8 2019 Malm\u00f6, Sweden Tomasz Heimowski Paid","title":"2019"},{"location":"events/#2018","text":"Title Type Date Location Who Cost SAFE apps with F# web stack Conference Feb 23 2018 Krak\u00f3w, Poland Tomasz Heimowski Paid SAFE apps with F# web stack Conference April 5 2018 London, UK Tomasz Heimowski Paid SAFE Stack Workshop User Group Aug 22 2018 Bristol, UK Compositional IT Free SAFE apps with F# web stack Conference Sep 21 2018 Gda\u0144sk, Poland Tomasz Heimowski Free SAFE Stack: Functional Web Programming in .NET Conference Sep 22 2018 Cambridge, UK Compositional IT Free F# Full Stack with SAFE Training Sep 26 2018 San Francisco, USA Lambda Factory Paid SAFE Hackday Training Oct 6 2018 Birmingham, UK Ian Russel Free Cloud Programming with F# Training Oct 25 2018 Berlin, Germany Compositional IT Paid FableConf / RemmiDemmi Conference Oct 26/27 2018 Berlin, Germany Paid F# development with SAFE Training Nov 7 2018 Vienna, Austria Lambda Factory Paid","title":"2018"},{"location":"faq-build/","text":"This page explains the key differences that you should be aware of between running SAFE applications in development and production. Developing SAFE applications The SAFE template is geared towards a streamlined development process. It builds and runs both the client and server on your machine. During development, in parallel to your .NET web server, Webpack Dev Server is used to enable hot module replacement. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application. The build of the .NET server also makes use of dotnet watch to have the server automatically restart with the latest changes. Since your backend applications will typically be stateless, this permits a rapid development workflow. It's important to note that the webpack dev server is configured to automatically route traffic intended for api/* routes to the backend web server. This simulates how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or CORS issues. flowchart LR subgraph c[localhost:8080] js>Fable-compiled JS] webpack(Webpack dev server) js -- hot module replacement --- webpack end subgraph s[localhost:8085] dotnet(dotnet watch run) saturn(Saturn on Kestrel) saturn --- dotnet end c -- /api redirect --> s Running SAFE applications in production In a production environment, you won't need the Webpack Dev server. Instead, Webpack is used as a one-off compiler step to create your bundled Javascript from your Fable app (plus dependencies), and then deploy this along with your backend web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your backend APIs. This fits very well with standard CI / CD processes, as a build step in your Build.fs or Azure DevOps / AppVeyor / Travis step etc. flowchart BT subgraph dest[Web server e.g. https://contoso.com] saturn(Saturn myapp.dll) db[(transactional data)] assets>static assets] saturn -- api/customers --- db saturn -- bundle.js --- assets end subgraph src[CI/CD Server] exec>deployment script] webpack(webpack) dotnet(dotnet publish) source(F# source code) exec -- bundle.js --- webpack exec -- myapp.dll --- dotnet webpack --- source dotnet --- source end src -- file copy --> dest Client asset hosting alternatives Rather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.","title":"Moving from dev to prod"},{"location":"faq-build/#developing-safe-applications","text":"The SAFE template is geared towards a streamlined development process. It builds and runs both the client and server on your machine. During development, in parallel to your .NET web server, Webpack Dev Server is used to enable hot module replacement. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application. The build of the .NET server also makes use of dotnet watch to have the server automatically restart with the latest changes. Since your backend applications will typically be stateless, this permits a rapid development workflow. It's important to note that the webpack dev server is configured to automatically route traffic intended for api/* routes to the backend web server. This simulates how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or CORS issues. flowchart LR subgraph c[localhost:8080] js>Fable-compiled JS] webpack(Webpack dev server) js -- hot module replacement --- webpack end subgraph s[localhost:8085] dotnet(dotnet watch run) saturn(Saturn on Kestrel) saturn --- dotnet end c -- /api redirect --> s","title":"Developing SAFE applications"},{"location":"faq-build/#running-safe-applications-in-production","text":"In a production environment, you won't need the Webpack Dev server. Instead, Webpack is used as a one-off compiler step to create your bundled Javascript from your Fable app (plus dependencies), and then deploy this along with your backend web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your backend APIs. This fits very well with standard CI / CD processes, as a build step in your Build.fs or Azure DevOps / AppVeyor / Travis step etc. flowchart BT subgraph dest[Web server e.g. https://contoso.com] saturn(Saturn myapp.dll) db[(transactional data)] assets>static assets] saturn -- api/customers --- db saturn -- bundle.js --- assets end subgraph src[CI/CD Server] exec>deployment script] webpack(webpack) dotnet(dotnet publish) source(F# source code) exec -- bundle.js --- webpack exec -- myapp.dll --- dotnet webpack --- source dotnet --- source end src -- file copy --> dest","title":"Running SAFE applications in production"},{"location":"faq-build/#client-asset-hosting-alternatives","text":"Rather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.","title":"Client asset hosting alternatives"},{"location":"faq-troubleshooting/","text":"Getting Started Diagnostics SocketProtocolError in Debug Console You may see the following SocketProtocolError message in the Debug Console once you have started your SAFE application. WebSocket connection to 'ws://localhost:8000/socketcluster/' failed: Error during WebSocket handshake: Unexpected response code: 404 Whilst these messages can be safely ignored, you can eliminate them by installing Redux Dev Tools in the launched Chrome instance as described in the debugging prerequisites section. Debugging in VS Code Node Process does not stop after stopping the debugger VS Code does not kill the Fable process when you stop the debugger, leaving it running as a \"zombie\". In such a case, you will have to explicitly kill the process otherwise it will hold onto port 8080 and prevent you starting new instances. This should be easily doable by sending Ctrl+C in the Terminal window in VS Code for Watch Client task. Tracked here . Chrome opens to a blank window Occasionally, VS Code will open Chrome before the Client has started. In this case, you will be presented with a blank screen until the client starts. Depending on the order in which compilation occurs, VS Code may launch the web browser before the server has started. If this occurs, you may need to refresh the browser once the server is fully initialised. Fable JavaScript bundle size A project created from SAFE template might issue the following warning from Webpack upon building the JavaScript bundle: WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. We're striving to optimise the bundle size, however with a number of different options and dependencies it's not that easy to stay below the Webpack recommended limit. To minimize the bundle size in your project you can try restricting browser compatibility by modifying the Babel Preset targets for Browserslist and thus using less polyfills. For more info, see this issue .","title":"Troubleshooting"},{"location":"faq-troubleshooting/#getting-started","text":"","title":"Getting Started"},{"location":"faq-troubleshooting/#diagnostics","text":"","title":"Diagnostics"},{"location":"faq-troubleshooting/#socketprotocolerror-in-debug-console","text":"You may see the following SocketProtocolError message in the Debug Console once you have started your SAFE application. WebSocket connection to 'ws://localhost:8000/socketcluster/' failed: Error during WebSocket handshake: Unexpected response code: 404 Whilst these messages can be safely ignored, you can eliminate them by installing Redux Dev Tools in the launched Chrome instance as described in the debugging prerequisites section.","title":"SocketProtocolError in Debug Console"},{"location":"faq-troubleshooting/#debugging-in-vs-code","text":"","title":"Debugging in VS Code"},{"location":"faq-troubleshooting/#node-process-does-not-stop-after-stopping-the-debugger","text":"VS Code does not kill the Fable process when you stop the debugger, leaving it running as a \"zombie\". In such a case, you will have to explicitly kill the process otherwise it will hold onto port 8080 and prevent you starting new instances. This should be easily doable by sending Ctrl+C in the Terminal window in VS Code for Watch Client task. Tracked here .","title":"Node Process does not stop after stopping the debugger"},{"location":"faq-troubleshooting/#chrome-opens-to-a-blank-window","text":"Occasionally, VS Code will open Chrome before the Client has started. In this case, you will be presented with a blank screen until the client starts. Depending on the order in which compilation occurs, VS Code may launch the web browser before the server has started. If this occurs, you may need to refresh the browser once the server is fully initialised.","title":"Chrome opens to a blank window"},{"location":"faq-troubleshooting/#fable","text":"","title":"Fable"},{"location":"faq-troubleshooting/#javascript-bundle-size","text":"A project created from SAFE template might issue the following warning from Webpack upon building the JavaScript bundle: WARNING in entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance. We're striving to optimise the bundle size, however with a number of different options and dependencies it's not that easy to stay below the Webpack recommended limit. To minimize the bundle size in your project you can try restricting browser compatibility by modifying the Babel Preset targets for Browserslist and thus using less polyfills. For more info, see this issue .","title":"JavaScript bundle size"},{"location":"feature-azurefunctions/","text":"Going serverless with SAFE With SAFE-Stack you can easily take advantage of serverless computing via Azure Functions . With Functions-As-A-Service (FAAS) you can focus on building your business logic and don't need to worry about provisioning and maintaining servers (hence \"serverless\"). Azure Functions provide a managed compute platform with high reliability. If you use a \"consumption plan\" it scales on demand and you only get billed for the actual runtime of your code. Potential use cases For SAFE apps we see various use cases for FAAS: Running recurring jobs to create statistics or maintenance actions via timer triggers Running jobs that can be processed async like creating accountings or sending email Command processing in CQRS apps via message queues or HTTP triggers Editing Functions in the Azure Portal The Azure Portal allows you to create and edit Functions and their source code via an online editor. For a short test go to the portal, click the \"New\" button and search for \"Function App\". Click through the wizard to create a new Function App. Open the app when it's created and add a new function. Pick \"Timer\" as scenario and F# as language. Replace the contents of function.json with: { \"bindings\": [ { \"name\": \"myTimer\", \"type\": \"timerTrigger\", \"direction\": \"in\", \"schedule\": \"0 * * * * *\" } ], \"disabled\": false } and replace the run.fsx with the following F# code: open System let minutesSince ( d : DateTime ) = ( DateTime . Now - d ). TotalMinutes let run ( myTimer : TimerInfo , log : TraceWriter ) = let meetupStart = new DateTime ( 2017 , 11 , 8 , 19 , 0 , 0 ) minutesSince meetupStart |> int |> sprintf \"Our meetup has been running for %d minutes\" |> log . Info Now observe the logs to see that the function runs every minute and outputs the message about the meetup duration. While it seems very convenient, the online editor should only be used for testing and prototyping. In SAFE-Stack you usually benefit from reusing your domain model at various places see Client/Server - so we recommend to use \"precompiled Azure Functions\" as described below. Deployment In SAFE-Stack scenarios we recommend all deployments should be automated. Here, we discuss two options for deploying your functions apps into Azure. Azure Functions Core Tools In the case of Function Apps the excellent Azure Functions Core Tools can be used. If you use core tools version 2 then the following should be added to your build/deploy script: dotnet publish - c Release func azure functionapp publish [ FunctionApp Name ] This will compile your Function App in release mode and push it to the Azure portal. In the case of a CI server etc., you will need to install the Functions Core Tools on the server and once per functions app log into the CI machine and explicitly authenticate it manually (see the Functions Core Tools docs). HTTPS Upload Since Azure Functions sits on top of Azure App Service, the same mechanisms for deployment there also exist here. In this case, you can use the exact same HTTPS upload capabilities of the App Service to upload a zip of your functions app into your Functions app. The standard SAFE Template can generate this for you for the core SAFE application as part of the FAKE script; the exact same mechanism can be utilised for your functions app. As per the standard App Service, HTTPS upload uses a user/pass supplied in the header of the zip which is PUT into the functions app. This user / pass can be taken from the App Service in the Azure Portal directly, or extracted during deployment of your ARM template (as per the FAKE script does for the App Service).","title":"Working with Azure functions"},{"location":"feature-azurefunctions/#going-serverless-with-safe","text":"With SAFE-Stack you can easily take advantage of serverless computing via Azure Functions . With Functions-As-A-Service (FAAS) you can focus on building your business logic and don't need to worry about provisioning and maintaining servers (hence \"serverless\"). Azure Functions provide a managed compute platform with high reliability. If you use a \"consumption plan\" it scales on demand and you only get billed for the actual runtime of your code.","title":"Going serverless with SAFE"},{"location":"feature-azurefunctions/#potential-use-cases","text":"For SAFE apps we see various use cases for FAAS: Running recurring jobs to create statistics or maintenance actions via timer triggers Running jobs that can be processed async like creating accountings or sending email Command processing in CQRS apps via message queues or HTTP triggers","title":"Potential use cases"},{"location":"feature-azurefunctions/#editing-functions-in-the-azure-portal","text":"The Azure Portal allows you to create and edit Functions and their source code via an online editor. For a short test go to the portal, click the \"New\" button and search for \"Function App\". Click through the wizard to create a new Function App. Open the app when it's created and add a new function. Pick \"Timer\" as scenario and F# as language. Replace the contents of function.json with: { \"bindings\": [ { \"name\": \"myTimer\", \"type\": \"timerTrigger\", \"direction\": \"in\", \"schedule\": \"0 * * * * *\" } ], \"disabled\": false } and replace the run.fsx with the following F# code: open System let minutesSince ( d : DateTime ) = ( DateTime . Now - d ). TotalMinutes let run ( myTimer : TimerInfo , log : TraceWriter ) = let meetupStart = new DateTime ( 2017 , 11 , 8 , 19 , 0 , 0 ) minutesSince meetupStart |> int |> sprintf \"Our meetup has been running for %d minutes\" |> log . Info Now observe the logs to see that the function runs every minute and outputs the message about the meetup duration. While it seems very convenient, the online editor should only be used for testing and prototyping. In SAFE-Stack you usually benefit from reusing your domain model at various places see Client/Server - so we recommend to use \"precompiled Azure Functions\" as described below.","title":"Editing Functions in the Azure Portal"},{"location":"feature-azurefunctions/#deployment","text":"In SAFE-Stack scenarios we recommend all deployments should be automated. Here, we discuss two options for deploying your functions apps into Azure.","title":"Deployment"},{"location":"feature-azurefunctions/#azure-functions-core-tools","text":"In the case of Function Apps the excellent Azure Functions Core Tools can be used. If you use core tools version 2 then the following should be added to your build/deploy script: dotnet publish - c Release func azure functionapp publish [ FunctionApp Name ] This will compile your Function App in release mode and push it to the Azure portal. In the case of a CI server etc., you will need to install the Functions Core Tools on the server and once per functions app log into the CI machine and explicitly authenticate it manually (see the Functions Core Tools docs).","title":"Azure Functions Core Tools"},{"location":"feature-azurefunctions/#https-upload","text":"Since Azure Functions sits on top of Azure App Service, the same mechanisms for deployment there also exist here. In this case, you can use the exact same HTTPS upload capabilities of the App Service to upload a zip of your functions app into your Functions app. The standard SAFE Template can generate this for you for the core SAFE application as part of the FAKE script; the exact same mechanism can be utilised for your functions app. As per the standard App Service, HTTPS upload uses a user/pass supplied in the header of the zip which is PUT into the functions app. This user / pass can be taken from the App Service in the Azure Portal directly, or extracted during deployment of your ARM template (as per the FAKE script does for the App Service).","title":"HTTPS Upload"},{"location":"feature-clientserver-basics/","text":"Sharing Types Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g Shared.fs . Then, create types in the file as needed e.g type Customer = { Id : int ; Name : string } Reference this file from your server project. You can now reference those types on the server. <Project Sdk= \"Microsoft.NET.Sdk\" > ... <ItemGroup> <Compile Include= \"../Shared/Shared.fs\" /> </ItemGroup> ... </Project> Finally, reference this file in your client project (as above). You can now reference those types on the client; Fable will automatically convert your F# types into Javascript in the background. Sharing Behaviour You can also share behaviour using the same mechanism at that for sharing types. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server. Fable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets including: ASP.NET Core (via Saturn) Azure Functions Javascript that runs in the browser Javascript that runs on mobile devices with React Native . Raspberry Pi (via .NET Core) You can read more about this on the Fable website .","title":"Sharing Types and Code"},{"location":"feature-clientserver-basics/#sharing-types","text":"Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g Shared.fs . Then, create types in the file as needed e.g type Customer = { Id : int ; Name : string } Reference this file from your server project. You can now reference those types on the server. <Project Sdk= \"Microsoft.NET.Sdk\" > ... <ItemGroup> <Compile Include= \"../Shared/Shared.fs\" /> </ItemGroup> ... </Project> Finally, reference this file in your client project (as above). You can now reference those types on the client; Fable will automatically convert your F# types into Javascript in the background.","title":"Sharing Types"},{"location":"feature-clientserver-basics/#sharing-behaviour","text":"You can also share behaviour using the same mechanism at that for sharing types. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server. Fable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets including: ASP.NET Core (via Saturn) Azure Functions Javascript that runs in the browser Javascript that runs on mobile devices with React Native . Raspberry Pi (via .NET Core) You can read more about this on the Fable website .","title":"Sharing Behaviour"},{"location":"feature-clientserver-bridge/","text":"Using F# on both client and server is at the core of the SAFE stack, as it simplifies the way we think about building web applications by using the same language, idioms and in many cases sharing our code and domain models. However, building a client and a server app requires a fundamentally different way of thinking. On the server side we build stateless APIs in Saturn that map HTTP requests to internal functionality, whereas on the frontend we use the Elmish model, implementing the model-view-update pattern : a stateful pattern that lets us think about the application state as it evolves while the application is running. Even though we use the same language across platforms, applying these two different programming models forces us to switch our way of thinking back and forth when writing code for the client and for the server. This is where the Elmish.Bridge library comes into play: it brings the Elmish programming model to the server and unifies the way we write the application as a whole. How does Elmish work on the server? Think of Elmish on the server as the model-view-update pattern but without the view part . Instead, you only need to implement init and update functions to manage the server state as it evolves while the server is running. Server state can contain data that is relevant to a single or all clients The dispatch loop running on the server is connected to the dispatch loop on the client via a persistent stateful websocket connection The update functions on client and server can exchange data via message passing. A simple example Let's see a simple example of how this might work in practice: // Client-side let update msg state = match msg with | LoadUsers -> // send the message to the server state , Cmd . bridgeSend ServerMsg . LoadUsers | UsersLoaded users -> // receive message from the server let nextState = { state with Users = users } nextState , Cmd . none // Server-side let update clientDispatch msg state = match msg with | ServerMsg . LoadUsers -> let loadUsersCmd = Cmd . ofAsync getUsersFromDb // unit -> Async<User list> () // input arg = unit UsersLoadedFromDb // User list -> ServerMsg DoNothing // ServerMsg state , loadUsersCmd | ServerMsg . UsersLoadedFromDbSuccess users -> // answer the current connected client with data clientDispatch ( ClientMsg . UsersLoaded users ) state , Cmd . none | ServerMsg . DoNothing -> state , Cmd . none The above example mimics what would have been a GET request to the server to get user data from database. However, now the client sends a fire-and-forget message to the server to load users, and at some point the server messages the current client back with the results. Notice that the server could have decided to do other things than just messaging the client back: for example, it could have broadcasted the same message to other clients updating their local state of the users. When to use Elmish.Bridge There are many scenarios where it makes sense to use Elmish.Bridge: Chat-like applications with many connected users through many channels Syncing price data in real-time while viewing ticket prices Multiplayer games that need real-time update of game states Other applications of web sockets through an Elmish model Things to consider The biggest distinction between using this and \"raw\" Saturn is that your web server becomes a stateful service. This introduces several differences for application design. The server state has a lifespan equal to the that of the process under which the server instance is running. This means if the server application restarts then the server state will be reset. The server state is local to the server instance . This means that if you run multiple web servers, they won't be sharing the same server state by default. As of now there is no built-in persistence for the state, but you can implement this yourself using any number of persistance layers such as Redis Cache, Azure Tables or Blobs etc. In addition Elmish.Bridge does not use standard HTTP verbs for communication, but rather websockets. Therefore, it is not a suitable technology for an open web server that can serve requests from other sources than Elmish.Bridge clients. Learn more about Elmish.Bridge Head over to Elmish.Bridge to learn more.","title":"Stateful Messaging through Bridge"},{"location":"feature-clientserver-bridge/#how-does-elmish-work-on-the-server","text":"Think of Elmish on the server as the model-view-update pattern but without the view part . Instead, you only need to implement init and update functions to manage the server state as it evolves while the server is running. Server state can contain data that is relevant to a single or all clients The dispatch loop running on the server is connected to the dispatch loop on the client via a persistent stateful websocket connection The update functions on client and server can exchange data via message passing.","title":"How does Elmish work on the server?"},{"location":"feature-clientserver-bridge/#a-simple-example","text":"Let's see a simple example of how this might work in practice: // Client-side let update msg state = match msg with | LoadUsers -> // send the message to the server state , Cmd . bridgeSend ServerMsg . LoadUsers | UsersLoaded users -> // receive message from the server let nextState = { state with Users = users } nextState , Cmd . none // Server-side let update clientDispatch msg state = match msg with | ServerMsg . LoadUsers -> let loadUsersCmd = Cmd . ofAsync getUsersFromDb // unit -> Async<User list> () // input arg = unit UsersLoadedFromDb // User list -> ServerMsg DoNothing // ServerMsg state , loadUsersCmd | ServerMsg . UsersLoadedFromDbSuccess users -> // answer the current connected client with data clientDispatch ( ClientMsg . UsersLoaded users ) state , Cmd . none | ServerMsg . DoNothing -> state , Cmd . none The above example mimics what would have been a GET request to the server to get user data from database. However, now the client sends a fire-and-forget message to the server to load users, and at some point the server messages the current client back with the results. Notice that the server could have decided to do other things than just messaging the client back: for example, it could have broadcasted the same message to other clients updating their local state of the users.","title":"A simple example"},{"location":"feature-clientserver-bridge/#when-to-use-elmishbridge","text":"There are many scenarios where it makes sense to use Elmish.Bridge: Chat-like applications with many connected users through many channels Syncing price data in real-time while viewing ticket prices Multiplayer games that need real-time update of game states Other applications of web sockets through an Elmish model","title":"When to use Elmish.Bridge"},{"location":"feature-clientserver-bridge/#things-to-consider","text":"The biggest distinction between using this and \"raw\" Saturn is that your web server becomes a stateful service. This introduces several differences for application design. The server state has a lifespan equal to the that of the process under which the server instance is running. This means if the server application restarts then the server state will be reset. The server state is local to the server instance . This means that if you run multiple web servers, they won't be sharing the same server state by default. As of now there is no built-in persistence for the state, but you can implement this yourself using any number of persistance layers such as Redis Cache, Azure Tables or Blobs etc. In addition Elmish.Bridge does not use standard HTTP verbs for communication, but rather websockets. Therefore, it is not a suitable technology for an open web server that can serve requests from other sources than Elmish.Bridge clients.","title":"Things to consider"},{"location":"feature-clientserver-bridge/#learn-more-about-elmishbridge","text":"Head over to Elmish.Bridge to learn more.","title":"Learn more about Elmish.Bridge"},{"location":"feature-clientserver-http/","text":"Client Server communication over HTTP Communicating over raw HTTP using Saturn has three main steps. 1. Load your data Start by creating a function on your server that returns some data: let loadCustomersFromDb () = [ { Id = 1 ; Name = \"Joe Bloggs\" } ] Next, create a method which returns the data as JSON within Giraffe's HTTP context. /// Returns the results of loadCustomersFromDb as JSON. let getCustomers next ctx = json ( loadCustomersFromDb () ) next ctx You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints. Also note the next and ctx arguments. These are used by Giraffe as part of its HTTP pipeline and are required by the json function (Note you can also use Successful.Ok instead of json , which will offer XML serialization as well). 2. Expose data through Saturn Now expose the api method using Saturn's router construct and add it to your overall application scope: let myApis = router { get \"/api/customers/\" getCustomers } For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the next and ctx arguments): let myApis = router { get \"/api/customers/\" ( json ( loadCustomersFromDb () )) } 3. Consume the endpoint from the client Finally, call the endpoint from your client application. promise { let! customers = Fetch . fetchAs < Customer list > \"api/customers\" ( Decode . Auto . generateDecoder () ) [] // do more with customers here... } Note the use of the promise { } computation expression. This behaves similarly to async { } blocks that you might already know, whilst the fetchAs function retrieves data from the HTTP endpoint specified. The JSON is deserialized as a Customer array using an automatically-generated \"decoder\" (see the section on serialization for more information).","title":"Messaging using HTTP"},{"location":"feature-clientserver-http/#client-server-communication-over-http","text":"Communicating over raw HTTP using Saturn has three main steps.","title":"Client Server communication over HTTP"},{"location":"feature-clientserver-http/#1-load-your-data","text":"Start by creating a function on your server that returns some data: let loadCustomersFromDb () = [ { Id = 1 ; Name = \"Joe Bloggs\" } ] Next, create a method which returns the data as JSON within Giraffe's HTTP context. /// Returns the results of loadCustomersFromDb as JSON. let getCustomers next ctx = json ( loadCustomersFromDb () ) next ctx You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints. Also note the next and ctx arguments. These are used by Giraffe as part of its HTTP pipeline and are required by the json function (Note you can also use Successful.Ok instead of json , which will offer XML serialization as well).","title":"1. Load your data"},{"location":"feature-clientserver-http/#2-expose-data-through-saturn","text":"Now expose the api method using Saturn's router construct and add it to your overall application scope: let myApis = router { get \"/api/customers/\" getCustomers } For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the next and ctx arguments): let myApis = router { get \"/api/customers/\" ( json ( loadCustomersFromDb () )) }","title":"2. Expose data through Saturn"},{"location":"feature-clientserver-http/#3-consume-the-endpoint-from-the-client","text":"Finally, call the endpoint from your client application. promise { let! customers = Fetch . fetchAs < Customer list > \"api/customers\" ( Decode . Auto . generateDecoder () ) [] // do more with customers here... } Note the use of the promise { } computation expression. This behaves similarly to async { } blocks that you might already know, whilst the fetchAs function retrieves data from the HTTP endpoint specified. The JSON is deserialized as a Customer array using an automatically-generated \"decoder\" (see the section on serialization for more information).","title":"3. Consume the endpoint from the client"},{"location":"feature-clientserver-remoting/","text":"Data sharing with Fable.Remoting Alongside raw HTTP, you can also use Fable.Remoting , which provides an RPC-style mechanism for calling server endpoints. With Remoting, you don't need to worry about the details of serialization or of how to consume the endpoint - instead, remoting lets you define you client-server interactions as a shared type that is commonly referred to as a protocol or contract . 1. Define a protocol Each field of the record is either of type Async<T> or a function that returns Async<T> , for example: type ICustomerApi = { getCustomers : unit -> Async < Customer list > findCustomerByName : string -> Async < Customer option > } The supported types used within the protocol can be any F# type: primitive values (int, string, DateTime, etc.), records, options, discriminated unions or collections etc. 2. Implement the protocol on the server On the server you would implement the protocol as follows: let getCustomers () = async { return [ { Id = 1 ; Name = \"John Doe\" } { Id = 2 ; Name = \"Jane Smith\" } ] } let findCustomerByName ( name : string ) = async { let! allCustomers = getCustomers () return allCustomers |> List . tryFind ( fun c -> c . Name = name ) } let customerApi : ICustomerApi = { getCustomers = getCustomers findCustomerByName = findCustomerByName } 3. Consume the protocol on the client After exposing an HttpHandler from customerApi you can start calling the API from the client. let api = Remoting . createApi () |> Remoting . buildProxy < ICustomerApi > async { let! customers = api . getCustomers () for customer in customers do printfn \"#%d => %s\" customer . Id customer . Name } Notice here, there is no need to configure routes or JSON serialization, worry about HTTP verbs, or even involve yourself with the Giraffe pipeline. If you open your browser network tab, you can easily inspect what remoting is doing behind the scenes.","title":"Messaging with Protocols"},{"location":"feature-clientserver-remoting/#data-sharing-with-fableremoting","text":"Alongside raw HTTP, you can also use Fable.Remoting , which provides an RPC-style mechanism for calling server endpoints. With Remoting, you don't need to worry about the details of serialization or of how to consume the endpoint - instead, remoting lets you define you client-server interactions as a shared type that is commonly referred to as a protocol or contract .","title":"Data sharing with Fable.Remoting"},{"location":"feature-clientserver-remoting/#1-define-a-protocol","text":"Each field of the record is either of type Async<T> or a function that returns Async<T> , for example: type ICustomerApi = { getCustomers : unit -> Async < Customer list > findCustomerByName : string -> Async < Customer option > } The supported types used within the protocol can be any F# type: primitive values (int, string, DateTime, etc.), records, options, discriminated unions or collections etc.","title":"1. Define a protocol"},{"location":"feature-clientserver-remoting/#2-implement-the-protocol-on-the-server","text":"On the server you would implement the protocol as follows: let getCustomers () = async { return [ { Id = 1 ; Name = \"John Doe\" } { Id = 2 ; Name = \"Jane Smith\" } ] } let findCustomerByName ( name : string ) = async { let! allCustomers = getCustomers () return allCustomers |> List . tryFind ( fun c -> c . Name = name ) } let customerApi : ICustomerApi = { getCustomers = getCustomers findCustomerByName = findCustomerByName }","title":"2. Implement the protocol on the server"},{"location":"feature-clientserver-remoting/#3-consume-the-protocol-on-the-client","text":"After exposing an HttpHandler from customerApi you can start calling the API from the client. let api = Remoting . createApi () |> Remoting . buildProxy < ICustomerApi > async { let! customers = api . getCustomers () for customer in customers do printfn \"#%d => %s\" customer . Id customer . Name } Notice here, there is no need to configure routes or JSON serialization, worry about HTTP verbs, or even involve yourself with the Giraffe pipeline. If you open your browser network tab, you can easily inspect what remoting is doing behind the scenes.","title":"3. Consume the protocol on the client"},{"location":"feature-clientserver-serialization/","text":"Serialization basics with Thoth When using basic HTTP communication between the client and server, you'll need to consider how to deserialize data from JSON to F# types. In order to guarantee that the serialization / deserialization routines between client and server are compatible, you should replace the JSON converter in Giraffe / Saturn with the Thoth library's serializer. This is the same library as that used in Fable for deserialization, and so will work seamlessly together. let configureSerialization ( services : IServiceCollection ) = services . AddSingleton < Giraffe . Serialization . Json . IJsonSerializer >( Thoth . Json . Giraffe . ThothSerializer () ) If you are using the SAFE Template , this will automatically be done for you in Server.fs . Approaches to deserialization Fable 2 uses the Thoth library for JSON deserialization, which makes use of decoders to convert JSON into F# values. There are generally two main approaches to take when doing this: automatic and manual decoders. Assume the following Customer record for the remaining examples. type Customer = { Id : int Name : string } Automatic Decoders Automatic decoders are the quickest and easier way to deserialize data. It works by Thoth trying to decode JSON automatically from a raw string to an F# type using automatic mapping rules. In the sample below, we fetch data from the /api/customers endpoint and have Thoth create a strongly-typed Decoder for a Customer array. fetchAs < Customer [] > \"/api/customers\" ( Decode . Auto . generateDecoder () ) [] If the serialization fails, Thoth will create an Error (rather than Ok ) value for this. Be aware that automatic decoders are designed to work with primitives, collections, F# records, tuples and discriminated unions but cannot deserialize classes. Improving efficiency with cached decoders You can reuse decoders when you know you'll be calling them often: // let-bound value that exists outside of the update function let customerDecoder = Decode . Auto . generateDecoder < Customer > () // inside the update function Fetch . fetchAs ( sprintf \"api/customers\" ) ( Decode . array customerDecoder [] ) Notice how the decoder is bound to a single Customer, and not an array. This way, we can also reuse the decoder on other routes, for example api/customers/1 which would return a single Customer object rather than a collection. Manual Decoders Manual decoders give you total control over how you rehydrate an object from JSON. Use them when: The JSON does not directly map 1:1 with your F# types You want flexibility to evolve JSON and F# types independently You are calling an external service and need fine-grained control over the deserialization process You are using F# on the client and another language on the server You create a manual decoder as follows: let customerDecoder : Decoder < Customer > = Decode . object ( fun get -> { Id = get . Required . Field \"id\" Decode . int Name = get . Optional . Field \"customerName\" Decode . string |> Option . defaultValue \"\" }) You can now replace the automatically generated decoder from earlier. You can also \"manually\" decode JSON to Customers as follows: Decode . fromString customerDecoder \"\"\"{ \"id\": 67, \"customerName\": \"Joe Bloggs\" }\"\"\" If decoding fails on any field, an error case will be returned. Handling \"unit\" calls You may design API methods that return unit i.e. they have no result. In such a case, you must currently do one of the following: Return some non-unit type e.g. boolean or int etc. and simply ignore it on the client response. Set the result type on the client as obj (or even _ - the F# compiler will infer obj for you). This will be correctly handled by Thoth and passed as a null object which can be safely ignored.","title":"Serialization in SAFE"},{"location":"feature-clientserver-serialization/#serialization-basics-with-thoth","text":"When using basic HTTP communication between the client and server, you'll need to consider how to deserialize data from JSON to F# types. In order to guarantee that the serialization / deserialization routines between client and server are compatible, you should replace the JSON converter in Giraffe / Saturn with the Thoth library's serializer. This is the same library as that used in Fable for deserialization, and so will work seamlessly together. let configureSerialization ( services : IServiceCollection ) = services . AddSingleton < Giraffe . Serialization . Json . IJsonSerializer >( Thoth . Json . Giraffe . ThothSerializer () ) If you are using the SAFE Template , this will automatically be done for you in Server.fs .","title":"Serialization basics with Thoth"},{"location":"feature-clientserver-serialization/#approaches-to-deserialization","text":"Fable 2 uses the Thoth library for JSON deserialization, which makes use of decoders to convert JSON into F# values. There are generally two main approaches to take when doing this: automatic and manual decoders. Assume the following Customer record for the remaining examples. type Customer = { Id : int Name : string }","title":"Approaches to deserialization"},{"location":"feature-clientserver-serialization/#automatic-decoders","text":"Automatic decoders are the quickest and easier way to deserialize data. It works by Thoth trying to decode JSON automatically from a raw string to an F# type using automatic mapping rules. In the sample below, we fetch data from the /api/customers endpoint and have Thoth create a strongly-typed Decoder for a Customer array. fetchAs < Customer [] > \"/api/customers\" ( Decode . Auto . generateDecoder () ) [] If the serialization fails, Thoth will create an Error (rather than Ok ) value for this. Be aware that automatic decoders are designed to work with primitives, collections, F# records, tuples and discriminated unions but cannot deserialize classes.","title":"Automatic Decoders"},{"location":"feature-clientserver-serialization/#improving-efficiency-with-cached-decoders","text":"You can reuse decoders when you know you'll be calling them often: // let-bound value that exists outside of the update function let customerDecoder = Decode . Auto . generateDecoder < Customer > () // inside the update function Fetch . fetchAs ( sprintf \"api/customers\" ) ( Decode . array customerDecoder [] ) Notice how the decoder is bound to a single Customer, and not an array. This way, we can also reuse the decoder on other routes, for example api/customers/1 which would return a single Customer object rather than a collection.","title":"Improving efficiency with cached decoders"},{"location":"feature-clientserver-serialization/#manual-decoders","text":"Manual decoders give you total control over how you rehydrate an object from JSON. Use them when: The JSON does not directly map 1:1 with your F# types You want flexibility to evolve JSON and F# types independently You are calling an external service and need fine-grained control over the deserialization process You are using F# on the client and another language on the server You create a manual decoder as follows: let customerDecoder : Decoder < Customer > = Decode . object ( fun get -> { Id = get . Required . Field \"id\" Decode . int Name = get . Optional . Field \"customerName\" Decode . string |> Option . defaultValue \"\" }) You can now replace the automatically generated decoder from earlier. You can also \"manually\" decode JSON to Customers as follows: Decode . fromString customerDecoder \"\"\"{ \"id\": 67, \"customerName\": \"Joe Bloggs\" }\"\"\" If decoding fails on any field, an error case will be returned.","title":"Manual Decoders"},{"location":"feature-clientserver-serialization/#handling-unit-calls","text":"You may design API methods that return unit i.e. they have no result. In such a case, you must currently do one of the following: Return some non-unit type e.g. boolean or int etc. and simply ignore it on the client response. Set the result type on the client as obj (or even _ - the F# compiler will infer obj for you). This will be correctly handled by Thoth and passed as a null object which can be safely ignored.","title":"Handling \"unit\" calls"},{"location":"feature-clientserver/","text":"One of the most powerful features of SAFE is the ability to seamlessly share code across client and server. Sharing Basics The basics of code sharing across client and server include: Sharing types . Useful for contracts between client and server, as well as to share a common domain. Sharing behaviour . In other words, functions that perform e.g. shared validation or similar. These two core areas are explained in more detail here . Sending messages between client and server In addition to types and messages, there are several technologies availabile in SAFE that allow you to send messages from client to server (and from server to client). Each has their own strengths and weaknesses: Raw HTTP using Saturn's routing capabilities. Contracts / protocols via Fable Remoting. Stateful servers through Elmish Bridge. Which technology should I use? The raw HTTP model provided by Saturn with router { } requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, using the raw HTTP model gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach. Alternatively, Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts and have guaranteed type-safety between both client and server. Consider using remoting for rapid prototyping, since JSON serialization and HTTP routing is handled by the library, you only think of your client-server code in terms of types and stateless functions. If you need full control over the HTTP channel for returning specific status codes, using custom HTTP verbs or working with headers, then remoting is probably not for you. Lastly, Elmish.Bridge provides an alternative way of modelling client/server communication. Unlike the other two mechanisms, Elmish Bridge provides the same Elmish model on the server as well as the client, as well as the ability to send notifications from the server back to connected clients via websockets. However, the Bridge model is inherently stateful, which means that a server restart could impact all connected clients. Fable.Remoting Raw HTTP Elmish.Bridge Client / Server support Very easy Easy Very Easy State model Stateless Stateless Stateful \"Open\" API? Yes Yes No HTTP Verbs? POST, GET Fully Configurable None Push messages? No No Yes Pipeline Control? Limited Full Limited Consider using a combination of multiple endpoints supporting combinations of the above to suit your needs!","title":"Sharing Overview"},{"location":"feature-clientserver/#sharing-basics","text":"The basics of code sharing across client and server include: Sharing types . Useful for contracts between client and server, as well as to share a common domain. Sharing behaviour . In other words, functions that perform e.g. shared validation or similar. These two core areas are explained in more detail here .","title":"Sharing Basics"},{"location":"feature-clientserver/#sending-messages-between-client-and-server","text":"In addition to types and messages, there are several technologies availabile in SAFE that allow you to send messages from client to server (and from server to client). Each has their own strengths and weaknesses: Raw HTTP using Saturn's routing capabilities. Contracts / protocols via Fable Remoting. Stateful servers through Elmish Bridge.","title":"Sending messages between client and server"},{"location":"feature-clientserver/#which-technology-should-i-use","text":"The raw HTTP model provided by Saturn with router { } requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, using the raw HTTP model gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach. Alternatively, Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts and have guaranteed type-safety between both client and server. Consider using remoting for rapid prototyping, since JSON serialization and HTTP routing is handled by the library, you only think of your client-server code in terms of types and stateless functions. If you need full control over the HTTP channel for returning specific status codes, using custom HTTP verbs or working with headers, then remoting is probably not for you. Lastly, Elmish.Bridge provides an alternative way of modelling client/server communication. Unlike the other two mechanisms, Elmish Bridge provides the same Elmish model on the server as well as the client, as well as the ability to send notifications from the server back to connected clients via websockets. However, the Bridge model is inherently stateful, which means that a server restart could impact all connected clients. Fable.Remoting Raw HTTP Elmish.Bridge Client / Server support Very easy Easy Very Easy State model Stateless Stateless Stateful \"Open\" API? Yes Yes No HTTP Verbs? POST, GET Fully Configurable None Push messages? No No Yes Pipeline Control? Limited Full Limited Consider using a combination of multiple endpoints supporting combinations of the above to suit your needs!","title":"Which technology should I use?"},{"location":"feature-hmr/","text":"Hot Module Replacement (HMR) allows to update the UI of an application while it is running, without a full reload. In SAFE stack apps, this can dramatically speed up the development for web and mobile GUIs, since there is no need to \"stop\" and \"reload\" and application. Instead, you can make changes to your views and have them immediately update in the browser, without the need to restart the application. How does it work? In case of web development, the webpack development server will automatically refresh the changed parts of your elmish views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through React Native 's own bundler. Why does it work so well with SAFE? Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case. Further reading Hot Module Replacement via webpack Introducing Hot Reloading in React Native","title":"Hot Module Replacement"},{"location":"feature-hmr/#how-does-it-work","text":"In case of web development, the webpack development server will automatically refresh the changed parts of your elmish views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through React Native 's own bundler.","title":"How does it work?"},{"location":"feature-hmr/#why-does-it-work-so-well-with-safe","text":"Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case.","title":"Why does it work so well with SAFE?"},{"location":"feature-hmr/#further-reading","text":"Hot Module Replacement via webpack Introducing Hot Reloading in React Native","title":"Further reading"},{"location":"feature-ssr/","text":"Server-Side Rendering (SSR) means that some parts of your application code can run on both the server and the client. For React this means that you can render your components directly to HTML on the server side (e.g. via a node.js server ), which allows for better search engine optimization (SEO) and gives a faster initial response, especially on mobile devices. The browser typically receives a static HTML site and starts updating the UI immediately; React's bundle code will be downloaded asynchronously and when it completes, the client-side JavaScript will take over via React's hydrate functionality. In the JavaScript ecosystem this is also known as an \"isomorphic\" or \"universal\" app. Why use SSR? Pros Better SEO support, as web crawlers will directly see the fully rendered HTML page. Faster time-to-content, especially on slow internet connections or devices. Cons Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server. Increased complexity of build and deployment processes. Increased server-side load. SSR on SAFE In SAFE, SSR can be done using fable-react . Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your Elmish views directly on .NET Core, with all the benefits of the .NET Core runtime. Further reading More details can be found in the SSR tutorial . The SAFE-BookStore sample project uses SSR.","title":"Server Side Rendering"},{"location":"feature-ssr/#why-use-ssr","text":"","title":"Why use SSR?"},{"location":"feature-ssr/#pros","text":"Better SEO support, as web crawlers will directly see the fully rendered HTML page. Faster time-to-content, especially on slow internet connections or devices.","title":"Pros"},{"location":"feature-ssr/#cons","text":"Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server. Increased complexity of build and deployment processes. Increased server-side load.","title":"Cons"},{"location":"feature-ssr/#ssr-on-safe","text":"In SAFE, SSR can be done using fable-react . Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your Elmish views directly on .NET Core, with all the benefits of the .NET Core runtime.","title":"SSR on SAFE"},{"location":"feature-ssr/#further-reading","text":"More details can be found in the SSR tutorial . The SAFE-BookStore sample project uses SSR.","title":"Further reading"},{"location":"intro/","text":"What is SAFE? The SAFE stack is the best way to write functional-first web applications . The SAFE stack allows you to develop web applications almost entirely in F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications. SAFE Stack is: Open-source Free Type-safe Flexible Cloud-ready The SAFE stack is made up of four components: A web server running on .NET Core for hosting back-end services in F# A hosting platform that provides simple, scalable deployment models plus associated platform services for application developers A mechanism to run F# in the web browser for client-side delivery of F# An F# programming model for client-side user interfaces Why SAFE? SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\". Create client / server applications entirely in F# Re-use development skills on client and server Rapidly create rich client-side web applications with no Javascript knowledge Runs on the latest .NET (and tested daily by Microsoft) Rapid development cycle with support for hot module replacement Interact with native Javascript libraries whenever needed Create client-side applications purely in F#, with full type checking for safety Seamlessly share code between client and server","title":"Introduction"},{"location":"intro/#what-is-safe","text":"The SAFE stack is the best way to write functional-first web applications . The SAFE stack allows you to develop web applications almost entirely in F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications. SAFE Stack is: Open-source Free Type-safe Flexible Cloud-ready The SAFE stack is made up of four components: A web server running on .NET Core for hosting back-end services in F# A hosting platform that provides simple, scalable deployment models plus associated platform services for application developers A mechanism to run F# in the web browser for client-side delivery of F# An F# programming model for client-side user interfaces","title":"What is SAFE?"},{"location":"intro/#why-safe","text":"SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\". Create client / server applications entirely in F# Re-use development skills on client and server Rapidly create rich client-side web applications with no Javascript knowledge Runs on the latest .NET (and tested daily by Microsoft) Rapid development cycle with support for hot module replacement Interact with native Javascript libraries whenever needed Create client-side applications purely in F#, with full type checking for safety Seamlessly share code between client and server","title":"Why SAFE?"},{"location":"learning/","text":"This section contains useful repositories that allow you to learn more about the SAFE stack, at your own pace. Tutorials SAFE Dojo This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations. The dojo takes around 90 minutes to complete if you have never worked with the stack before. SAFE Samples The following example repositories (and more!) can be found in the official SAFE Stack organisational GitHub page. SAFE Todo List The simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two. tabula-rasa A minimalistic real-worldish blog engine written entirely in F#. Specifically made as a learning resource when building apps with the SAFE stack. This application features many concerns of large apps such as logging, database access, secured remoting, web sockets and much more. SAFE Bookstore This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store. SAFE ConfPlanner This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture. SAFE Search This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways. SAFE Chat This application is a real-time chat application built on SAFE that uses the AKKA framework to manage actors that represent chat users, including Akka Streams and the Akkling F# library. SAFE Nightwatch This application is a sample mobile application using the React Native library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you. Videos SAFE apps with F# web stack at Lambda Days 2018 (Tomasz Heimowski) Modern app development with Fable and React Native at NDC Oslo 2017 (Steffen Forkmann) Reinventing MVC pattern for F# web development at NDC Oslo 2018 (Krzysztof Cieslak) Other Resources The Hanselminutes podcast: F# and the functional SAFE Stack with Krzysztof Cieslak Introducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps Learning about the F# SAFE stack High level introduction to the SAFE stack by Scott Hanselman","title":"Learning"},{"location":"learning/#tutorials","text":"","title":"Tutorials"},{"location":"learning/#safe-dojo","text":"This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations. The dojo takes around 90 minutes to complete if you have never worked with the stack before.","title":"SAFE Dojo"},{"location":"learning/#safe-samples","text":"The following example repositories (and more!) can be found in the official SAFE Stack organisational GitHub page.","title":"SAFE Samples"},{"location":"learning/#safe-todo-list","text":"The simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two.","title":"SAFE Todo List"},{"location":"learning/#tabula-rasa","text":"A minimalistic real-worldish blog engine written entirely in F#. Specifically made as a learning resource when building apps with the SAFE stack. This application features many concerns of large apps such as logging, database access, secured remoting, web sockets and much more.","title":"tabula-rasa"},{"location":"learning/#safe-bookstore","text":"This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.","title":"SAFE Bookstore"},{"location":"learning/#safe-confplanner","text":"This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.","title":"SAFE ConfPlanner"},{"location":"learning/#safe-search","text":"This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.","title":"SAFE Search"},{"location":"learning/#safe-chat","text":"This application is a real-time chat application built on SAFE that uses the AKKA framework to manage actors that represent chat users, including Akka Streams and the Akkling F# library.","title":"SAFE Chat"},{"location":"learning/#safe-nightwatch","text":"This application is a sample mobile application using the React Native library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.","title":"SAFE Nightwatch"},{"location":"learning/#videos","text":"SAFE apps with F# web stack at Lambda Days 2018 (Tomasz Heimowski) Modern app development with Fable and React Native at NDC Oslo 2017 (Steffen Forkmann) Reinventing MVC pattern for F# web development at NDC Oslo 2018 (Krzysztof Cieslak)","title":"Videos"},{"location":"learning/#other-resources","text":"The Hanselminutes podcast: F# and the functional SAFE Stack with Krzysztof Cieslak Introducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps Learning about the F# SAFE stack High level introduction to the SAFE stack by Scott Hanselman","title":"Other Resources"},{"location":"legacy-template-fake/","text":"The template uses FAKE to build the application. Generated FAKE script contains a number of useful build targets: \"Run\" target dotnet fake build - -target run This target is used for development purposes, and provides a great live-reload experience. It pulls down any dependencies required for both the client and server, before running both the client and server in a \"watch\" mode, so any changes you make on either side will be automatically applied without your needing to restart the application. Navigating to http://localhost:8080/ will load the application. \"Bundle\" target dotnet fake build As Bundle is the default target, you do not need to supply any arguments to FAKE. This target is used to both build and package up your application in a production fashion, ready for deployment. It will restore all dependencies and build both the client and server in a production and release mode respectively, and correctly copy the outputs into the deploy folder in the root of the application. Once your build has completed, you can launch the entire application locally to test it as follows: cd deploy Server Navigating to http://localhost:8085/ will load the application. \"Azure\" target dotnet fake build - -target azure This target will deploy your application to Azure with a fully configured Application Insights instance. You do not need to pre-create any resources in Azure - the template will create everything needed, using free SKUs so you can test without any costs. You must already have an Azure account and will be prompted to log into it during the deployment process. This build step uses both the Azure CLI and Farmer projects to create all resources in just a few lines of code. The name of resources will be generated based on the folder in which you created the application. These may be incompatible with Azure naming rules, or may already be in use (Azure web applications must be globally unique) so you may have to modify the name of the webapp to pick one that is acceptable. \"RunTests\" target dotnet fake build - -target runtests This target behaves similarly to the standard Run target, except that it launches the unit tests for both client and server. The server tests will run immediately in the console, using watch mode to allow you to rapidly iterate on your tests. The client tests run in the browser . Again, they use a watch mode so you can make changes to your client code and see the results in the browser. Launch the client tests on http://localhost:8081/","title":"The FAKE script"},{"location":"legacy-template-fake/#run-target","text":"dotnet fake build - -target run This target is used for development purposes, and provides a great live-reload experience. It pulls down any dependencies required for both the client and server, before running both the client and server in a \"watch\" mode, so any changes you make on either side will be automatically applied without your needing to restart the application. Navigating to http://localhost:8080/ will load the application.","title":"\"Run\" target"},{"location":"legacy-template-fake/#bundle-target","text":"dotnet fake build As Bundle is the default target, you do not need to supply any arguments to FAKE. This target is used to both build and package up your application in a production fashion, ready for deployment. It will restore all dependencies and build both the client and server in a production and release mode respectively, and correctly copy the outputs into the deploy folder in the root of the application. Once your build has completed, you can launch the entire application locally to test it as follows: cd deploy Server Navigating to http://localhost:8085/ will load the application.","title":"\"Bundle\" target"},{"location":"legacy-template-fake/#azure-target","text":"dotnet fake build - -target azure This target will deploy your application to Azure with a fully configured Application Insights instance. You do not need to pre-create any resources in Azure - the template will create everything needed, using free SKUs so you can test without any costs. You must already have an Azure account and will be prompted to log into it during the deployment process. This build step uses both the Azure CLI and Farmer projects to create all resources in just a few lines of code. The name of resources will be generated based on the folder in which you created the application. These may be incompatible with Azure naming rules, or may already be in use (Azure web applications must be globally unique) so you may have to modify the name of the webapp to pick one that is acceptable.","title":"\"Azure\" target"},{"location":"legacy-template-fake/#runtests-target","text":"dotnet fake build - -target runtests This target behaves similarly to the standard Run target, except that it launches the unit tests for both client and server. The server tests will run immediately in the console, using watch mode to allow you to rapidly iterate on your tests. The client tests run in the browser . Again, they use a watch mode so you can make changes to your client code and see the results in the browser. Launch the client tests on http://localhost:8081/","title":"\"RunTests\" target"},{"location":"news/","text":"News and Announcements 2021 28th June - SAFE v3 is Live! After a long beta test period, we're excited to launch SAFE 3! The new template upgrades SAFE to .NET 5 compatibility, Fable 3 and the latest versions of Giraffe and Saturn. We've also introduced the use of the popular Feliz domain-specific language (DSL), upgraded all documentation and made the build process even easier to use. We're super excited about this update as well as hearing about your suggestions and ideas to make it even better in the future. 2020 22nd August - SAFE v2 Launches! It's taken a while, but we're delighted to announce the launch of SAFE v2. The new template has been drastically slimmed down and provides a highly streamlined approach, whilst we've incorporated requested features such as testing support out of the box. We're looking forward to building on the new template with improved documentation, a set of easy-to-follow recipes for common tasks as well as new demos, exercises and a set of new wrappers around popular JS and React libraries. 2018 5th August We're pleased to see that the Suave team has clarified their license and explicitly removed the dependency on the Logary package. However, our decision to remove Suave from the SAFE stack remains: Suave no longer forms a part of the strategic goals of the SAFE project , and our server-side focus remains on improving the experience for both Giraffe and Saturn. We nonetheless wish the Suave project, team and contributors the best of luck for the future. 18th June Due to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team has today made the unamimous decision to remove Suave as a recommended option on the SAFE stack . We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling. Our default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP.NET. SAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.","title":"News"},{"location":"news/#news-and-announcements","text":"","title":"News and Announcements"},{"location":"news/#2021","text":"","title":"2021"},{"location":"news/#28th-june-safe-v3-is-live","text":"After a long beta test period, we're excited to launch SAFE 3! The new template upgrades SAFE to .NET 5 compatibility, Fable 3 and the latest versions of Giraffe and Saturn. We've also introduced the use of the popular Feliz domain-specific language (DSL), upgraded all documentation and made the build process even easier to use. We're super excited about this update as well as hearing about your suggestions and ideas to make it even better in the future.","title":"28th June - SAFE v3 is Live!"},{"location":"news/#2020","text":"","title":"2020"},{"location":"news/#22nd-august-safe-v2-launches","text":"It's taken a while, but we're delighted to announce the launch of SAFE v2. The new template has been drastically slimmed down and provides a highly streamlined approach, whilst we've incorporated requested features such as testing support out of the box. We're looking forward to building on the new template with improved documentation, a set of easy-to-follow recipes for common tasks as well as new demos, exercises and a set of new wrappers around popular JS and React libraries.","title":"22nd August - SAFE v2 Launches!"},{"location":"news/#2018","text":"","title":"2018"},{"location":"news/#5th-august","text":"We're pleased to see that the Suave team has clarified their license and explicitly removed the dependency on the Logary package. However, our decision to remove Suave from the SAFE stack remains: Suave no longer forms a part of the strategic goals of the SAFE project , and our server-side focus remains on improving the experience for both Giraffe and Saturn. We nonetheless wish the Suave project, team and contributors the best of luck for the future.","title":"5th August"},{"location":"news/#18th-june","text":"Due to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team has today made the unamimous decision to remove Suave as a recommended option on the SAFE stack . We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling. Our default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP.NET. SAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.","title":"18th June"},{"location":"overview/","text":"SAFE Stack components The SAFE acronym is made up of four separate components: S aturn for back-end services in F# A zure as a hosting platform plus associated platform services F able for running F# in the web browser E lmish for client-side user interfaces flowchart TB subgraph Azure App Service Host Saturn(Saturn) Elmish(Elmish) <--> Fable(Fable) Saturn <-- HTTP --> Fable end Saturn The Saturn library builds on top of the solid foundation of both the F#-friendly Giraffe and the high performance, rock-solid ASP.NET Core web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve. Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model. Microsoft Azure Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions. Fable Fable is an F# to JavaScript compiler, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed. Elmish The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the React framework. Further reading Please also feel free to read this blog series on the Compositional IT website for more details on the history of SAFE. Are there alternative components in the SAFE stack? Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs: Giraffe is a programming model designed for F# that runs on ASP.NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe. Freya is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP.NET Core. AWS is Amazon's cloud compute offering, providing a large number of services available globally. WebSharper is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models. Falco is a toolkit for building functional-first, fast and fault-tolerant web applications using F#. Built upon the high-performance primitives of ASP.NET Core and optimized for building HTTP applications quickly.","title":"SAFE Stack Overview"},{"location":"overview/#safe-stack-components","text":"The SAFE acronym is made up of four separate components: S aturn for back-end services in F# A zure as a hosting platform plus associated platform services F able for running F# in the web browser E lmish for client-side user interfaces flowchart TB subgraph Azure App Service Host Saturn(Saturn) Elmish(Elmish) <--> Fable(Fable) Saturn <-- HTTP --> Fable end","title":"SAFE Stack components"},{"location":"overview/#saturn","text":"The Saturn library builds on top of the solid foundation of both the F#-friendly Giraffe and the high performance, rock-solid ASP.NET Core web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve. Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model.","title":"Saturn"},{"location":"overview/#microsoft-azure","text":"Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.","title":"Microsoft Azure"},{"location":"overview/#fable","text":"Fable is an F# to JavaScript compiler, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.","title":"Fable"},{"location":"overview/#elmish","text":"The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the React framework.","title":"Elmish"},{"location":"overview/#further-reading","text":"Please also feel free to read this blog series on the Compositional IT website for more details on the history of SAFE.","title":"Further reading"},{"location":"overview/#are-there-alternative-components-in-the-safe-stack","text":"Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs: Giraffe is a programming model designed for F# that runs on ASP.NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe. Freya is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP.NET Core. AWS is Amazon's cloud compute offering, providing a large number of services available globally. WebSharper is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models. Falco is a toolkit for building functional-first, fast and fault-tolerant web applications using F#. Built upon the high-performance primitives of ASP.NET Core and optimized for building HTTP applications quickly.","title":"Are there alternative components in the SAFE stack?"},{"location":"quickstart/","text":"This page provides some basic guidance on getting up and running with your first SAFE application. Install pre-requisites You'll need to install the following pre-requisites in order to build SAFE applications The .NET 5 SDK node.js (>= 8.0) npm Azure CLI (optional - required for Azure deployments) Install an F# code editor You'll also want an IDE to create F# applications. We recommend one of the following great IDEs: VS Code + Ionide extension Visual Studio 2019 Jetbrains Rider Create your first SAFE app Open a command prompt Create a new directory on your machine and navigate into it Enter dotnet new -i SAFE.Template to install the SAFE project template ( only required once ) Enter dotnet new SAFE to create a new SAFE project Enter dotnet tool restore to install local tools like Fable. Enter dotnet run to build and run the app Open a web browser and navigate to http://localhost:8080. Congratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watches your project for changes; whenever you save a file in the client project it will refresh the browser automatically ; if you save a file in the server project it will also restart the server in the background. The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. Alternatively there is a \"bare-bones\" SAFE Stack app with minimal value-add features. Take a look at the template options to see a side by side comparison of features available between the standard and minimal template. Troubleshooting Still have issues getting started? Check out the troubleshooting page.","title":"Quick Start"},{"location":"quickstart/#install-pre-requisites","text":"You'll need to install the following pre-requisites in order to build SAFE applications The .NET 5 SDK node.js (>= 8.0) npm Azure CLI (optional - required for Azure deployments)","title":"Install pre-requisites"},{"location":"quickstart/#install-an-f-code-editor","text":"You'll also want an IDE to create F# applications. We recommend one of the following great IDEs: VS Code + Ionide extension Visual Studio 2019 Jetbrains Rider","title":"Install an F# code editor"},{"location":"quickstart/#create-your-first-safe-app","text":"Open a command prompt Create a new directory on your machine and navigate into it Enter dotnet new -i SAFE.Template to install the SAFE project template ( only required once ) Enter dotnet new SAFE to create a new SAFE project Enter dotnet tool restore to install local tools like Fable. Enter dotnet run to build and run the app Open a web browser and navigate to http://localhost:8080. Congratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watches your project for changes; whenever you save a file in the client project it will refresh the browser automatically ; if you save a file in the server project it will also restart the server in the background. The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. Alternatively there is a \"bare-bones\" SAFE Stack app with minimal value-add features. Take a look at the template options to see a side by side comparison of features available between the standard and minimal template.","title":"Create your first SAFE app"},{"location":"quickstart/#troubleshooting","text":"Still have issues getting started? Check out the troubleshooting page.","title":"Troubleshooting"},{"location":"support/","text":"The following companies provide commercial training, support, consultancy and development services for SAFE Stack applications. Compositional IT Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions. Lambda Factory Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow. Fuzzy Cloud Fuzzy Cloud is a fast-growing team of highly skilled and passionate IT professionals who can deliver services that help you speed up innovation and maximize efficiency. Our services are dynamic, scalable, resilient and responsive enabling rapid growth and high value for our clients. We take a highly collaborative approach to align our services with your business goals. We provide consulting in area like Cloud, Cross Platform mobile development, Machine Learning etc using Languages like F#, Python, Dart and few others. The F# Community The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out. Social You can also reach out to the SAFE team on @safe_stack or on the regular F# channels on Slack: either the official F# Foundation Slack (an F# Foundation membership is required) or on the Functional Programming Slack . We'll be expanding this over time.","title":"Support"},{"location":"support/#compositional-it","text":"Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.","title":"Compositional IT"},{"location":"support/#lambda-factory","text":"Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.","title":"Lambda Factory"},{"location":"support/#fuzzy-cloud","text":"Fuzzy Cloud is a fast-growing team of highly skilled and passionate IT professionals who can deliver services that help you speed up innovation and maximize efficiency. Our services are dynamic, scalable, resilient and responsive enabling rapid growth and high value for our clients. We take a highly collaborative approach to align our services with your business goals. We provide consulting in area like Cloud, Cross Platform mobile development, Machine Learning etc using Languages like F#, Python, Dart and few others.","title":"Fuzzy Cloud"},{"location":"support/#the-f-community","text":"The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.","title":"The F# Community"},{"location":"support/#social","text":"You can also reach out to the SAFE team on @safe_stack or on the regular F# channels on Slack: either the official F# Foundation Slack (an F# Foundation membership is required) or on the Functional Programming Slack . We'll be expanding this over time.","title":"Social"},{"location":"template-overview/","text":"The SAFE Template is a dotnet CLI template for SAFE Stack projects, designed to get you up and running as quickly as possible, with flexible options to suit your application. The template gets you up and running with the most common elements of the stack with minimal configuration options. All template options come with a fully working end-to-end SAFE application with known-good dependencies on client (NPM) and server (NuGet), as well as a preconfigured webpack configuration file. Using the template Refer to the Quick Start guide to see basic guidance on how to install and use the template. Template options The template provides two simple modes: the standard and minimal template. Standard Template The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. dotnet new SAFE Use this configuration if.. .. you are brand new to SAFE Stack, or F#, or software development in general, and want a \"recommended\" experience .. you want to get up and running as quickly as possible .. you are an F# developer and want an experience that uses tools that you are familiar with Minimal Template The minimal template is a \"bare-bones\" SAFE Stack app with minimal value-add features. dotnet new SAFE -m Use this configuration if.. .. you are a SAFE Stack expert and want to hand-craft your own SAFE Stack application from a minimal starting point .. you are coming from a web development background and know your way around tools like NPM and Webpack .. you are comfortable creating your own build and packaging pipeline .. you want to see \"behind the magic\" and get a feel for what is happening behind the scenes At-a-glance Comparison Feature Standard Minimal Styling Feliz.Bulma None Starter App Todo List None Communication Fable Remoting Raw HTTP .NET Package Manager Paket NuGet Build Tooling FAKE None Azure Integration Farmer None Testing Support Client and Server None Recommendations VS Code Extensions, Code Style No","title":"Overview"},{"location":"template-overview/#using-the-template","text":"Refer to the Quick Start guide to see basic guidance on how to install and use the template.","title":"Using the template"},{"location":"template-overview/#template-options","text":"The template provides two simple modes: the standard and minimal template.","title":"Template options"},{"location":"template-overview/#standard-template","text":"The standard template creates an opinionated SAFE Stack app that contains everything you'll need to start developing, testing and deploying applications into Azure. dotnet new SAFE Use this configuration if.. .. you are brand new to SAFE Stack, or F#, or software development in general, and want a \"recommended\" experience .. you want to get up and running as quickly as possible .. you are an F# developer and want an experience that uses tools that you are familiar with","title":"Standard Template"},{"location":"template-overview/#minimal-template","text":"The minimal template is a \"bare-bones\" SAFE Stack app with minimal value-add features. dotnet new SAFE -m Use this configuration if.. .. you are a SAFE Stack expert and want to hand-craft your own SAFE Stack application from a minimal starting point .. you are coming from a web development background and know your way around tools like NPM and Webpack .. you are comfortable creating your own build and packaging pipeline .. you want to see \"behind the magic\" and get a feel for what is happening behind the scenes","title":"Minimal Template"},{"location":"template-overview/#at-a-glance-comparison","text":"Feature Standard Minimal Styling Feliz.Bulma None Starter App Todo List None Communication Fable Remoting Raw HTTP .NET Package Manager Paket NuGet Build Tooling FAKE None Azure Integration Farmer None Testing Support Client and Server None Recommendations VS Code Extensions, Code Style No","title":"At-a-glance Comparison"},{"location":"template-safe-commands/","text":"The SAFE Stack now runs FAKE using a console app rather than a script. \"Run\" dotnet run Used for development purposes, and provides a great live-reload experience. It pulls down any dependencies required for both the client and server, before running both the client and server in a \"watch\" mode, so any changes you make on either side will be automatically applied without your needing to restart the application. Navigating to http://localhost:8080/ will load the application. \"Bundle\" target dotnet run Bundle Used to both build and package up your application in a production fashion, ready for deployment. It will restore all dependencies and build both the client and server in a production and release mode respectively, and correctly copy the outputs into the deploy folder in the root of the application. Once your build has completed, you can launch the entire application locally to test it as follows: cd deploy Server Navigating to http://localhost:8085/ will load the application. \"Azure\" target dotnet run Azure This target will deploy your application to Azure with a fully configured Application Insights instance. You do not need to pre-create any resources in Azure - the template will create everything needed, using free SKUs so you can test without any costs. You must already have an Azure account and will be prompted to log into it during the deployment process. This build step uses both the Azure CLI and Farmer projects to create all resources in just a few lines of code. The name of resources will be generated based on the folder in which you created the application. These may be incompatible with Azure naming rules, or may already be in use (Azure web applications must be globally unique) so you may have to modify the name of the webapp to pick one that is acceptable. \"RunTests\" target dotnet run RunTests This target behaves similarly to the standard Run target, except that it launches the unit tests for both client and server. The server tests will run immediately in the console, using watch mode to allow you to rapidly iterate on your tests. The client tests run in the browser . Again, they use a watch mode so you can make changes to your client code and see the results in the browser. Launch the client tests on http://localhost:8081/ \"Format\" target dotnet run Format This target will format all the F# files in the src folder using Fantomas . Out of the box, Fantomas tries to reformat the code according to the F# style guide by Microsoft . For more info, check out the documentation .","title":"Commands"},{"location":"template-safe-commands/#run","text":"dotnet run Used for development purposes, and provides a great live-reload experience. It pulls down any dependencies required for both the client and server, before running both the client and server in a \"watch\" mode, so any changes you make on either side will be automatically applied without your needing to restart the application. Navigating to http://localhost:8080/ will load the application.","title":"\"Run\""},{"location":"template-safe-commands/#bundle-target","text":"dotnet run Bundle Used to both build and package up your application in a production fashion, ready for deployment. It will restore all dependencies and build both the client and server in a production and release mode respectively, and correctly copy the outputs into the deploy folder in the root of the application. Once your build has completed, you can launch the entire application locally to test it as follows: cd deploy Server Navigating to http://localhost:8085/ will load the application.","title":"\"Bundle\" target"},{"location":"template-safe-commands/#azure-target","text":"dotnet run Azure This target will deploy your application to Azure with a fully configured Application Insights instance. You do not need to pre-create any resources in Azure - the template will create everything needed, using free SKUs so you can test without any costs. You must already have an Azure account and will be prompted to log into it during the deployment process. This build step uses both the Azure CLI and Farmer projects to create all resources in just a few lines of code. The name of resources will be generated based on the folder in which you created the application. These may be incompatible with Azure naming rules, or may already be in use (Azure web applications must be globally unique) so you may have to modify the name of the webapp to pick one that is acceptable.","title":"\"Azure\" target"},{"location":"template-safe-commands/#runtests-target","text":"dotnet run RunTests This target behaves similarly to the standard Run target, except that it launches the unit tests for both client and server. The server tests will run immediately in the console, using watch mode to allow you to rapidly iterate on your tests. The client tests run in the browser . Again, they use a watch mode so you can make changes to your client code and see the results in the browser. Launch the client tests on http://localhost:8081/","title":"\"RunTests\" target"},{"location":"template-safe-commands/#format-target","text":"dotnet run Format This target will format all the F# files in the src folder using Fantomas . Out of the box, Fantomas tries to reformat the code according to the F# style guide by Microsoft . For more info, check out the documentation .","title":"\"Format\" target"},{"location":"testimonials/","text":"Please feel free to submit a PR to add testimonials to this page! msu solutions GmbH SAFE gives us a fast development cycle for our web and mobile platforms We at msu solutions GmbH are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with. Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. Especially the commercial support for SAFE is very important for us and our customers. Goswin Rothenthal It just works! The docs are very detailed and helpful. I got the template up and running on a public URL on Azure within one hour. Without any issues. Even though I am new to dotnet core and Azure. Demetrix SAFE was the perfect place to start our biological design and data management platform Demetrix uses F# for DNA design and data management in our research pipeline. Our data systems are built on top of SAFE and it was a great experience for both veteran F# developers and people new to the environment. I would start with SAFE again in a heartbeat for a new project. We shared some of our experiences at Open F# 2018. Microdesk Spoil your customers with F# and the SAFE stack! Porting a production web app from TypeScript/React to use the SAFE stack turned out to be a huge win. Sharing F# models on the front and back-end allows you to leverage the excellent F# compiler and type system when designing and refactoring your codebase. Using a type provider (in our case, SQLProvider) extends this coverage to your database as well. This means that changes to any part of your application will be picked up by the compiler which will essentially guide you to every relevant place in the source code that needs to be updated. This is so effective that once you experience it, you will never want to be without it. On the front end, the Elmish pattern, which may look intimidating at first glance, is actually quite fun and intuitive to write. More importantly, it guides you into the \"pit of success\" by making you write highly testable \"pure functions\" that outline your UI state transitions (in your update function). Putting all state transitions in one place becomes a breath of fresh air because it eliminates the spaghetti code that can happen in MVVM view models of even modest complexity. Do you have a complex \"sort\" that needs to be handled in your update ? You can easily write a unit test in F# that passes in the relevant command input for that. No mocking is required because it will be a pure function! If you still feel leery of the Elmish pattern, you are free to use React Hooks API or any other pattern you prefer. There are also many excellent external libraries - i.e. Feliz - that allow you to optionally use the Elmish pattern on only certain pages, among other things. Worried about getting stuck? Don't worry because the F# community will practially crawl all over themselves to be the first to answer you question. There are also options for professional consultation as well. The community support is amazing! The SAFE stack is designed to be as turn-key as possible, but there are also plenty of opportunities to customize the stack as you see fit. Overall, the SAFE stack has allowed me to completely spoil a very demanding customer with timely, bug-free deliverables. Jake Witcher I really appreciate the effort that went in to this! The F# SAFE stack documentation is incredibly well done. One of the best features is the learning resources page that includes GitHub repos of example projects. Casper Bollen Never did Computer Science The SAFE stack enables me to create full backend to frontend web apps in a matter of weeks!! Leko Thomas Recipes are concise solve only one problem and are composable I find SAFE stack recipes have so much value. Thank you! Please keep on doing it. James Randall After a year I still feel like F# with the SAFE stack is like high octane rocket fuel for developers. The F# community have created, and made very accessible, a fantastic set of tools that allow you to write F# end to end on the web and in a way that embraces the existing world.","title":"Testimonials"},{"location":"testimonials/#msu-solutions-gmbh","text":"SAFE gives us a fast development cycle for our web and mobile platforms We at msu solutions GmbH are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with. Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. Especially the commercial support for SAFE is very important for us and our customers.","title":"msu solutions GmbH"},{"location":"testimonials/#goswin-rothenthal","text":"It just works! The docs are very detailed and helpful. I got the template up and running on a public URL on Azure within one hour. Without any issues. Even though I am new to dotnet core and Azure.","title":"Goswin Rothenthal"},{"location":"testimonials/#demetrix","text":"SAFE was the perfect place to start our biological design and data management platform Demetrix uses F# for DNA design and data management in our research pipeline. Our data systems are built on top of SAFE and it was a great experience for both veteran F# developers and people new to the environment. I would start with SAFE again in a heartbeat for a new project. We shared some of our experiences at Open F# 2018.","title":"Demetrix"},{"location":"testimonials/#microdesk","text":"Spoil your customers with F# and the SAFE stack! Porting a production web app from TypeScript/React to use the SAFE stack turned out to be a huge win. Sharing F# models on the front and back-end allows you to leverage the excellent F# compiler and type system when designing and refactoring your codebase. Using a type provider (in our case, SQLProvider) extends this coverage to your database as well. This means that changes to any part of your application will be picked up by the compiler which will essentially guide you to every relevant place in the source code that needs to be updated. This is so effective that once you experience it, you will never want to be without it. On the front end, the Elmish pattern, which may look intimidating at first glance, is actually quite fun and intuitive to write. More importantly, it guides you into the \"pit of success\" by making you write highly testable \"pure functions\" that outline your UI state transitions (in your update function). Putting all state transitions in one place becomes a breath of fresh air because it eliminates the spaghetti code that can happen in MVVM view models of even modest complexity. Do you have a complex \"sort\" that needs to be handled in your update ? You can easily write a unit test in F# that passes in the relevant command input for that. No mocking is required because it will be a pure function! If you still feel leery of the Elmish pattern, you are free to use React Hooks API or any other pattern you prefer. There are also many excellent external libraries - i.e. Feliz - that allow you to optionally use the Elmish pattern on only certain pages, among other things. Worried about getting stuck? Don't worry because the F# community will practially crawl all over themselves to be the first to answer you question. There are also options for professional consultation as well. The community support is amazing! The SAFE stack is designed to be as turn-key as possible, but there are also plenty of opportunities to customize the stack as you see fit. Overall, the SAFE stack has allowed me to completely spoil a very demanding customer with timely, bug-free deliverables.","title":"Microdesk"},{"location":"testimonials/#jake-witcher","text":"I really appreciate the effort that went in to this! The F# SAFE stack documentation is incredibly well done. One of the best features is the learning resources page that includes GitHub repos of example projects.","title":"Jake Witcher"},{"location":"testimonials/#casper-bollen","text":"Never did Computer Science The SAFE stack enables me to create full backend to frontend web apps in a matter of weeks!!","title":"Casper Bollen"},{"location":"testimonials/#leko-thomas","text":"Recipes are concise solve only one problem and are composable I find SAFE stack recipes have so much value. Thank you! Please keep on doing it.","title":"Leko Thomas"},{"location":"testimonials/#james-randall","text":"After a year I still feel like F# with the SAFE stack is like high octane rocket fuel for developers. The F# community have created, and made very accessible, a fantastic set of tools that allow you to write F# end to end on the web and in a way that embraces the existing world.","title":"James Randall"},{"location":"recipes/template/","text":"How do I create a SAFE recipe? Follow the following pattern and headings and the guide below. Best practices DO focus on integration between different components in the SAFE Stack e.g. how to connect Fable apps to Saturn backend etc. DO focus on getting results quickly. DO consider both template versions e.g. make the recipe suitable for both \"minimal\" and \"full\" template options Do NOT reproduce reference documentation from \"source\" technologies e.g. do NOT replicate documentation from Saturn or Fable sites. DO link to reference documentation from source technologies. Do NOT create reference documentation in a recipe. DO use simple code snippets where appropriate. How Do I < insert task here >? Start by writing a short introduction of a few sentences. Explain what the recipe is about, and problems it solves. Which technologies does it utilise, and what are the alternatives etc.? Remember to link the first instance of any technology to the appropriate docs elsewhere within this site, or to the homepage of the technology (or both!). Step-by-step Guide Write clear instructions on how to get to the desired outcome. The step-by-step instructions should be clear, short, easy to understand with possibly a use case and an example at the end if suitable. If you have a step in this section that is relevant to some other recipe we have here in the docs, such as adding a package to a SAFE app, link it to that relevant page. See here for an example recipe.","title":"Create a new Recipe"},{"location":"recipes/template/#how-do-i-create-a-safe-recipe","text":"Follow the following pattern and headings and the guide below.","title":"How do I create a SAFE recipe?"},{"location":"recipes/template/#best-practices","text":"DO focus on integration between different components in the SAFE Stack e.g. how to connect Fable apps to Saturn backend etc. DO focus on getting results quickly. DO consider both template versions e.g. make the recipe suitable for both \"minimal\" and \"full\" template options Do NOT reproduce reference documentation from \"source\" technologies e.g. do NOT replicate documentation from Saturn or Fable sites. DO link to reference documentation from source technologies. Do NOT create reference documentation in a recipe. DO use simple code snippets where appropriate.","title":"Best practices"},{"location":"recipes/template/#how-do-i-insert-task-here","text":"Start by writing a short introduction of a few sentences. Explain what the recipe is about, and problems it solves. Which technologies does it utilise, and what are the alternatives etc.? Remember to link the first instance of any technology to the appropriate docs elsewhere within this site, or to the homepage of the technology (or both!).","title":"How Do I &lt; insert task here &gt;?"},{"location":"recipes/template/#step-by-step-guide","text":"Write clear instructions on how to get to the desired outcome. The step-by-step instructions should be clear, short, easy to understand with possibly a use case and an example at the end if suitable. If you have a step in this section that is relevant to some other recipe we have here in the docs, such as adding a package to a SAFE app, link it to that relevant page. See here for an example recipe.","title":"Step-by-step Guide"},{"location":"recipes/build/add-build-script/","text":"How do I add build automation to the project? FAKE Fake is a DSL for build tasks that is modular, extensible and easy to start with. Fake allows you to easily build, bundle, deploy your app and more by executing a single command. The standard template comes with a FAKE project by default, so this recipe only applies to the minimal template . 1. Create a build project Create a new console app called 'Build' at the root of your solution dotnet new console - lang f # - n Build - o . We are creating the project directly at the root of the solution in order to allow us to execute the build without needing to navigate into a subfolder. 2. Create a build script Open the project you just created in your IDE and rename the module it contains from Program.fs to Build.fs . This renaming is't explicitly necessary, however it keeps your solution consistent with other SAFE apps and is a better name for the file really. If you just rename the file directly rather than in your IDE, then the Build project won't be able to find it unless you edit the Build.fsproj file as well Open Build.fs and paste in the following code. open Fake.Core open Fake.IO open System let redirect createProcess = createProcess |> CreateProcess . redirectOutputIfNotRedirected |> CreateProcess . withOutputEvents Console . WriteLine Console . WriteLine let createProcess exe arg dir = CreateProcess . fromRawCommandLine exe arg |> CreateProcess . withWorkingDirectory dir |> CreateProcess . ensureExitCode let dotnet = createProcess \"dotnet\" let npm = let npmPath = match ProcessUtils . tryFindFileOnPath \"npm\" with | Some path -> path | None -> failwith \"npm was not found in path.\" createProcess npmPath let run proc arg dir = proc arg dir |> Proc . run |> ignore let execContext = Context . FakeExecutionContext . Create false \"build.fsx\" [ ] Context . setExecutionContext ( Context . RuntimeContext . Fake execContext ) Target . create \"Clean\" ( fun _ -> Shell . cleanDir ( Path . getFullName \"deploy\" )) Target . create \"InstallClient\" ( fun _ -> run npm \"install\" \".\" ) Target . create \"Run\" ( fun _ -> run dotnet \"build\" ( Path . getFullName \"src/Shared\" ) [ dotnet \"watch run\" ( Path . getFullName \"src/Server\" ) dotnet \"fable watch --run webpack-dev-server\" ( Path . getFullName \"src/Client\" ) ] |> Seq . toArray |> Array . map redirect |> Array . Parallel . map Proc . run |> ignore ) open Fake.Core.TargetOperators let dependencies = [ \"Clean\" ==> \"InstallClient\" ==> \"Run\" ] [< EntryPoint >] let main args = try match args with | [| target |] -> Target . runOrDefault target | _ -> Target . runOrDefault \"Run\" 0 with e -> printfn \"%A\" e 1 3. Add the project to the solution Run the following command dotnet sln add Build.fsproj 4. Installing dependencies You will need to install the following dependencies: Fake.Core.Target Fake.IO.FileSystem We recommend migrating to Paket . It is possible to use FAKE without Paket, however this will not be covered in this recipe. 5. Run the app At the root of the solution, run dotnet paket install to install all your dependencies. If you now execute dotnet run , the default target will be run. This will build the app in development mode and launch it locally. To learn more about targets and FAKE in general, see Getting Started with FAKE .","title":"Add build automation"},{"location":"recipes/build/add-build-script/#how-do-i-add-build-automation-to-the-project","text":"","title":"How do I add build automation to the project?"},{"location":"recipes/build/add-build-script/#fake","text":"Fake is a DSL for build tasks that is modular, extensible and easy to start with. Fake allows you to easily build, bundle, deploy your app and more by executing a single command. The standard template comes with a FAKE project by default, so this recipe only applies to the minimal template .","title":"FAKE"},{"location":"recipes/build/add-build-script/#1-create-a-build-project","text":"Create a new console app called 'Build' at the root of your solution dotnet new console - lang f # - n Build - o . We are creating the project directly at the root of the solution in order to allow us to execute the build without needing to navigate into a subfolder.","title":"1. Create a build project"},{"location":"recipes/build/add-build-script/#2-create-a-build-script","text":"Open the project you just created in your IDE and rename the module it contains from Program.fs to Build.fs . This renaming is't explicitly necessary, however it keeps your solution consistent with other SAFE apps and is a better name for the file really. If you just rename the file directly rather than in your IDE, then the Build project won't be able to find it unless you edit the Build.fsproj file as well Open Build.fs and paste in the following code. open Fake.Core open Fake.IO open System let redirect createProcess = createProcess |> CreateProcess . redirectOutputIfNotRedirected |> CreateProcess . withOutputEvents Console . WriteLine Console . WriteLine let createProcess exe arg dir = CreateProcess . fromRawCommandLine exe arg |> CreateProcess . withWorkingDirectory dir |> CreateProcess . ensureExitCode let dotnet = createProcess \"dotnet\" let npm = let npmPath = match ProcessUtils . tryFindFileOnPath \"npm\" with | Some path -> path | None -> failwith \"npm was not found in path.\" createProcess npmPath let run proc arg dir = proc arg dir |> Proc . run |> ignore let execContext = Context . FakeExecutionContext . Create false \"build.fsx\" [ ] Context . setExecutionContext ( Context . RuntimeContext . Fake execContext ) Target . create \"Clean\" ( fun _ -> Shell . cleanDir ( Path . getFullName \"deploy\" )) Target . create \"InstallClient\" ( fun _ -> run npm \"install\" \".\" ) Target . create \"Run\" ( fun _ -> run dotnet \"build\" ( Path . getFullName \"src/Shared\" ) [ dotnet \"watch run\" ( Path . getFullName \"src/Server\" ) dotnet \"fable watch --run webpack-dev-server\" ( Path . getFullName \"src/Client\" ) ] |> Seq . toArray |> Array . map redirect |> Array . Parallel . map Proc . run |> ignore ) open Fake.Core.TargetOperators let dependencies = [ \"Clean\" ==> \"InstallClient\" ==> \"Run\" ] [< EntryPoint >] let main args = try match args with | [| target |] -> Target . runOrDefault target | _ -> Target . runOrDefault \"Run\" 0 with e -> printfn \"%A\" e 1","title":"2. Create a build script"},{"location":"recipes/build/add-build-script/#3-add-the-project-to-the-solution","text":"Run the following command dotnet sln add Build.fsproj","title":"3. Add the project to the solution"},{"location":"recipes/build/add-build-script/#4-installing-dependencies","text":"You will need to install the following dependencies: Fake.Core.Target Fake.IO.FileSystem We recommend migrating to Paket . It is possible to use FAKE without Paket, however this will not be covered in this recipe.","title":"4. Installing dependencies"},{"location":"recipes/build/add-build-script/#5-run-the-app","text":"At the root of the solution, run dotnet paket install to install all your dependencies. If you now execute dotnet run , the default target will be run. This will build the app in development mode and launch it locally. To learn more about targets and FAKE in general, see Getting Started with FAKE .","title":"5. Run the app"},{"location":"recipes/build/bundle-app/","text":"How do I bundle my SAFE application? When developing your SAFE application, the local runtime experience uses WebPack to run the client and redirect API calls to the server on a different port . However, when you deploy your application, you'll need to run your Saturn server which will serve up statically-built client resources (HTML, JavaScript, CSS etc.). I'm using the standard template 1. Run the FAKE script If you created your SAFE app using the recommended defaults, your application already has a FAKE script which will do the bundling for you. You can create a bundle using the following command: dotnet run Bundle This will build and package up both the client and server and place them into the /deploy folder at the root of the repository. See here for more details on this build target. I'm using the minimal template If you created your SAFE app using the minimal option, you need to bundle up the client and server separately. 1. Bundle the Client (Fable) application Execute the following commands: npm install dotnet tool restore dotnet fable src/Client --run webpack This will build the client project and copy all outputs into /deploy/public . 2. Bundle the Server (Saturn) application Execute the following commands: cd src/Server dotnet publish -c release -o ../../deploy This will bundle the server project and copy all outputs into the deploy folder. Testing the bundle Navigate to the deploy folder at the root of your repository. Run the Server.exe application. Navigate in your browser to http://localhost:8085 . You should now see your SAFE application. Further reading See this article for more information on architectural concerns regarding the move from dev to production and bundling SAFE Stack applications.","title":"Package my SAFE app for deployment"},{"location":"recipes/build/bundle-app/#how-do-i-bundle-my-safe-application","text":"When developing your SAFE application, the local runtime experience uses WebPack to run the client and redirect API calls to the server on a different port . However, when you deploy your application, you'll need to run your Saturn server which will serve up statically-built client resources (HTML, JavaScript, CSS etc.).","title":"How do I bundle my SAFE application?"},{"location":"recipes/build/bundle-app/#im-using-the-standard-template","text":"","title":"I'm using the standard template"},{"location":"recipes/build/bundle-app/#1-run-the-fake-script","text":"If you created your SAFE app using the recommended defaults, your application already has a FAKE script which will do the bundling for you. You can create a bundle using the following command: dotnet run Bundle This will build and package up both the client and server and place them into the /deploy folder at the root of the repository. See here for more details on this build target.","title":"1. Run the FAKE script"},{"location":"recipes/build/bundle-app/#im-using-the-minimal-template","text":"If you created your SAFE app using the minimal option, you need to bundle up the client and server separately.","title":"I'm using the minimal template"},{"location":"recipes/build/bundle-app/#1-bundle-the-client-fable-application","text":"Execute the following commands: npm install dotnet tool restore dotnet fable src/Client --run webpack This will build the client project and copy all outputs into /deploy/public .","title":"1. Bundle the Client (Fable) application"},{"location":"recipes/build/bundle-app/#2-bundle-the-server-saturn-application","text":"Execute the following commands: cd src/Server dotnet publish -c release -o ../../deploy This will bundle the server project and copy all outputs into the deploy folder.","title":"2. Bundle the Server (Saturn) application"},{"location":"recipes/build/bundle-app/#testing-the-bundle","text":"Navigate to the deploy folder at the root of your repository. Run the Server.exe application. Navigate in your browser to http://localhost:8085 . You should now see your SAFE application.","title":"Testing the bundle"},{"location":"recipes/build/bundle-app/#further-reading","text":"See this article for more information on architectural concerns regarding the move from dev to production and bundling SAFE Stack applications.","title":"Further reading"},{"location":"recipes/build/docker-image/","text":"How do I build with docker? Using Docker makes it possible to deploy your application as a docker container or release an image on docker hub. This recipe walks you through creating a Dockerfile and automating the build and test process with Docker Hub . 1. Create a .dockerignore file Create a .dockerignore file with the same contents as .gitignore Linux cp .gitignore .dockerignore Windows copy .gitignore .dockerignore Now, add the following lines to the .dockerignore file: .git 2. Create the dockerfile Create a Dockerfile with the following contents: FROM mcr.microsoft.com/dotnet/sdk:5.0 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY . . RUN dotnet tool restore RUN dotnet run Bundle FROM mcr.microsoft.com/dotnet/aspnet:5.0-alpine COPY --from = build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ] This uses multistage builds to keep the final image small. Using the minimal template? Replace the line RUN dotnet run Bundle with RUN npm install RUN dotnet fable src/Client --run webpack RUN cd src/Server && dotnet publish -c release -o ../../deploy 3. Building and running with docker locally Build the image docker build -t my-safe-app . Run the container docker run -it -p 8085:8085 my-safe-app Because the build is done entirely in docker, Docker Hub automated builds can be setup to automatically build and push the docker image. 4. Testing the server Create a docker-compose.server.test.yml file with the following contents: version: '3.4' services: sut: build: target: build context: . working_dir: /workspace/tests/Server command: dotnet run To run the tests execute the command docker-compose -f docker-compose.server.test.yml up --build You can add server tests to the minimal template with the testing the server recipe. The template is not currently setup for automating the client tests in ci. Docker Hub can also run automated tests for you. Follow the instructions to enable Autotest on docker hub. 5. Making the docker build faster Not recommended for most applications If you often build with docker locally, you may wish to make the build faster by optimising the Dockerfile for caching. For example, it is not necessary to download all paket and npm dependencies on every build unless there have been changes to the dependencies. Furthermore, the client and server can be built in separate build stages so that they are cached independently. Enable Docker BuildKit to build them concurrently. This comes at the expense of making the dockerfile more complex; if any changes are made to the build such as adding new projects or migrating package managers, the dockerfile must be updated accordingly. The following should be a good starting point but is not guarenteed to work. FROM mcr.microsoft.com/dotnet/sdk:5.0 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY .config .config RUN dotnet tool restore COPY .paket .paket COPY paket.dependencies paket.lock ./ FROM build as server-build COPY src/Shared src/Shared COPY src/Server src/Server RUN cd src/Server && dotnet publish -c release -o ../../deploy FROM build as client-build COPY package.json package-lock.json ./ RUN npm install COPY webpack.config.js ./ COPY src/Shared src/Shared COPY src/Client src/Client RUN dotnet fable src/Client --run webpack FROM mcr.microsoft.com/dotnet/aspnet:5.0-alpine COPY --from = server-build /workspace/deploy /app COPY --from = client-build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ]","title":"Create a docker image"},{"location":"recipes/build/docker-image/#how-do-i-build-with-docker","text":"Using Docker makes it possible to deploy your application as a docker container or release an image on docker hub. This recipe walks you through creating a Dockerfile and automating the build and test process with Docker Hub .","title":"How do I build with docker?"},{"location":"recipes/build/docker-image/#1-create-a-dockerignore-file","text":"Create a .dockerignore file with the same contents as .gitignore","title":"1. Create a .dockerignore file"},{"location":"recipes/build/docker-image/#linux","text":"cp .gitignore .dockerignore","title":"Linux"},{"location":"recipes/build/docker-image/#windows","text":"copy .gitignore .dockerignore Now, add the following lines to the .dockerignore file: .git","title":"Windows"},{"location":"recipes/build/docker-image/#2-create-the-dockerfile","text":"Create a Dockerfile with the following contents: FROM mcr.microsoft.com/dotnet/sdk:5.0 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY . . RUN dotnet tool restore RUN dotnet run Bundle FROM mcr.microsoft.com/dotnet/aspnet:5.0-alpine COPY --from = build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ] This uses multistage builds to keep the final image small.","title":"2. Create the dockerfile"},{"location":"recipes/build/docker-image/#using-the-minimal-template","text":"Replace the line RUN dotnet run Bundle with RUN npm install RUN dotnet fable src/Client --run webpack RUN cd src/Server && dotnet publish -c release -o ../../deploy","title":"Using the minimal template?"},{"location":"recipes/build/docker-image/#3-building-and-running-with-docker-locally","text":"Build the image docker build -t my-safe-app . Run the container docker run -it -p 8085:8085 my-safe-app Because the build is done entirely in docker, Docker Hub automated builds can be setup to automatically build and push the docker image.","title":"3. Building and running with docker locally"},{"location":"recipes/build/docker-image/#4-testing-the-server","text":"Create a docker-compose.server.test.yml file with the following contents: version: '3.4' services: sut: build: target: build context: . working_dir: /workspace/tests/Server command: dotnet run To run the tests execute the command docker-compose -f docker-compose.server.test.yml up --build You can add server tests to the minimal template with the testing the server recipe. The template is not currently setup for automating the client tests in ci. Docker Hub can also run automated tests for you. Follow the instructions to enable Autotest on docker hub.","title":"4. Testing the server"},{"location":"recipes/build/docker-image/#5-making-the-docker-build-faster","text":"Not recommended for most applications If you often build with docker locally, you may wish to make the build faster by optimising the Dockerfile for caching. For example, it is not necessary to download all paket and npm dependencies on every build unless there have been changes to the dependencies. Furthermore, the client and server can be built in separate build stages so that they are cached independently. Enable Docker BuildKit to build them concurrently. This comes at the expense of making the dockerfile more complex; if any changes are made to the build such as adding new projects or migrating package managers, the dockerfile must be updated accordingly. The following should be a good starting point but is not guarenteed to work. FROM mcr.microsoft.com/dotnet/sdk:5.0 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY .config .config RUN dotnet tool restore COPY .paket .paket COPY paket.dependencies paket.lock ./ FROM build as server-build COPY src/Shared src/Shared COPY src/Server src/Server RUN cd src/Server && dotnet publish -c release -o ../../deploy FROM build as client-build COPY package.json package-lock.json ./ RUN npm install COPY webpack.config.js ./ COPY src/Shared src/Shared COPY src/Client src/Client RUN dotnet fable src/Client --run webpack FROM mcr.microsoft.com/dotnet/aspnet:5.0-alpine COPY --from = server-build /workspace/deploy /app COPY --from = client-build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ]","title":"5. Making the docker build faster"},{"location":"recipes/build/remove-fake/","text":"How do I remove the use of FAKE? FAKE is a tool for build automation. The standard SAFE template comes with a ready-made build project at the root of the solution that provides support for many common SAFE tasks. If you would prefer not to use FAKE, you can of course simply ignore it, but this recipes shows how to completely remove it from your repository. It is important to note that having removed FAKE, you will have to follow a more manual approach to each of these processes. This recipe will only include instructions on how to build and deploy the application after removing FAKE. Note that the minimal template does not use FAKE by default, and this recipe only applies to the standard template . 1. Build project Delete Build.fs , Build.fsproj , Helpers.fs , paket.references at the root of the solution. 2. Dependencies Remove the following dependencies dotnet paket remove Fake . Core . Target dotnet paket remove Fake . IO . FileSystem dotnet paket remove Farmer Running the App Now that you have the FAKE dependencies removed, you will have to separately run the server and the client. 1. Start the Server Navigate to src/Server inside a terminal and execute dotnet run . 2. Start the Client Execute the following commands inside a terminal at the root of the solution . dotnet tool restore npm install dotnet fable src/Client --run webpack-dev-server The app will now be running at http://0.0.0.0:8080/ . Navigate to this address in a browser to see your app running. Bundling the App See this guide to learn how to package a SAFE application for deployment to e.g. Azure.","title":"Remove FAKE"},{"location":"recipes/build/remove-fake/#how-do-i-remove-the-use-of-fake","text":"FAKE is a tool for build automation. The standard SAFE template comes with a ready-made build project at the root of the solution that provides support for many common SAFE tasks. If you would prefer not to use FAKE, you can of course simply ignore it, but this recipes shows how to completely remove it from your repository. It is important to note that having removed FAKE, you will have to follow a more manual approach to each of these processes. This recipe will only include instructions on how to build and deploy the application after removing FAKE. Note that the minimal template does not use FAKE by default, and this recipe only applies to the standard template .","title":"How do I remove the use of FAKE?"},{"location":"recipes/build/remove-fake/#1-build-project","text":"Delete Build.fs , Build.fsproj , Helpers.fs , paket.references at the root of the solution.","title":"1. Build project"},{"location":"recipes/build/remove-fake/#2-dependencies","text":"Remove the following dependencies dotnet paket remove Fake . Core . Target dotnet paket remove Fake . IO . FileSystem dotnet paket remove Farmer","title":"2. Dependencies"},{"location":"recipes/build/remove-fake/#running-the-app","text":"Now that you have the FAKE dependencies removed, you will have to separately run the server and the client.","title":"Running the App"},{"location":"recipes/build/remove-fake/#1-start-the-server","text":"Navigate to src/Server inside a terminal and execute dotnet run .","title":"1. Start the Server"},{"location":"recipes/build/remove-fake/#2-start-the-client","text":"Execute the following commands inside a terminal at the root of the solution . dotnet tool restore npm install dotnet fable src/Client --run webpack-dev-server The app will now be running at http://0.0.0.0:8080/ . Navigate to this address in a browser to see your app running.","title":"2. Start the Client"},{"location":"recipes/build/remove-fake/#bundling-the-app","text":"See this guide to learn how to package a SAFE application for deployment to e.g. Azure.","title":"Bundling the App"},{"location":"recipes/client-server/fable-remoting/","text":"How Do I Add Support for Fable Remoting? Fable Remoting is a type-safe RPC communication layer for SAFE apps. It uses HTTP behind the scenes, but allows you to program against protocols that exist across the application without needing to think about the HTTP plumbing, and is a great fit for the majority of SAFE applications. Note that the standard template uses Fable Remoting. This recipe only applies to the minimal template . 1. Install NuGet Packages Add Fable.Remoting.Giraffe to the Server and Fable.Remoting.Client to the Client. See How Do I Add a NuGet Package to the Server and How Do I Add a NuGet Package to the Client . 2. Create the API protocol You now need to create the protocol, or contract, of the API we\u2019ll be creating. Insert the following below the Route module in Shared.fs : type IMyApi = { hello : unit -> Async < string > } 3. Create the routing function We need to provide a basic routing function in order to ensure client and server communicate on the same endpoint. Find the Route module in src/Shared/Shared.fs and replace it with the following: module Route = let builder typeName methodName = sprintf \"/api/%s/%s\" typeName methodName 4. Create the protocol implementation We now need to provide an implementation of the protocol on the server. Open src/Server/Server.fs and insert the following right after the open statements: let myApi = { hello = fun () -> async { return \"Hello from SAFE!\" } } 5. Hook into ASP.NET We now need to \"adapt\" Fable Remoting into the ASP.NET pipeline by converting it into a Giraffe HTTP Handler. Don't worry - this is not hard. Find webApp in Server.fs and replace it with the following: open Fable.Remoting.Server open Fable.Remoting.Giraffe let webApp = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder // use the routing function from step 3 |> Remoting . fromValue myApi // use the myApi implementation from step 4 |> Remoting . buildHttpHandler // adapt it to Giraffe's HTTP Handler 6. Create the Client proxy We now need a corresponding client proxy in order to be able to connect to the server. Open src/Client/Client.fs and insert the following right after the Msg type: open Fable.Remoting.Client let myApi = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder |> Remoting . buildProxy < IMyApi > 7. Make calls to the Server Replace the following two lines in the init function in Client.fs : let getHello () = Fetch . get < unit , string > Route . hello let cmd = Cmd . OfPromise . perform getHello () GotHello with this: let cmd = Cmd . OfAsync . perform myApi . hello () GotHello Done! At this point, the app should work just as it did before. Now, expanding the API and adding a new endpoint is as easy as adding a new field to the API protocol we defined in Shared.fs , editing the myApi record in Server.fs with the implementation, and finally making calls from the proxy.","title":"Add support for Fable Remoting"},{"location":"recipes/client-server/fable-remoting/#how-do-i-add-support-for-fable-remoting","text":"Fable Remoting is a type-safe RPC communication layer for SAFE apps. It uses HTTP behind the scenes, but allows you to program against protocols that exist across the application without needing to think about the HTTP plumbing, and is a great fit for the majority of SAFE applications. Note that the standard template uses Fable Remoting. This recipe only applies to the minimal template .","title":"How Do I Add Support for Fable Remoting?"},{"location":"recipes/client-server/fable-remoting/#1-install-nuget-packages","text":"Add Fable.Remoting.Giraffe to the Server and Fable.Remoting.Client to the Client. See How Do I Add a NuGet Package to the Server and How Do I Add a NuGet Package to the Client .","title":"1. Install NuGet Packages"},{"location":"recipes/client-server/fable-remoting/#2-create-the-api-protocol","text":"You now need to create the protocol, or contract, of the API we\u2019ll be creating. Insert the following below the Route module in Shared.fs : type IMyApi = { hello : unit -> Async < string > }","title":"2. Create the API protocol"},{"location":"recipes/client-server/fable-remoting/#3-create-the-routing-function","text":"We need to provide a basic routing function in order to ensure client and server communicate on the same endpoint. Find the Route module in src/Shared/Shared.fs and replace it with the following: module Route = let builder typeName methodName = sprintf \"/api/%s/%s\" typeName methodName","title":"3. Create the routing function"},{"location":"recipes/client-server/fable-remoting/#4-create-the-protocol-implementation","text":"We now need to provide an implementation of the protocol on the server. Open src/Server/Server.fs and insert the following right after the open statements: let myApi = { hello = fun () -> async { return \"Hello from SAFE!\" } }","title":"4. Create the protocol implementation"},{"location":"recipes/client-server/fable-remoting/#5-hook-into-aspnet","text":"We now need to \"adapt\" Fable Remoting into the ASP.NET pipeline by converting it into a Giraffe HTTP Handler. Don't worry - this is not hard. Find webApp in Server.fs and replace it with the following: open Fable.Remoting.Server open Fable.Remoting.Giraffe let webApp = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder // use the routing function from step 3 |> Remoting . fromValue myApi // use the myApi implementation from step 4 |> Remoting . buildHttpHandler // adapt it to Giraffe's HTTP Handler","title":"5. Hook into ASP.NET"},{"location":"recipes/client-server/fable-remoting/#6-create-the-client-proxy","text":"We now need a corresponding client proxy in order to be able to connect to the server. Open src/Client/Client.fs and insert the following right after the Msg type: open Fable.Remoting.Client let myApi = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder |> Remoting . buildProxy < IMyApi >","title":"6. Create the Client proxy"},{"location":"recipes/client-server/fable-remoting/#7-make-calls-to-the-server","text":"Replace the following two lines in the init function in Client.fs : let getHello () = Fetch . get < unit , string > Route . hello let cmd = Cmd . OfPromise . perform getHello () GotHello with this: let cmd = Cmd . OfAsync . perform myApi . hello () GotHello","title":"7. Make calls to the Server"},{"location":"recipes/client-server/fable-remoting/#done","text":"At this point, the app should work just as it did before. Now, expanding the API and adding a new endpoint is as easy as adding a new field to the API protocol we defined in Shared.fs , editing the myApi record in Server.fs with the implementation, and finally making calls from the proxy.","title":"Done!"},{"location":"recipes/client-server/messaging-post/","text":"How do I send and receive data using POST? This recipe shows how to create an endpoint on the server and hook up it up to the client using HTTP POST. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server. A POST endpoint is normally used to send data from the client to the server in the body, for example from a form. This is useful when we need to supply more data than can easily be provided in the URI. You may wish to use POST for \"write\" operations and use GETs for \"reads\", however this is a highly opinionated topic that is beyond the scope of this recipe. I'm using the standard template (Fable Remoting) Fable Remoting takes care of deciding whether to use POST or GET etc. - you don't have to worry about this. Refer to this recipe for more details. I'm using the minimal template (Raw HTTP) In Shared 1. Create contract Create the type that will store the payload sent from the client to the server. type SaveCustomerRequest = { Name : string Age : int } On the Client 1. Call the endpoint Create a new function saveCustomer that will call the server. It supplies the customer to save, which is serialized and sent to the server in the body of the message. let saveCustomer customer = let save customer = Fetch . post < SaveCustomerRequest , int > ( \"/api/customer\" , customer ) Cmd . OfPromise . perform save customer CustomerSaved The generic arguments of Fetch.post are the input and output types. The example above shows that the input is of type SaveCustomerRequest with the response will contain an integer value. This may be the ID generated by the server for the save operation. This can now be called from within your update function e.g. | SaveCustomer request -> model , saveCustomer request | CustomerSaved generatedId -> { model with GeneratedCustomerId = Some generatedId ; Message = \"Saved customer!\" }, Cmd . none On the Server 1. Write implementation Create a function that can extract the payload from the body of the request using Giraffe's built-in model binding support : open FSharp.Control.Tasks open Giraffe open Microsoft.AspNetCore.Http open Shared /// Extracts the request from the body and saves to the database. let saveCustomer next ( ctx : HttpContext ) = task { let! customer = ctx . BindModelAsync < SaveCustomerRequest > () do ! Database . saveCustomer customer return ! Successful . OK \"Saved customer\" next ctx } 2. Expose your function Tie your function into the router, using the post verb instead of get . let webApp = router { post \"/api/customer\" saveCustomer // Add this }","title":"Post data to the server"},{"location":"recipes/client-server/messaging-post/#how-do-i-send-and-receive-data-using-post","text":"This recipe shows how to create an endpoint on the server and hook up it up to the client using HTTP POST. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server. A POST endpoint is normally used to send data from the client to the server in the body, for example from a form. This is useful when we need to supply more data than can easily be provided in the URI. You may wish to use POST for \"write\" operations and use GETs for \"reads\", however this is a highly opinionated topic that is beyond the scope of this recipe.","title":"How do I send and receive data using POST?"},{"location":"recipes/client-server/messaging-post/#im-using-the-standard-template-fable-remoting","text":"Fable Remoting takes care of deciding whether to use POST or GET etc. - you don't have to worry about this. Refer to this recipe for more details.","title":"I'm using the standard template (Fable Remoting)"},{"location":"recipes/client-server/messaging-post/#im-using-the-minimal-template-raw-http","text":"","title":"I'm using the minimal template (Raw HTTP)"},{"location":"recipes/client-server/messaging-post/#in-shared","text":"","title":"In Shared"},{"location":"recipes/client-server/messaging-post/#1-create-contract","text":"Create the type that will store the payload sent from the client to the server. type SaveCustomerRequest = { Name : string Age : int }","title":"1. Create contract"},{"location":"recipes/client-server/messaging-post/#on-the-client","text":"","title":"On the Client"},{"location":"recipes/client-server/messaging-post/#1-call-the-endpoint","text":"Create a new function saveCustomer that will call the server. It supplies the customer to save, which is serialized and sent to the server in the body of the message. let saveCustomer customer = let save customer = Fetch . post < SaveCustomerRequest , int > ( \"/api/customer\" , customer ) Cmd . OfPromise . perform save customer CustomerSaved The generic arguments of Fetch.post are the input and output types. The example above shows that the input is of type SaveCustomerRequest with the response will contain an integer value. This may be the ID generated by the server for the save operation. This can now be called from within your update function e.g. | SaveCustomer request -> model , saveCustomer request | CustomerSaved generatedId -> { model with GeneratedCustomerId = Some generatedId ; Message = \"Saved customer!\" }, Cmd . none","title":"1. Call the endpoint"},{"location":"recipes/client-server/messaging-post/#on-the-server","text":"","title":"On the Server"},{"location":"recipes/client-server/messaging-post/#1-write-implementation","text":"Create a function that can extract the payload from the body of the request using Giraffe's built-in model binding support : open FSharp.Control.Tasks open Giraffe open Microsoft.AspNetCore.Http open Shared /// Extracts the request from the body and saves to the database. let saveCustomer next ( ctx : HttpContext ) = task { let! customer = ctx . BindModelAsync < SaveCustomerRequest > () do ! Database . saveCustomer customer return ! Successful . OK \"Saved customer\" next ctx }","title":"1. Write implementation"},{"location":"recipes/client-server/messaging-post/#2-expose-your-function","text":"Tie your function into the router, using the post verb instead of get . let webApp = router { post \"/api/customer\" saveCustomer // Add this }","title":"2. Expose your function"},{"location":"recipes/client-server/messaging/","text":"How do I send and receive data? This recipe shows how to create an endpoint on the server and hook up it up to the client. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server. I'm using the standard template (Fable Remoting) Fable Remoting is a library which allows you to create client/server messaging without any need to think about HTTP verbs or serialization etc. In Shared 1. Update contract Add your new endpoint onto an existing API contract e.g. ITodosApi . Because Fable Remoting exposes your API through F# on client and server, you get type safety across both. type ITodosApi = { getCustomer : int -> Async < Customer option > } On the server 1. Write implementation Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. let loadCustomer customerId = async { return Some { Name = \"My Customer\" } } Note the use of async here. Fable Remoting uses async workflows, and not tasks. You can write functions that use task, but will have to at some point map to async using Async.AwaitTask . 2. Expose your function Tie the function you've just written into the API implementation. let todosApi = { ///... getCustomer = loadCustomer } 3. Test the endpoint (optional) Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc. See here for more details on the required format. On the client 1. Call the endpoint Create a new function loadCustomer that will call the endpoint. let loadCustomer customerId = Cmd . OfAsync . perform todosApi . getCustomer customerId LoadedCustomer Note the final value supplied, CustomerLoaded . This is the Msg case that will be sent into the Elmish loop once the call returns , with the returned data. It should take in a value that matches the type returned by the Server e.g. CustomerLoaded of Customer option . See here for more information. This can now be called from within your update function e.g. | LoadCustomer customerId -> model , loadCustomer customerId I'm using the minimal template (Raw HTTP) This recipe shows how to create a GET endpoint on the server and consume it on the client using the Fetch API. On the Server 1. Write implementation Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. open Saturn open FSharp.Control.Tasks /// Loads a customer from the DB and returns as a Customer in json. let loadCustomer ( customerId : int ) next ctx = task { let customer = { Name = \"My Customer\" } return ! json customer next ctx } Note how we parameterise this function to take in the customerId as the first argument. Any parameters you need should be supplied in this manner. If you do not need any parameters, just omit them and leave the next and ctx ones. This example does not cover dealing with \"missing\" data e.g. invalid customer ID is found. 2.Expose your function Tie the function into the router with a route. let webApp = router { getf \"/api/customer/%i\" loadCustomer // Add this } Note the use of getf rather than get . If you do not need any parameters, just use get . See here for reference docs on the use of the Saturn router. 3. Test the endpoint (optional) Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc. On the client 1. Call the endpoint Create a new function loadCustomer that will call the endpoint. let loadCustomer customerId = let loadCustomer () = Fetch . get < unit , Customer > ( sprintf \"/api/customer/%i\" customerId ) Cmd . OfPromise . perform loadCustomer () CustomerLoaded Note the final value supplied, CustomerLoaded . This is the Msg case that will be sent into the Elmish loop once the call returns , with the returned data. It should take in a value that matches the type returned by the Server e.g. CustomerLoaded of Customer . See here for more information. An alternative (and slightly more succinct) way of writing this is: let loadCustomer customerId = let loadCustomer = sprintf \"/api/customer/%i\" >> Fetch . get < unit , Customer > Cmd . OfPromise . perform loadCustomer customerId CustomerLoaded This can now be called from within your update function e.g. | LoadCustomer customerId -> model , loadCustomer customerId","title":"Get data from the server"},{"location":"recipes/client-server/messaging/#how-do-i-send-and-receive-data","text":"This recipe shows how to create an endpoint on the server and hook up it up to the client. This recipe assumes that you have also followed this recipe and have an understanding of MVU messaging. This recipe only shows how to wire up the client and server.","title":"How do I send and receive data?"},{"location":"recipes/client-server/messaging/#im-using-the-standard-template-fable-remoting","text":"Fable Remoting is a library which allows you to create client/server messaging without any need to think about HTTP verbs or serialization etc.","title":"I'm using the standard template (Fable Remoting)"},{"location":"recipes/client-server/messaging/#in-shared","text":"","title":"In Shared"},{"location":"recipes/client-server/messaging/#1-update-contract","text":"Add your new endpoint onto an existing API contract e.g. ITodosApi . Because Fable Remoting exposes your API through F# on client and server, you get type safety across both. type ITodosApi = { getCustomer : int -> Async < Customer option > }","title":"1. Update contract"},{"location":"recipes/client-server/messaging/#on-the-server","text":"","title":"On the server"},{"location":"recipes/client-server/messaging/#1-write-implementation","text":"Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. let loadCustomer customerId = async { return Some { Name = \"My Customer\" } } Note the use of async here. Fable Remoting uses async workflows, and not tasks. You can write functions that use task, but will have to at some point map to async using Async.AwaitTask .","title":"1. Write implementation"},{"location":"recipes/client-server/messaging/#2-expose-your-function","text":"Tie the function you've just written into the API implementation. let todosApi = { ///... getCustomer = loadCustomer }","title":"2. Expose your function"},{"location":"recipes/client-server/messaging/#3-test-the-endpoint-optional","text":"Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc. See here for more details on the required format.","title":"3. Test the endpoint (optional)"},{"location":"recipes/client-server/messaging/#on-the-client","text":"","title":"On the client"},{"location":"recipes/client-server/messaging/#1-call-the-endpoint","text":"Create a new function loadCustomer that will call the endpoint. let loadCustomer customerId = Cmd . OfAsync . perform todosApi . getCustomer customerId LoadedCustomer Note the final value supplied, CustomerLoaded . This is the Msg case that will be sent into the Elmish loop once the call returns , with the returned data. It should take in a value that matches the type returned by the Server e.g. CustomerLoaded of Customer option . See here for more information. This can now be called from within your update function e.g. | LoadCustomer customerId -> model , loadCustomer customerId","title":"1. Call the endpoint"},{"location":"recipes/client-server/messaging/#im-using-the-minimal-template-raw-http","text":"This recipe shows how to create a GET endpoint on the server and consume it on the client using the Fetch API.","title":"I'm using the minimal template (Raw HTTP)"},{"location":"recipes/client-server/messaging/#on-the-server_1","text":"","title":"On the Server"},{"location":"recipes/client-server/messaging/#1-write-implementation_1","text":"Create a function that implements the back-end service that you require. Use standard functions to read from databases or other external sources as required. open Saturn open FSharp.Control.Tasks /// Loads a customer from the DB and returns as a Customer in json. let loadCustomer ( customerId : int ) next ctx = task { let customer = { Name = \"My Customer\" } return ! json customer next ctx } Note how we parameterise this function to take in the customerId as the first argument. Any parameters you need should be supplied in this manner. If you do not need any parameters, just omit them and leave the next and ctx ones. This example does not cover dealing with \"missing\" data e.g. invalid customer ID is found.","title":"1. Write implementation"},{"location":"recipes/client-server/messaging/#2expose-your-function","text":"Tie the function into the router with a route. let webApp = router { getf \"/api/customer/%i\" loadCustomer // Add this } Note the use of getf rather than get . If you do not need any parameters, just use get . See here for reference docs on the use of the Saturn router.","title":"2.Expose your function"},{"location":"recipes/client-server/messaging/#3-test-the-endpoint-optional_1","text":"Test out your endpoint using e.g. web browser / Postman / REST Client for VS Code etc.","title":"3. Test the endpoint (optional)"},{"location":"recipes/client-server/messaging/#on-the-client_1","text":"","title":"On the client"},{"location":"recipes/client-server/messaging/#1-call-the-endpoint_1","text":"Create a new function loadCustomer that will call the endpoint. let loadCustomer customerId = let loadCustomer () = Fetch . get < unit , Customer > ( sprintf \"/api/customer/%i\" customerId ) Cmd . OfPromise . perform loadCustomer () CustomerLoaded Note the final value supplied, CustomerLoaded . This is the Msg case that will be sent into the Elmish loop once the call returns , with the returned data. It should take in a value that matches the type returned by the Server e.g. CustomerLoaded of Customer . See here for more information. An alternative (and slightly more succinct) way of writing this is: let loadCustomer customerId = let loadCustomer = sprintf \"/api/customer/%i\" >> Fetch . get < unit , Customer > Cmd . OfPromise . perform loadCustomer customerId CustomerLoaded This can now be called from within your update function e.g. | LoadCustomer customerId -> model , loadCustomer customerId","title":"1. Call the endpoint"},{"location":"recipes/client-server/mvu-roundtrip/","text":"How do I load data from server to client using MVU? This recipe demonstrates the steps you need to take to store new data on the client using the MVU pattern, which is typically read from the Server. You will learn the steps required to modify the model, update and view functions to handle a button click which requests data from the server and handles the response. In Shared 1. Create shared domain Create a type in the Shared project which will act as the contract type between client and server. As SAFE compiles F# into JavaScript for you, you only need a single definition which will automatically be shared. type Customer = { Name : string } On the Client 1. Create message pairs Modify the Msg type to have two new messages: type Msg = // other messages ... | LoadCustomer of customerId : int // Add this | CustomerLoaded of Customer // Add this You will see that this symmetrical pattern is often followed in MVU: A command to initiate a call to the server for some data ( Load Customer) An event with the result of calling the command (Customer Loaded ) 2. Update the Model Update the Model to store the Customer once it is loaded: type Model = { // ... TheCustomer : Customer option } Make TheCustomer optional so that it can be initialised as None (see next step). 3. Update the Init function Update the init function to provide default data let model = { // ... TheCustomer = None } 4. Update the View Update your view to initiate the LoadCustomer event. Here, we create a button that will start loading customer 42 on click: let view model dispatch = Html . div [ // ... Html . button [ prop . onClick ( fun _ -> dispatch ( LoadCustomer 42 )) prop . text \"Load Customer\" ] ] 5. Handle the Update Modify the update function to handle the new messages: let update msg model = match msg with // .... | LoadCustomer customerId -> // Implementation to connect to the server to be defined. | CustomerLoaded c -> { model with TheCustomer = Some c }, Cmd . none The code to fire off the message to the server differs depending on the client / server communication you are using and normally whether you are reading or writing data. See here for more information.","title":"Perform roundtrips with MVU"},{"location":"recipes/client-server/mvu-roundtrip/#how-do-i-load-data-from-server-to-client-using-mvu","text":"This recipe demonstrates the steps you need to take to store new data on the client using the MVU pattern, which is typically read from the Server. You will learn the steps required to modify the model, update and view functions to handle a button click which requests data from the server and handles the response.","title":"How do I load data from server to client using MVU?"},{"location":"recipes/client-server/mvu-roundtrip/#in-shared","text":"","title":"In Shared"},{"location":"recipes/client-server/mvu-roundtrip/#1-create-shared-domain","text":"Create a type in the Shared project which will act as the contract type between client and server. As SAFE compiles F# into JavaScript for you, you only need a single definition which will automatically be shared. type Customer = { Name : string }","title":"1. Create shared domain"},{"location":"recipes/client-server/mvu-roundtrip/#on-the-client","text":"","title":"On the Client"},{"location":"recipes/client-server/mvu-roundtrip/#1-create-message-pairs","text":"Modify the Msg type to have two new messages: type Msg = // other messages ... | LoadCustomer of customerId : int // Add this | CustomerLoaded of Customer // Add this You will see that this symmetrical pattern is often followed in MVU: A command to initiate a call to the server for some data ( Load Customer) An event with the result of calling the command (Customer Loaded )","title":"1. Create message pairs"},{"location":"recipes/client-server/mvu-roundtrip/#2-update-the-model","text":"Update the Model to store the Customer once it is loaded: type Model = { // ... TheCustomer : Customer option } Make TheCustomer optional so that it can be initialised as None (see next step).","title":"2. Update the Model"},{"location":"recipes/client-server/mvu-roundtrip/#3-update-the-init-function","text":"Update the init function to provide default data let model = { // ... TheCustomer = None }","title":"3. Update the Init function"},{"location":"recipes/client-server/mvu-roundtrip/#4-update-the-view","text":"Update your view to initiate the LoadCustomer event. Here, we create a button that will start loading customer 42 on click: let view model dispatch = Html . div [ // ... Html . button [ prop . onClick ( fun _ -> dispatch ( LoadCustomer 42 )) prop . text \"Load Customer\" ] ]","title":"4. Update the View"},{"location":"recipes/client-server/mvu-roundtrip/#5-handle-the-update","text":"Modify the update function to handle the new messages: let update msg model = match msg with // .... | LoadCustomer customerId -> // Implementation to connect to the server to be defined. | CustomerLoaded c -> { model with TheCustomer = Some c }, Cmd . none The code to fire off the message to the server differs depending on the client / server communication you are using and normally whether you are reading or writing data. See here for more information.","title":"5. Handle the Update"},{"location":"recipes/client-server/saturn-to-giraffe/","text":"How do I use Giraffe instead of Saturn? Saturn is a functional alternative to MVC and Razor which sits on top of Giraffe . Giraffe itself is a functional wrapper around the ASP.NET Core web framework, making it easier to work with when using F#. Since Saturn is built on top of Giraffe, migrating to using \"raw\" Giraffe is relatively simple to do. Bootstrapping the Application 1. Open libraries Navigate to the Server module in the Server project. Remove open Saturn and replace it with open Giraffe open Microsoft.AspNetCore.Builder open Microsoft.Extensions.DependencyInjection open Microsoft.Extensions.Hosting open Microsoft.AspNetCore.Hosting 2. Replace application In the same module, we need to replace the Server's application computation expression with some functions which set up the default host, configure the application and register services. Remove this let app = application { // ...setup functions } run app and replace it with this let configureApp ( app : IApplicationBuilder ) = app . UseStaticFiles () . UseGiraffe webApp let configureServices ( services : IServiceCollection ) = services . AddGiraffe () |> ignore Host . CreateDefaultBuilder () . ConfigureWebHostDefaults ( fun webHostBuilder -> webHostBuilder . Configure ( configureApp ) . ConfigureServices ( configureServices ) . UseUrls ([| \"http://0.0.0.0:8085\" |]) . UseWebRoot ( \"public\" ) |> ignore ) . Build () . Run () Routing If you are using the standard SAFE template, there is nothing more you need to do, as routing is taken care of by Fable Remoting. If however you are using the minimal template, you will need to replace the Saturn router expression with the Giraffe equivalent. Replace this let webApp = router { get Route . hello ( json \"Hello from SAFE!\" ) } with this let webApp = route Route . hello >=> json \"Hello from SAFE!\" Other setup The steps shown here are the minimal necessary to get a SAFE app running using Giraffe. As with any Server setup however, there are many more optional parameters that you may wish to configure, such as caching , response compression and serialisation options as seen in the default SAFE templates amongst many others. See the Giraffe and ASP.NET Core host builder , application builder and service collection docs for more information on this.","title":"Use Giraffe instead of Saturn"},{"location":"recipes/client-server/saturn-to-giraffe/#how-do-i-use-giraffe-instead-of-saturn","text":"Saturn is a functional alternative to MVC and Razor which sits on top of Giraffe . Giraffe itself is a functional wrapper around the ASP.NET Core web framework, making it easier to work with when using F#. Since Saturn is built on top of Giraffe, migrating to using \"raw\" Giraffe is relatively simple to do.","title":"How do I use Giraffe instead of Saturn?"},{"location":"recipes/client-server/saturn-to-giraffe/#bootstrapping-the-application","text":"","title":"Bootstrapping the Application"},{"location":"recipes/client-server/saturn-to-giraffe/#1-open-libraries","text":"Navigate to the Server module in the Server project. Remove open Saturn and replace it with open Giraffe open Microsoft.AspNetCore.Builder open Microsoft.Extensions.DependencyInjection open Microsoft.Extensions.Hosting open Microsoft.AspNetCore.Hosting","title":"1. Open libraries"},{"location":"recipes/client-server/saturn-to-giraffe/#2-replace-application","text":"In the same module, we need to replace the Server's application computation expression with some functions which set up the default host, configure the application and register services. Remove this let app = application { // ...setup functions } run app and replace it with this let configureApp ( app : IApplicationBuilder ) = app . UseStaticFiles () . UseGiraffe webApp let configureServices ( services : IServiceCollection ) = services . AddGiraffe () |> ignore Host . CreateDefaultBuilder () . ConfigureWebHostDefaults ( fun webHostBuilder -> webHostBuilder . Configure ( configureApp ) . ConfigureServices ( configureServices ) . UseUrls ([| \"http://0.0.0.0:8085\" |]) . UseWebRoot ( \"public\" ) |> ignore ) . Build () . Run ()","title":"2. Replace application"},{"location":"recipes/client-server/saturn-to-giraffe/#routing","text":"If you are using the standard SAFE template, there is nothing more you need to do, as routing is taken care of by Fable Remoting. If however you are using the minimal template, you will need to replace the Saturn router expression with the Giraffe equivalent. Replace this let webApp = router { get Route . hello ( json \"Hello from SAFE!\" ) } with this let webApp = route Route . hello >=> json \"Hello from SAFE!\"","title":"Routing"},{"location":"recipes/client-server/saturn-to-giraffe/#other-setup","text":"The steps shown here are the minimal necessary to get a SAFE app running using Giraffe. As with any Server setup however, there are many more optional parameters that you may wish to configure, such as caching , response compression and serialisation options as seen in the default SAFE templates amongst many others. See the Giraffe and ASP.NET Core host builder , application builder and service collection docs for more information on this.","title":"Other setup"},{"location":"recipes/client-server/serve-a-file-from-the-backend/","text":"Serve a file from the back-end In SAFE apps, you can send a file from the server to the client as well as you can send any other type of data. However, there are a few details that make this case unique that varies on whether you use the standard or the minimal template. I am using the minimal template 1. Add the route To begin, find the Route module in Shared.fs and create the following route inside it. let file = \"api/file\" 2. HTTP Handler Find the webApp in Server.fs . Inside its router expression, add the following get expression. open FSharp.Control.Tasks.V2 let webApp = router { //...other handlers get Route . file ( fun next ctx -> task { let byteArray = System . IO . File . ReadAllBytes ( \"~/files/file.xlsx\" ) ctx . SetContentType \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" ctx . SetHttpHeader \"Content-Disposition\" \"attachment;\" return ! ctx . WriteBytesAsync ( byteArray ) }) } What we're doing here is to read a file from the local drive, but where the file is retrieved from is irrelevant. Then, using ctx , which is of type HttpContext , we let the browser know about the type of data this handler is returning. The last line (again, using ctx ) writes a byte array to the body of the HTTP response as well as handling some details that goes alongside this process. 3. The download function Although not perfect, the best solution for handling the file download is creating an invisible download link, clicking it, and then removing it completely. The following block of code is all we need for this. Add it to the Index.fs file, somewhere above the view function. open Fable.Core.JsInterop open Shared let downloadFile () = let anchor = Browser . Dom . document . createElement \"a\" anchor ? style <- \"display: none\" anchor ? href <- Route . file anchor ? download <- \"MyFile.xlsx\" anchor . click () anchor . remove () You could also pass in the name of the file or the route to be hit as a parameter. Now, you can call the downloadFile function to initiate the file download. I am using the standard template 1. Define the route Since the standard template uses Fable.Remoting, we need to edit our API definition first. Find your API type definition in Shared.fs . It's usually the last block of code. The one you see here is named IFileAPI, but the one you see in Shared.fs will be named differently. Edit this definition to have the download member you see below. open System // We need this for the `Byte` type type IFileAPI = { //...other routes download : unit -> Async < Byte [] > } 2. Add the route Open the Server.fs file and find the API that implements the definition we've just edited. It should now have an error since we're not matching the definition at the moment. Add the following route to it download = fun () -> async { let byteArray = System . IO . File . ReadAllBytes ( \"~/files/file.xlsx\" ) return byteArray } Observe that this matches the route we've just defined inside the API definition, in that it takes in a unit and returns a byte array. 3. The download function Paste the following code into Index.fs , somewhere above the view function. open Browser.Dom open Fable.Core open Fable.Core.JsInterop [< Emit ( \"new Blob([$0.buffer], { 'type': $1 })\" )>] let createBlobFromBytes ( bytes : byte [] ) ( contentType : string ) : Browser . Types . Blob = jsNative [< Emit ( \"window.URL.createObjectURL($0)\" )>] let createObjectUrl ( blob : Browser . Types . Blob ) : string = jsNative let downloadFile () = async { let! fileContents = fileApi . download () let contentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" let blob = createBlobFromBytes fileContents contentType let dataUrl = createObjectUrl blob let anchor = document . createElement \"a\" anchor ? style <- \"display: none\" anchor ? href <- dataUrl anchor ? download <- \"MyFile.xlsx\" anchor . click () anchor . remove () } If you looked at the minimal template's download function, you will realise that this snippet is quite larger. The main difference is that in this example we are using a couple of JavaScript interop functions to create a blob from the byte array that we receive from the server and to generate a URL to download it. 4. Using the download funciton Since the downloadFile function is asynchronous, we can't just call it anywhere in our view. The way we're going to deal with this is to create a Msg case and handle it in our update funciton. a. Add a couple of new cases to the Msg type type Msg = //...other cases | DownloadFile | FileDownloaded b. Handle these cases in the update function let update ( msg : Msg ) ( model : Model ): Model * Cmd < Msg > = match msg with //...other cases | DownloadFile -> model , Cmd . OfAsync . perform downloadFile () FileDownloaded | FileDownloaded -> model , Cmd . none // You can do something else here c. Dispatch this message using a UI element Html . button [ prop . OnClick ( fun _ -> dispatch DownloadFile ) prop . text \"Click to download\" ] Having added this last snippet of code into the view function, you will be able to download the file by clicking the button that will now be displayed in your UI.","title":"Serve a file from the back-end"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#serve-a-file-from-the-back-end","text":"In SAFE apps, you can send a file from the server to the client as well as you can send any other type of data. However, there are a few details that make this case unique that varies on whether you use the standard or the minimal template.","title":"Serve a file from the back-end"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#i-am-using-the-minimal-template","text":"","title":"I am using the minimal template"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#1-add-the-route","text":"To begin, find the Route module in Shared.fs and create the following route inside it. let file = \"api/file\"","title":"1. Add the route"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#2-http-handler","text":"Find the webApp in Server.fs . Inside its router expression, add the following get expression. open FSharp.Control.Tasks.V2 let webApp = router { //...other handlers get Route . file ( fun next ctx -> task { let byteArray = System . IO . File . ReadAllBytes ( \"~/files/file.xlsx\" ) ctx . SetContentType \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" ctx . SetHttpHeader \"Content-Disposition\" \"attachment;\" return ! ctx . WriteBytesAsync ( byteArray ) }) } What we're doing here is to read a file from the local drive, but where the file is retrieved from is irrelevant. Then, using ctx , which is of type HttpContext , we let the browser know about the type of data this handler is returning. The last line (again, using ctx ) writes a byte array to the body of the HTTP response as well as handling some details that goes alongside this process.","title":"2. HTTP Handler"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#3-the-download-function","text":"Although not perfect, the best solution for handling the file download is creating an invisible download link, clicking it, and then removing it completely. The following block of code is all we need for this. Add it to the Index.fs file, somewhere above the view function. open Fable.Core.JsInterop open Shared let downloadFile () = let anchor = Browser . Dom . document . createElement \"a\" anchor ? style <- \"display: none\" anchor ? href <- Route . file anchor ? download <- \"MyFile.xlsx\" anchor . click () anchor . remove () You could also pass in the name of the file or the route to be hit as a parameter. Now, you can call the downloadFile function to initiate the file download.","title":"3. The download function"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#i-am-using-the-standard-template","text":"","title":"I am using the standard template"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#1-define-the-route","text":"Since the standard template uses Fable.Remoting, we need to edit our API definition first. Find your API type definition in Shared.fs . It's usually the last block of code. The one you see here is named IFileAPI, but the one you see in Shared.fs will be named differently. Edit this definition to have the download member you see below. open System // We need this for the `Byte` type type IFileAPI = { //...other routes download : unit -> Async < Byte [] > }","title":"1. Define the route"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#2-add-the-route","text":"Open the Server.fs file and find the API that implements the definition we've just edited. It should now have an error since we're not matching the definition at the moment. Add the following route to it download = fun () -> async { let byteArray = System . IO . File . ReadAllBytes ( \"~/files/file.xlsx\" ) return byteArray } Observe that this matches the route we've just defined inside the API definition, in that it takes in a unit and returns a byte array.","title":"2. Add the route"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#3-the-download-function_1","text":"Paste the following code into Index.fs , somewhere above the view function. open Browser.Dom open Fable.Core open Fable.Core.JsInterop [< Emit ( \"new Blob([$0.buffer], { 'type': $1 })\" )>] let createBlobFromBytes ( bytes : byte [] ) ( contentType : string ) : Browser . Types . Blob = jsNative [< Emit ( \"window.URL.createObjectURL($0)\" )>] let createObjectUrl ( blob : Browser . Types . Blob ) : string = jsNative let downloadFile () = async { let! fileContents = fileApi . download () let contentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" let blob = createBlobFromBytes fileContents contentType let dataUrl = createObjectUrl blob let anchor = document . createElement \"a\" anchor ? style <- \"display: none\" anchor ? href <- dataUrl anchor ? download <- \"MyFile.xlsx\" anchor . click () anchor . remove () } If you looked at the minimal template's download function, you will realise that this snippet is quite larger. The main difference is that in this example we are using a couple of JavaScript interop functions to create a blob from the byte array that we receive from the server and to generate a URL to download it.","title":"3. The download function"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#4-using-the-download-funciton","text":"Since the downloadFile function is asynchronous, we can't just call it anywhere in our view. The way we're going to deal with this is to create a Msg case and handle it in our update funciton.","title":"4. Using the download funciton"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#a-add-a-couple-of-new-cases-to-the-msg-type","text":"type Msg = //...other cases | DownloadFile | FileDownloaded","title":"a. Add a couple of new cases to the Msg type"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#b-handle-these-cases-in-the-update-function","text":"let update ( msg : Msg ) ( model : Model ): Model * Cmd < Msg > = match msg with //...other cases | DownloadFile -> model , Cmd . OfAsync . perform downloadFile () FileDownloaded | FileDownloaded -> model , Cmd . none // You can do something else here","title":"b. Handle these cases in the update function"},{"location":"recipes/client-server/serve-a-file-from-the-backend/#c-dispatch-this-message-using-a-ui-element","text":"Html . button [ prop . OnClick ( fun _ -> dispatch DownloadFile ) prop . text \"Click to download\" ] Having added this last snippet of code into the view function, you will be able to download the file by clicking the button that will now be displayed in your UI.","title":"c. Dispatch this message using a UI element"},{"location":"recipes/client-server/server-errors-on-client/","text":"How Do I Handle Server Exceptions on the Client? SAFE Stack makes it easy to catch and handle exceptions raised by the server on the client. Though the way we make a call to the server from the client is different between the standard and the minimal template, the way we handle server errors on the client is the same in principle. 1. Update the Model Update the model to store the error details that we receive from the server. Find the Model type in src/Client/Index.fs and add it the following Errors field: type Model = { ... // the rest of the fields Errors : string list } Now, bind an empty list to the field record inside the init function: let model = { ... // the rest of the fields Errors = [] } 2. Add an Error Message Handler We now add a new message to handle errors that we get back from the server after making a request. Add the following case to the Msg type: type Msg = | ... // other message cases | GotError of exn 3. Handle the new Message In this simple example, we will simply capture the Message of the exception. Add the following line to the end of the pattern match inside the update function: | GotError ex -> { model with Errors = ex . Message :: model . Errors }, Cmd . none The following steps will vary depending on whether you\u2019re using the standard template or the minimal one. 4. Connect Server Errors to Elmish We now have to connect up the server response to the new message we created. Elmish has support for this through the either Cmd functions (instead of the perform functions). Make the following changes to your server call: I Am Using the Standard Template let cmd = Cmd . OfAsync . perform todosApi . getTodos () GotTodos \u2026and replace it with the following: let cmd = Cmd . OfAsync . either todosApi . getTodos () GotTodos GotError I Am Using the Minimal Template let cmd = Cmd . OfPromise . perform getHello () GotHello \u2026and replace it with the following: let cmd = Cmd . OfPromise . either getHello () GotHello GotError Done! Now, if you get an exception from the Server, its message will be added to the Errors field of the Model type. Instead of throwing the error, you can now display a meaningful text to the user like so: [ for msg in errorMessages do Html . p msg ]","title":"Handle server errors on the client"},{"location":"recipes/client-server/server-errors-on-client/#how-do-i-handle-server-exceptions-on-the-client","text":"SAFE Stack makes it easy to catch and handle exceptions raised by the server on the client. Though the way we make a call to the server from the client is different between the standard and the minimal template, the way we handle server errors on the client is the same in principle.","title":"How Do I Handle Server Exceptions on the Client?"},{"location":"recipes/client-server/server-errors-on-client/#1-update-the-model","text":"Update the model to store the error details that we receive from the server. Find the Model type in src/Client/Index.fs and add it the following Errors field: type Model = { ... // the rest of the fields Errors : string list } Now, bind an empty list to the field record inside the init function: let model = { ... // the rest of the fields Errors = [] }","title":"1. Update the Model"},{"location":"recipes/client-server/server-errors-on-client/#2-add-an-error-message-handler","text":"We now add a new message to handle errors that we get back from the server after making a request. Add the following case to the Msg type: type Msg = | ... // other message cases | GotError of exn","title":"2. Add an Error Message Handler"},{"location":"recipes/client-server/server-errors-on-client/#3-handle-the-new-message","text":"In this simple example, we will simply capture the Message of the exception. Add the following line to the end of the pattern match inside the update function: | GotError ex -> { model with Errors = ex . Message :: model . Errors }, Cmd . none The following steps will vary depending on whether you\u2019re using the standard template or the minimal one.","title":"3. Handle the new Message"},{"location":"recipes/client-server/server-errors-on-client/#4-connect-server-errors-to-elmish","text":"We now have to connect up the server response to the new message we created. Elmish has support for this through the either Cmd functions (instead of the perform functions). Make the following changes to your server call:","title":"4. Connect Server Errors to Elmish"},{"location":"recipes/client-server/server-errors-on-client/#i-am-using-the-standard-template","text":"let cmd = Cmd . OfAsync . perform todosApi . getTodos () GotTodos \u2026and replace it with the following: let cmd = Cmd . OfAsync . either todosApi . getTodos () GotTodos GotError","title":"I Am Using the Standard Template"},{"location":"recipes/client-server/server-errors-on-client/#i-am-using-the-minimal-template","text":"let cmd = Cmd . OfPromise . perform getHello () GotHello \u2026and replace it with the following: let cmd = Cmd . OfPromise . either getHello () GotHello GotError","title":"I Am Using the Minimal Template"},{"location":"recipes/client-server/server-errors-on-client/#done","text":"Now, if you get an exception from the Server, its message will be added to the Errors field of the Model type. Instead of throwing the error, you can now display a meaningful text to the user like so: [ for msg in errorMessages do Html . p msg ]","title":"Done!"},{"location":"recipes/client-server/share-code/","text":"How Do I Share Code Types Between the Client and the Server? SAFE Stack makes it really simple and easy to share code between the client and the server, since both of them are written in F#. The client side is transpiled into JavaScript via webpack, whilst the server side is compiled down to .NET CIL. Serialization between both happens in the background, so you don't have to worry about it. Types Let\u2019s say the you have the following type in src/Server/Server.fs : type Customer = { Id : Guid Name : string Email : string PhoneNumber : string } Values and Functions And you have the following function that is used to validate this Customer type in src/Client/Index.fs : let customerIsValid customer = ( Guid . Empty = customer . Id || String . IsNullOrEmpty customer . Name || String . IsNullOrEmpty customer . Email || String . IsNullOrEmpty customer . PhoneNumber ) |> not Shared If at any point you realise you need to use both the Customer type and the customerIsValid function both in the Client and the Server, all you need to do is to move both of them to Shared project. You can either put them in the Shared.fs file, or create your own file in the Shared project (eg. Customer.fs ). After this, you will be able to use both the Customer type and the customerIsValid function in both the Client and the Server. Serialization SAFE comes out of the box with [Fable.Remoting] or [Thoth] for serialization. These will handle transport of data seamlessly for you. Considerations Be careful not to place code in Shared.fs that depends on a Client or Server-specific dependency. If your code depends on Fable for example, in most cases it will not be suitable to place it in Shared, since it can only be used in Client. Similarly, if your types rely on .NET specific types in e.g. the framework class library (FCL), beware. Fable has built-in mappings for popular .NET types e.g. System.DateTime and System.Math , but you will have to write your own mappers otherwise.","title":"Share code between the client and the server"},{"location":"recipes/client-server/share-code/#how-do-i-share-code-types-between-the-client-and-the-server","text":"SAFE Stack makes it really simple and easy to share code between the client and the server, since both of them are written in F#. The client side is transpiled into JavaScript via webpack, whilst the server side is compiled down to .NET CIL. Serialization between both happens in the background, so you don't have to worry about it.","title":"How Do I Share Code Types Between the Client and the Server?"},{"location":"recipes/client-server/share-code/#types","text":"Let\u2019s say the you have the following type in src/Server/Server.fs : type Customer = { Id : Guid Name : string Email : string PhoneNumber : string }","title":"Types"},{"location":"recipes/client-server/share-code/#values-and-functions","text":"And you have the following function that is used to validate this Customer type in src/Client/Index.fs : let customerIsValid customer = ( Guid . Empty = customer . Id || String . IsNullOrEmpty customer . Name || String . IsNullOrEmpty customer . Email || String . IsNullOrEmpty customer . PhoneNumber ) |> not","title":"Values and Functions"},{"location":"recipes/client-server/share-code/#shared","text":"If at any point you realise you need to use both the Customer type and the customerIsValid function both in the Client and the Server, all you need to do is to move both of them to Shared project. You can either put them in the Shared.fs file, or create your own file in the Shared project (eg. Customer.fs ). After this, you will be able to use both the Customer type and the customerIsValid function in both the Client and the Server.","title":"Shared"},{"location":"recipes/client-server/share-code/#serialization","text":"SAFE comes out of the box with [Fable.Remoting] or [Thoth] for serialization. These will handle transport of data seamlessly for you.","title":"Serialization"},{"location":"recipes/client-server/share-code/#considerations","text":"Be careful not to place code in Shared.fs that depends on a Client or Server-specific dependency. If your code depends on Fable for example, in most cases it will not be suitable to place it in Shared, since it can only be used in Client. Similarly, if your types rely on .NET specific types in e.g. the framework class library (FCL), beware. Fable has built-in mappings for popular .NET types e.g. System.DateTime and System.Math , but you will have to write your own mappers otherwise.","title":"Considerations"},{"location":"recipes/client-server/upload-file-from-client/","text":"How do I upload a file from the client? Fable makes it quick and easy to upload files from the client. Both the standard and the minimal template comes with Fable support by default. 1. Create a File Create a file in the client project named FileUpload.fs somewhere before the Index.fs file and insert the following: module FileUpload open Fable.React open Fable.React.Props open Fable.FontAwesome open Fable.Core open Fable.Core.JsInterop 2. File Event Handler Then, add the following. The reader.onload block will be executed once we select and confirm a file to be uploaded. Read the FileReader docs to find out more. let handleFileEvent onLoad ( fileEvent : Browser . Types . Event ) = let files : Browser . Types . FileList = !! fileEvent . target ? files if files . length > 0 then let reader = Browser . Dom . FileReader . Create () reader . onload <- ( fun _ -> reader . result |> unbox |> onLoad ) reader . readAsArrayBuffer ( files .[ 0 ]) 3. Create the UI Element This step varies depending on whether you're using the standard or the minimal template. Apply only the instructions under the appropriate heading. I'm using the standard template Insert the following block of code at the end of FileUpload.fs . This function will create a UI element to be used to upload files. Click here to find out more about Bulma's file input component. open Feliz.Bulma let createFileUpload onLoad = Bulma . file [ Bulma . fileLabel . label [ Bulma . fileInput [ prop . onChange ( handleFileEvent onLoad ) ] Bulma . fileCta [ Bulma . fileLabel . label \"Choose a file...\" ] ] ] I'm using the minimal template Insert the following block of code at the end of FileUpload.fs . This function will create a UI element to be used to upload files. let createFileUpload onLoad = let input = document . createElement \"INPUT\" input . onchange <- ( handleFileEvent onLoad ) 4. Use the UI Element Having followed all these steps, you can now use the createFileUpload function in Index.fs to create the UI element for uploading files. One thing to note is that HandleFile is a case of the discriminated union type Msg that's in Index.fs . You can use this message case to send the file from the client to the server . FileUpload . createFileUpload ( HandleFile >> dispatch )","title":"Upload file from the client"},{"location":"recipes/client-server/upload-file-from-client/#how-do-i-upload-a-file-from-the-client","text":"Fable makes it quick and easy to upload files from the client. Both the standard and the minimal template comes with Fable support by default.","title":"How do I upload a file from the client?"},{"location":"recipes/client-server/upload-file-from-client/#1-create-a-file","text":"Create a file in the client project named FileUpload.fs somewhere before the Index.fs file and insert the following: module FileUpload open Fable.React open Fable.React.Props open Fable.FontAwesome open Fable.Core open Fable.Core.JsInterop","title":"1. Create a File"},{"location":"recipes/client-server/upload-file-from-client/#2-file-event-handler","text":"Then, add the following. The reader.onload block will be executed once we select and confirm a file to be uploaded. Read the FileReader docs to find out more. let handleFileEvent onLoad ( fileEvent : Browser . Types . Event ) = let files : Browser . Types . FileList = !! fileEvent . target ? files if files . length > 0 then let reader = Browser . Dom . FileReader . Create () reader . onload <- ( fun _ -> reader . result |> unbox |> onLoad ) reader . readAsArrayBuffer ( files .[ 0 ])","title":"2. File Event Handler"},{"location":"recipes/client-server/upload-file-from-client/#3-create-the-ui-element","text":"This step varies depending on whether you're using the standard or the minimal template. Apply only the instructions under the appropriate heading.","title":"3. Create the UI Element"},{"location":"recipes/client-server/upload-file-from-client/#im-using-the-standard-template","text":"Insert the following block of code at the end of FileUpload.fs . This function will create a UI element to be used to upload files. Click here to find out more about Bulma's file input component. open Feliz.Bulma let createFileUpload onLoad = Bulma . file [ Bulma . fileLabel . label [ Bulma . fileInput [ prop . onChange ( handleFileEvent onLoad ) ] Bulma . fileCta [ Bulma . fileLabel . label \"Choose a file...\" ] ] ]","title":"I'm using the standard template"},{"location":"recipes/client-server/upload-file-from-client/#im-using-the-minimal-template","text":"Insert the following block of code at the end of FileUpload.fs . This function will create a UI element to be used to upload files. let createFileUpload onLoad = let input = document . createElement \"INPUT\" input . onchange <- ( handleFileEvent onLoad )","title":"I'm using the minimal template"},{"location":"recipes/client-server/upload-file-from-client/#4-use-the-ui-element","text":"Having followed all these steps, you can now use the createFileUpload function in Index.fs to create the UI element for uploading files. One thing to note is that HandleFile is a case of the discriminated union type Msg that's in Index.fs . You can use this message case to send the file from the client to the server . FileUpload . createFileUpload ( HandleFile >> dispatch )","title":"4. Use the UI Element"},{"location":"recipes/developing-and-testing/debug-safe-app/","text":"How do I debug a SAFE app? I'm using Visual Studio In order to debug Server code from Visual Studio, we need set the correct URLs in the project's debug properties. Debugging the Server 1. Configure launch settings You can do this through the Server project's Properties/Debug editor or by editing the launchSettings.json file which is in the properties folder. After selecting the debug profile that you wish to edit ( IIS Express or Server ), you will need to set the App URL field to http://localhost:8085 and Launch browser field to http://localhost:8080 . The process is very similar for VS Mac. Once this is done, you can expect your launchSettings.json file to look something like this: { \"iisSettings\" : { \"windowsAuthentication\" : false , \"anonymousAuthentication\" : true , \"iisExpress\" : { \"applicationUrl\" : \"http://localhost:8085/\" , \"sslPort\" : 44330 } }, \"profiles\" : { \"IIS Express\" : { \"commandName\" : \"IISExpress\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080/\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } }, \"Server\" : { \"commandName\" : \"Project\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" }, \"applicationUrl\" : \"http://localhost:8085\" } } } 2. Start the Client Since you will be running the server directly through Visual Studio, you cannot use a FAKE script to start the application, so launch the client directly using e.g. npm run start . 3. Debug the Server Set the server as your Startup project, either using the drop-down menu at the top of the IDE or by right clicking on the project itself and selecting Set as Startup Project . Select the profile that you set up earlier and wish to launch from the drop-down at the top of the IDE. Either press the Play button at the top of the IDE or hit F5 on your keyboard to start the Server debugging and launch a browser pointing at the website. Debugging the Client Although we write our client-side code using F#, it is being converted into Javascript at runtime by Fable and executed in the browser. However, we can still debug it via the magic of source mapping. If you are using Visual Studio, you cannot directly connect to the browser debugger. You can, however, debug your client F# code using the browser's development tools. 1. Set breakpoints in Client code The exact instructions will depend on your browser, but essentially it simply involves: Opening the Developer tools panel (usually by hitting F12). Finding the F# file you want to add breakpoints to in the source of the website (look inside the webpack folder). Add breakpoints to it in your browser inspector. I'm using VS Code VS Code allows \"full stack\" debugging i.e. both the client and server. Prerequisites that you should install: 0. Install Prerequisites Install either Google Chrome or Microsoft Edge : Enables client-side debugging. Configure your browser with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code. Debugger for Edge : Provides integrated client-side debugging in Code. 1. Create a launch.json file Open the Command Palette using Ctrl+Shift+P and run Debug: Open launch.json . This will ask you to choose a platform; select .NET Core . This will create a launch.json file in the root of your solution and also open it in the editor. 2. Add a Configuration Click the \"Add Configuration...\" button and choose Launch .NET Core Console Application . The only change required is to point it at the Server application, by replacing the program line with this: \"program\" : \"${workspaceFolder}/src/Server/bin/Debug/net5.0/Server.dll\" , 3. Configure a build task From the Command Palette, choose Configure Task . Select Create tasks.json file from template . This will show you a list of pre-configured templates. Select .NET Core . Update the build directory using \"options\": {\"cwd\": \"src/Server\"}, as shown below: { // See h tt ps : //go.microso ft .com/ f wli n k/?Li n kId= 733558 // f or t he docume ntat io n abou t t he tas ks.jso n f orma t \"version\" : \"2.0.0\" , \"tasks\" : [ { \"label\" : \"build\" , \"command\" : \"dotnet\" , \"type\" : \"shell\" , \"options\" : { \"cwd\" : \"src/Server\" }, \"args\" : [ \"build\" , \"debug-pt3.sln\" , // Ask do tnet build t o ge nerate full pa t hs f or f ile na mes. \"/property:GenerateFullPaths=true\" , // Do n o t ge nerate summary o t herwise i t leads t o duplica te errors i n Problems pa nel \"/consoleloggerparameters:NoSummary\" ], \"group\" : \"build\" , \"presentation\" : { \"reveal\" : \"silent\" }, \"problemMatcher\" : \"$msCompile\" } ] } 4. Debug the Server Either hit F5 or open the Debugging pane and press the Play button to build and launch the Server with the debugger attached. Observe that the Debug Console panel will show output from the server. The server is now running and you can set breakpoints and view the callstack etc. 5. Debug the Client Start the Client using dotnet fable watch src/Client --run webpack-dev-server . Open the Command Palette and run Debug: Open Link . When prompted for a url, type http://localhost:8080/ . This will launch a browser which is pointed at the URL and connect the debugger to it. You can now set breakpoints in the generated .fs.js files within VS Code. Select the appropriate Debug Console you wish to view. If you find that your breakpoints aren't being hit, try stopping the Client, disconnecting the debugger and re-launching them both. To find out more about the VS Code debugger, see here .","title":"Debug a SAFE app"},{"location":"recipes/developing-and-testing/debug-safe-app/#how-do-i-debug-a-safe-app","text":"","title":"How do I debug a SAFE app?"},{"location":"recipes/developing-and-testing/debug-safe-app/#im-using-visual-studio","text":"In order to debug Server code from Visual Studio, we need set the correct URLs in the project's debug properties.","title":"I'm using Visual Studio"},{"location":"recipes/developing-and-testing/debug-safe-app/#debugging-the-server","text":"","title":"Debugging the Server"},{"location":"recipes/developing-and-testing/debug-safe-app/#1-configure-launch-settings","text":"You can do this through the Server project's Properties/Debug editor or by editing the launchSettings.json file which is in the properties folder. After selecting the debug profile that you wish to edit ( IIS Express or Server ), you will need to set the App URL field to http://localhost:8085 and Launch browser field to http://localhost:8080 . The process is very similar for VS Mac. Once this is done, you can expect your launchSettings.json file to look something like this: { \"iisSettings\" : { \"windowsAuthentication\" : false , \"anonymousAuthentication\" : true , \"iisExpress\" : { \"applicationUrl\" : \"http://localhost:8085/\" , \"sslPort\" : 44330 } }, \"profiles\" : { \"IIS Express\" : { \"commandName\" : \"IISExpress\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080/\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } }, \"Server\" : { \"commandName\" : \"Project\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" }, \"applicationUrl\" : \"http://localhost:8085\" } } }","title":"1. Configure launch settings"},{"location":"recipes/developing-and-testing/debug-safe-app/#2-start-the-client","text":"Since you will be running the server directly through Visual Studio, you cannot use a FAKE script to start the application, so launch the client directly using e.g. npm run start .","title":"2. Start the Client"},{"location":"recipes/developing-and-testing/debug-safe-app/#3-debug-the-server","text":"Set the server as your Startup project, either using the drop-down menu at the top of the IDE or by right clicking on the project itself and selecting Set as Startup Project . Select the profile that you set up earlier and wish to launch from the drop-down at the top of the IDE. Either press the Play button at the top of the IDE or hit F5 on your keyboard to start the Server debugging and launch a browser pointing at the website.","title":"3. Debug the Server"},{"location":"recipes/developing-and-testing/debug-safe-app/#debugging-the-client","text":"Although we write our client-side code using F#, it is being converted into Javascript at runtime by Fable and executed in the browser. However, we can still debug it via the magic of source mapping. If you are using Visual Studio, you cannot directly connect to the browser debugger. You can, however, debug your client F# code using the browser's development tools.","title":"Debugging the Client"},{"location":"recipes/developing-and-testing/debug-safe-app/#1-set-breakpoints-in-client-code","text":"The exact instructions will depend on your browser, but essentially it simply involves: Opening the Developer tools panel (usually by hitting F12). Finding the F# file you want to add breakpoints to in the source of the website (look inside the webpack folder). Add breakpoints to it in your browser inspector.","title":"1. Set breakpoints in Client code"},{"location":"recipes/developing-and-testing/debug-safe-app/#im-using-vs-code","text":"VS Code allows \"full stack\" debugging i.e. both the client and server. Prerequisites that you should install:","title":"I'm using VS Code"},{"location":"recipes/developing-and-testing/debug-safe-app/#0-install-prerequisites","text":"Install either Google Chrome or Microsoft Edge : Enables client-side debugging. Configure your browser with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code. Debugger for Edge : Provides integrated client-side debugging in Code.","title":"0. Install Prerequisites"},{"location":"recipes/developing-and-testing/debug-safe-app/#1-create-a-launchjson-file","text":"Open the Command Palette using Ctrl+Shift+P and run Debug: Open launch.json . This will ask you to choose a platform; select .NET Core . This will create a launch.json file in the root of your solution and also open it in the editor.","title":"1. Create a launch.json file"},{"location":"recipes/developing-and-testing/debug-safe-app/#2-add-a-configuration","text":"Click the \"Add Configuration...\" button and choose Launch .NET Core Console Application . The only change required is to point it at the Server application, by replacing the program line with this: \"program\" : \"${workspaceFolder}/src/Server/bin/Debug/net5.0/Server.dll\" ,","title":"2. Add a Configuration"},{"location":"recipes/developing-and-testing/debug-safe-app/#3-configure-a-build-task","text":"From the Command Palette, choose Configure Task . Select Create tasks.json file from template . This will show you a list of pre-configured templates. Select .NET Core . Update the build directory using \"options\": {\"cwd\": \"src/Server\"}, as shown below: { // See h tt ps : //go.microso ft .com/ f wli n k/?Li n kId= 733558 // f or t he docume ntat io n abou t t he tas ks.jso n f orma t \"version\" : \"2.0.0\" , \"tasks\" : [ { \"label\" : \"build\" , \"command\" : \"dotnet\" , \"type\" : \"shell\" , \"options\" : { \"cwd\" : \"src/Server\" }, \"args\" : [ \"build\" , \"debug-pt3.sln\" , // Ask do tnet build t o ge nerate full pa t hs f or f ile na mes. \"/property:GenerateFullPaths=true\" , // Do n o t ge nerate summary o t herwise i t leads t o duplica te errors i n Problems pa nel \"/consoleloggerparameters:NoSummary\" ], \"group\" : \"build\" , \"presentation\" : { \"reveal\" : \"silent\" }, \"problemMatcher\" : \"$msCompile\" } ] }","title":"3. Configure a build task"},{"location":"recipes/developing-and-testing/debug-safe-app/#4-debug-the-server","text":"Either hit F5 or open the Debugging pane and press the Play button to build and launch the Server with the debugger attached. Observe that the Debug Console panel will show output from the server. The server is now running and you can set breakpoints and view the callstack etc.","title":"4. Debug the Server"},{"location":"recipes/developing-and-testing/debug-safe-app/#5-debug-the-client","text":"Start the Client using dotnet fable watch src/Client --run webpack-dev-server . Open the Command Palette and run Debug: Open Link . When prompted for a url, type http://localhost:8080/ . This will launch a browser which is pointed at the URL and connect the debugger to it. You can now set breakpoints in the generated .fs.js files within VS Code. Select the appropriate Debug Console you wish to view. If you find that your breakpoints aren't being hit, try stopping the Client, disconnecting the debugger and re-launching them both. To find out more about the VS Code debugger, see here .","title":"5. Debug the Client"},{"location":"recipes/developing-and-testing/testing-the-client/","text":"How do I test the client? Testing on the client is a little different than on the server. This is because the code which is ultimately being executed in the browser is Javascript, translated from F# by Fable, and so it must be tested in a Javascript environment. Furthermore, code that is shared between the Client and Server must be tested in both a dotnet environment and a Javascript environment. The SAFE template uses a library called Fable.Mocha which allows us to run the same tests in both environments. It mirrors the Expecto API and works in much the same way. I'm using the standard template If you are using the standard template then there is nothing more you need to do in order to start testing your Client. In the tests/Client folder, there is a project named Client.Tests with a single script demonstrating how to use Mocha to test the TODO sample. Note the compiler directive here which makes sure that the Shared tests are only included when executing in a Javascript (Fable) context. They are covered by Expecto under dotnet as you can see in Server.Tests.fs . 1. Launch the test server In order to run the tests, instead of starting your application using dotnet run you should instead use dotnet run Runtests 2. View the results Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this: This command builds and runs the Server test project too. If you want to run the Client tests alone, you can simply launch the test server using npm run test:live , which executes a command stored in package.json . I'm using the minimal template If you are using the minimal template, you will need to first configure a test project as none are included. 1. Add a test project In the tests/Client folder, create a create a .Net library called Client.Tests . dotnet new ClassLib -lang F # -n Client.Tests -o tests/Client dotnet sln add tests / Client 2. Reference the Client project Reference the Client project from the Client.Tests project: dotnet add src / Client . Tests reference src / Client 3. Add the Fable.Mocha package to Test project Run the following command: dotnet add tests / Client package Fable . Mocha 4. Add something to test Add this function to Client.fs in the Client project let sayHello name = $ \"Hello {name}\" 5. Add a test Replace the contents of tests/Client/Library.fs with the following code: module Tests open Fable.Mocha let client = testList \"Client\" [ testCase \"Hello received\" <| fun _ -> let hello = Client . sayHello \"SAFE V3\" Expect . equal hello \"Hello SAFE V3\" \"Unexpected greeting\" ] let all = testList \"All\" [ client ] [< EntryPoint >] let main _ = Mocha . runTests all 6. Add Test web page Add a file called index.html to the tests/Client folder with following contents: <!DOCTYPE html> < html > < head > < title > SAFE Client Tests </ title > </ head > < body > </ body > </ html > 7. Add test webpack config Add a file called webpack.tests.config.js to the root directory with the following contents:**** // Template for webpack.config.js in Fable projects // Find latest version in https://github.com/fable-compiler/webpack-config-template // In most cases, you'll only need to edit the CONFIG object (after dependencies) // See below if you need better fine-tuning of Webpack options // Dependencies. Also required: core-js, @babel/core, // @babel/preset-env, babel-loader, sass, sass-loader, css-loader, style-loader, file-loader, resolve-url-loader var path = require ( 'path' ); var webpack = require ( 'webpack' ); var HtmlWebpackPlugin = require ( 'html-webpack-plugin' ); var CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); var CONFIG = { // The tags to include the generated JS and CSS will be automatically injected in the HTML template // See https://github.com/jantimon/html-webpack-plugin indexHtmlTemplate : 'tests/Client/index.html' , fsharpEntry : 'tests/Client/Library.fs.js' , outputDir : 'tests/Client' , assetsDir : 'tests/Client' , devServerPort : 8081 , // When using webpack-dev-server, you may need to redirect some calls // to a external API server. See https://webpack.js.org/configuration/dev-server/#devserver-proxy devServerProxy : undefined , babel : undefined } // If we're running the webpack-dev-server, assume we're in development mode var isProduction = ! process . argv . find ( v => v . indexOf ( 'webpack-dev-server' ) !== - 1 ); var environment = isProduction ? 'production' : 'development' ; process . env . NODE_ENV = environment ; console . log ( 'Bundling for ' + environment + '...' ); // The HtmlWebpackPlugin allows us to use a template for the index.html page // and automatically injects <script> or <link> tags for generated bundles. var commonPlugins = [ new HtmlWebpackPlugin ({ filename : 'index.html' , template : resolve ( CONFIG . indexHtmlTemplate ) }) ]; module . exports = { // In development, split the JavaScript and CSS files in order to // have a faster HMR support. In production bundle styles together // with the code because the MiniCssExtractPlugin will extract the // CSS in a separate files. entry : { app : resolve ( CONFIG . fsharpEntry ) }, // Add a hash to the output file name in production // to prevent browser caching if code changes output : { path : resolve ( CONFIG . outputDir ), filename : isProduction ? '[name].[hash].js' : '[name].js' }, mode : isProduction ? 'production' : 'development' , devtool : isProduction ? 'source-map' : 'eval-source-map' , optimization : { splitChunks : { chunks : 'all' }, }, // Besides the HtmlPlugin, we use the following plugins: // PRODUCTION // - MiniCssExtractPlugin: Extracts CSS from bundle to a different file // To minify CSS, see https://github.com/webpack-contrib/mini-css-extract-plugin#minimizing-for-production // - CopyWebpackPlugin: Copies static assets to output directory // DEVELOPMENT // - HotModuleReplacementPlugin: Enables hot reloading when code changes without refreshing plugins : isProduction ? commonPlugins . concat ([ new CopyWebpackPlugin ({ patterns : [{ from : resolve ( CONFIG . assetsDir ) }] }), ]) : commonPlugins . concat ([ new webpack . HotModuleReplacementPlugin (), ]), resolve : { // See https://github.com/fable-compiler/Fable/issues/1490 symlinks : false }, // Configuration for webpack-dev-server devServer : { publicPath : '/' , contentBase : resolve ( CONFIG . assetsDir ), host : '0.0.0.0' , port : CONFIG . devServerPort , proxy : CONFIG . devServerProxy , hot : true , inline : true }, module : { rules : [ ] } }; function resolve ( filePath ) { return path . isAbsolute ( filePath ) ? filePath : path . join ( __dirname , filePath ); } 8. Install the client's dependencies npm install 9. Launch the test website dotnet fable watch src / Client - -run webpack-dev-server - -config webpack . tests . config Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this:","title":"Test the Client"},{"location":"recipes/developing-and-testing/testing-the-client/#how-do-i-test-the-client","text":"Testing on the client is a little different than on the server. This is because the code which is ultimately being executed in the browser is Javascript, translated from F# by Fable, and so it must be tested in a Javascript environment. Furthermore, code that is shared between the Client and Server must be tested in both a dotnet environment and a Javascript environment. The SAFE template uses a library called Fable.Mocha which allows us to run the same tests in both environments. It mirrors the Expecto API and works in much the same way.","title":"How do I test the client?"},{"location":"recipes/developing-and-testing/testing-the-client/#im-using-the-standard-template","text":"If you are using the standard template then there is nothing more you need to do in order to start testing your Client. In the tests/Client folder, there is a project named Client.Tests with a single script demonstrating how to use Mocha to test the TODO sample. Note the compiler directive here which makes sure that the Shared tests are only included when executing in a Javascript (Fable) context. They are covered by Expecto under dotnet as you can see in Server.Tests.fs .","title":"I'm using the standard template"},{"location":"recipes/developing-and-testing/testing-the-client/#1-launch-the-test-server","text":"In order to run the tests, instead of starting your application using dotnet run you should instead use dotnet run Runtests","title":"1. Launch the test server"},{"location":"recipes/developing-and-testing/testing-the-client/#2-view-the-results","text":"Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this: This command builds and runs the Server test project too. If you want to run the Client tests alone, you can simply launch the test server using npm run test:live , which executes a command stored in package.json .","title":"2. View the results"},{"location":"recipes/developing-and-testing/testing-the-client/#im-using-the-minimal-template","text":"If you are using the minimal template, you will need to first configure a test project as none are included.","title":"I'm using the minimal template"},{"location":"recipes/developing-and-testing/testing-the-client/#1-add-a-test-project","text":"In the tests/Client folder, create a create a .Net library called Client.Tests . dotnet new ClassLib -lang F # -n Client.Tests -o tests/Client dotnet sln add tests / Client","title":"1. Add a test project"},{"location":"recipes/developing-and-testing/testing-the-client/#2-reference-the-client-project","text":"Reference the Client project from the Client.Tests project: dotnet add src / Client . Tests reference src / Client","title":"2. Reference the Client project"},{"location":"recipes/developing-and-testing/testing-the-client/#3-add-the-fablemocha-package-to-test-project","text":"Run the following command: dotnet add tests / Client package Fable . Mocha","title":"3. Add the Fable.Mocha package to Test project"},{"location":"recipes/developing-and-testing/testing-the-client/#4-add-something-to-test","text":"Add this function to Client.fs in the Client project let sayHello name = $ \"Hello {name}\"","title":"4. Add something to test"},{"location":"recipes/developing-and-testing/testing-the-client/#5-add-a-test","text":"Replace the contents of tests/Client/Library.fs with the following code: module Tests open Fable.Mocha let client = testList \"Client\" [ testCase \"Hello received\" <| fun _ -> let hello = Client . sayHello \"SAFE V3\" Expect . equal hello \"Hello SAFE V3\" \"Unexpected greeting\" ] let all = testList \"All\" [ client ] [< EntryPoint >] let main _ = Mocha . runTests all","title":"5. Add a test"},{"location":"recipes/developing-and-testing/testing-the-client/#6-add-test-web-page","text":"Add a file called index.html to the tests/Client folder with following contents: <!DOCTYPE html> < html > < head > < title > SAFE Client Tests </ title > </ head > < body > </ body > </ html >","title":"6. Add Test web page"},{"location":"recipes/developing-and-testing/testing-the-client/#7-add-test-webpack-config","text":"Add a file called webpack.tests.config.js to the root directory with the following contents:**** // Template for webpack.config.js in Fable projects // Find latest version in https://github.com/fable-compiler/webpack-config-template // In most cases, you'll only need to edit the CONFIG object (after dependencies) // See below if you need better fine-tuning of Webpack options // Dependencies. Also required: core-js, @babel/core, // @babel/preset-env, babel-loader, sass, sass-loader, css-loader, style-loader, file-loader, resolve-url-loader var path = require ( 'path' ); var webpack = require ( 'webpack' ); var HtmlWebpackPlugin = require ( 'html-webpack-plugin' ); var CopyWebpackPlugin = require ( 'copy-webpack-plugin' ); var CONFIG = { // The tags to include the generated JS and CSS will be automatically injected in the HTML template // See https://github.com/jantimon/html-webpack-plugin indexHtmlTemplate : 'tests/Client/index.html' , fsharpEntry : 'tests/Client/Library.fs.js' , outputDir : 'tests/Client' , assetsDir : 'tests/Client' , devServerPort : 8081 , // When using webpack-dev-server, you may need to redirect some calls // to a external API server. See https://webpack.js.org/configuration/dev-server/#devserver-proxy devServerProxy : undefined , babel : undefined } // If we're running the webpack-dev-server, assume we're in development mode var isProduction = ! process . argv . find ( v => v . indexOf ( 'webpack-dev-server' ) !== - 1 ); var environment = isProduction ? 'production' : 'development' ; process . env . NODE_ENV = environment ; console . log ( 'Bundling for ' + environment + '...' ); // The HtmlWebpackPlugin allows us to use a template for the index.html page // and automatically injects <script> or <link> tags for generated bundles. var commonPlugins = [ new HtmlWebpackPlugin ({ filename : 'index.html' , template : resolve ( CONFIG . indexHtmlTemplate ) }) ]; module . exports = { // In development, split the JavaScript and CSS files in order to // have a faster HMR support. In production bundle styles together // with the code because the MiniCssExtractPlugin will extract the // CSS in a separate files. entry : { app : resolve ( CONFIG . fsharpEntry ) }, // Add a hash to the output file name in production // to prevent browser caching if code changes output : { path : resolve ( CONFIG . outputDir ), filename : isProduction ? '[name].[hash].js' : '[name].js' }, mode : isProduction ? 'production' : 'development' , devtool : isProduction ? 'source-map' : 'eval-source-map' , optimization : { splitChunks : { chunks : 'all' }, }, // Besides the HtmlPlugin, we use the following plugins: // PRODUCTION // - MiniCssExtractPlugin: Extracts CSS from bundle to a different file // To minify CSS, see https://github.com/webpack-contrib/mini-css-extract-plugin#minimizing-for-production // - CopyWebpackPlugin: Copies static assets to output directory // DEVELOPMENT // - HotModuleReplacementPlugin: Enables hot reloading when code changes without refreshing plugins : isProduction ? commonPlugins . concat ([ new CopyWebpackPlugin ({ patterns : [{ from : resolve ( CONFIG . assetsDir ) }] }), ]) : commonPlugins . concat ([ new webpack . HotModuleReplacementPlugin (), ]), resolve : { // See https://github.com/fable-compiler/Fable/issues/1490 symlinks : false }, // Configuration for webpack-dev-server devServer : { publicPath : '/' , contentBase : resolve ( CONFIG . assetsDir ), host : '0.0.0.0' , port : CONFIG . devServerPort , proxy : CONFIG . devServerProxy , hot : true , inline : true }, module : { rules : [ ] } }; function resolve ( filePath ) { return path . isAbsolute ( filePath ) ? filePath : path . join ( __dirname , filePath ); }","title":"7. Add test webpack config"},{"location":"recipes/developing-and-testing/testing-the-client/#8-install-the-clients-dependencies","text":"npm install","title":"8. Install the client's dependencies"},{"location":"recipes/developing-and-testing/testing-the-client/#9-launch-the-test-website","text":"dotnet fable watch src / Client - -run webpack-dev-server - -config webpack . tests . config Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this:","title":"9. Launch the test website"},{"location":"recipes/developing-and-testing/testing-the-server/","text":"How do I test the Server? Testing your Server code in a SAFE app is just the same as in any other dotnet app, and you can use the same tools and frameworks that you are familiar with. These include all of the usual suspects such as NUnit , XUnit , FSUnit , Expecto , FSCheck , AutoFixture etc. In this guide we will look at using Expecto , as this is included with the standard SAFE template. I'm using the standard template Using the Expecto runner If you are using the standard template, then there is nothing more you need to do in order to start testing your Server code. In the tests/Server folder, there is a project named Server.Tests with a single script demonstrating how to use Expecto to test the TODO sample. In order to run the tests, instead of starting your application using dotnet run you should instead use dotnet run RunTests This will execute the tests and print the results into the console window. This method builds and runs the Client test project too, which can be slow. If you want to run the Server tests alone, you can simply navigate to the tests/Server directory and run the project using dotnet run . Using dotnet test or the Visual Studio Test runner If you would like to use dotnet tests from the command line or the test runner that comes with Visual Studio, there are a couple of extra steps to follow. 1. Install the Test Adapters Run the following commands at the root of your solution: dotnet paket add Microsoft . NET . Test . Sdk -p Server . Tests dotnet paket add YoloDev . Expecto . TestSdk -p Server . Tests 2. Disable EntryPoint generation Open your ServerTests.fsproj file and add the following element: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup> 3. Discover tests To allow your tests to be discovered, you will need to decorate them with a [<Tests>] attribute. The provided test would look like this: [< Tests >] let server = testList \"Server\" [ testCase \"Adding valid Todo\" <| fun _ -> let storage = Storage () let validTodo = Todo . create \"TODO\" let expectedResult = Ok () let result = storage . AddTodo validTodo Expect . equal result expectedResult \"Result should be ok\" Expect . contains ( storage . GetTodos () ) validTodo \"Storage should contain new todo\" ] 4. Run tests There are now two ways to run these tests. From the command line, you can just run dotnet test tests / Server from the root of your solution. Alternatively, if you are using Visual Studio or VS Mac you can make use of the built-in test explorers. I'm using the minimal template If you are using the minimal template, you will need to first configure a test project as none are included. 1. Add a test project Create a .Net 5 console project called Server.Tests in the tests/Server folder. dotnet new console -lang F # -n Server.Tests -o tests/Server dotnet sln add tests / Server 2. Reference the Server project Reference the Server project from the Server.Tests project: dotnet add tests / Server reference src / Server 3. Add Expecto to the Test project Run the following command: dotnet add tests / Server package Expecto 4. Add something to test Update the Server.fs file in the Server project to extract the message logic from the router like so: let getMessage () = \"Hello from SAFE!\" let webApp = router { get Route . hello ( getMessage () |> json ) } 5. Add a test Replace the contents of tests/Server/Program.fs with the following: open Expecto let server = testList \"Server\" [ testCase \"Message returned correctly\" <| fun _ -> let expectedResult = \"Hello from SAFE!\" let result = Server . getMessage () Expect . equal result expectedResult \"Result should be ok\" ] [< EntryPoint >] let main _ = runTests defaultConfig server 6. Run the test dotnet run -p tests / Server This will print out the results in the console window 7. Using dotnet test or the Visual Studio Test Explorer Add the libraries Microsoft.NET.Test.Sdk and YoloDev.Expecto.TestSdk to your Test project, using nuget. The way you do this will depend on whether you are using nuget directly or via Paket. See this recipe for more details. You can now add [<Test>] attributes to your tests so that they can be discovered, and then run them using the dotnet tooling in the same way as explained earlier for the standard template.","title":"Test the Server"},{"location":"recipes/developing-and-testing/testing-the-server/#how-do-i-test-the-server","text":"Testing your Server code in a SAFE app is just the same as in any other dotnet app, and you can use the same tools and frameworks that you are familiar with. These include all of the usual suspects such as NUnit , XUnit , FSUnit , Expecto , FSCheck , AutoFixture etc. In this guide we will look at using Expecto , as this is included with the standard SAFE template.","title":"How do I test the Server?"},{"location":"recipes/developing-and-testing/testing-the-server/#im-using-the-standard-template","text":"","title":"I'm using the standard template"},{"location":"recipes/developing-and-testing/testing-the-server/#using-the-expecto-runner","text":"If you are using the standard template, then there is nothing more you need to do in order to start testing your Server code. In the tests/Server folder, there is a project named Server.Tests with a single script demonstrating how to use Expecto to test the TODO sample. In order to run the tests, instead of starting your application using dotnet run you should instead use dotnet run RunTests This will execute the tests and print the results into the console window. This method builds and runs the Client test project too, which can be slow. If you want to run the Server tests alone, you can simply navigate to the tests/Server directory and run the project using dotnet run .","title":"Using the Expecto runner"},{"location":"recipes/developing-and-testing/testing-the-server/#using-dotnet-test-or-the-visual-studio-test-runner","text":"If you would like to use dotnet tests from the command line or the test runner that comes with Visual Studio, there are a couple of extra steps to follow.","title":"Using dotnet test or the Visual Studio Test runner"},{"location":"recipes/developing-and-testing/testing-the-server/#1-install-the-test-adapters","text":"Run the following commands at the root of your solution: dotnet paket add Microsoft . NET . Test . Sdk -p Server . Tests dotnet paket add YoloDev . Expecto . TestSdk -p Server . Tests","title":"1. Install the Test Adapters"},{"location":"recipes/developing-and-testing/testing-the-server/#2-disable-entrypoint-generation","text":"Open your ServerTests.fsproj file and add the following element: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup>","title":"2. Disable EntryPoint generation"},{"location":"recipes/developing-and-testing/testing-the-server/#3-discover-tests","text":"To allow your tests to be discovered, you will need to decorate them with a [<Tests>] attribute. The provided test would look like this: [< Tests >] let server = testList \"Server\" [ testCase \"Adding valid Todo\" <| fun _ -> let storage = Storage () let validTodo = Todo . create \"TODO\" let expectedResult = Ok () let result = storage . AddTodo validTodo Expect . equal result expectedResult \"Result should be ok\" Expect . contains ( storage . GetTodos () ) validTodo \"Storage should contain new todo\" ]","title":"3. Discover tests"},{"location":"recipes/developing-and-testing/testing-the-server/#4-run-tests","text":"There are now two ways to run these tests. From the command line, you can just run dotnet test tests / Server from the root of your solution. Alternatively, if you are using Visual Studio or VS Mac you can make use of the built-in test explorers.","title":"4. Run tests"},{"location":"recipes/developing-and-testing/testing-the-server/#im-using-the-minimal-template","text":"If you are using the minimal template, you will need to first configure a test project as none are included.","title":"I'm using the minimal template"},{"location":"recipes/developing-and-testing/testing-the-server/#1-add-a-test-project","text":"Create a .Net 5 console project called Server.Tests in the tests/Server folder. dotnet new console -lang F # -n Server.Tests -o tests/Server dotnet sln add tests / Server","title":"1. Add a test project"},{"location":"recipes/developing-and-testing/testing-the-server/#2-reference-the-server-project","text":"Reference the Server project from the Server.Tests project: dotnet add tests / Server reference src / Server","title":"2. Reference the Server project"},{"location":"recipes/developing-and-testing/testing-the-server/#3-add-expecto-to-the-test-project","text":"Run the following command: dotnet add tests / Server package Expecto","title":"3. Add Expecto to the Test project"},{"location":"recipes/developing-and-testing/testing-the-server/#4-add-something-to-test","text":"Update the Server.fs file in the Server project to extract the message logic from the router like so: let getMessage () = \"Hello from SAFE!\" let webApp = router { get Route . hello ( getMessage () |> json ) }","title":"4. Add something to test"},{"location":"recipes/developing-and-testing/testing-the-server/#5-add-a-test","text":"Replace the contents of tests/Server/Program.fs with the following: open Expecto let server = testList \"Server\" [ testCase \"Message returned correctly\" <| fun _ -> let expectedResult = \"Hello from SAFE!\" let result = Server . getMessage () Expect . equal result expectedResult \"Result should be ok\" ] [< EntryPoint >] let main _ = runTests defaultConfig server","title":"5. Add a test"},{"location":"recipes/developing-and-testing/testing-the-server/#6-run-the-test","text":"dotnet run -p tests / Server This will print out the results in the console window","title":"6. Run the test"},{"location":"recipes/developing-and-testing/testing-the-server/#7-using-dotnet-test-or-the-visual-studio-test-explorer","text":"Add the libraries Microsoft.NET.Test.Sdk and YoloDev.Expecto.TestSdk to your Test project, using nuget. The way you do this will depend on whether you are using nuget directly or via Paket. See this recipe for more details. You can now add [<Test>] attributes to your tests so that they can be discovered, and then run them using the dotnet tooling in the same way as explained earlier for the standard template.","title":"7. Using dotnet test or the Visual Studio Test Explorer"},{"location":"recipes/developing-and-testing/using-hot-reload/","text":"How do I use hot reload? Hot reload is a great time-saving technology and something that every developer will find useful. Whenever changes are made to code, they are immediately reflected in the running application without needing to manually redeploy. The specific way that this is achieved depends on the nature of the application. In a SAFE app we have two distinct components, the Client and the Server. Whether you are using the minimal or standard SAFE template, there is nothing more you need to do in order to get started with hot reload. Client reloading If you deploy your application and then make a change in the Client, after a moment it will be reflected in the browser without a full re-deployment. Importantly, the state of your application will be retained across the deployment, so you can continue where you left off. This is achieved using the hot module replacement functionality provided by webpack . To Add Hot Module Replacement manually If your client project has been hand-rolled, or you simply wish to see how to add it from scratch: 1. Configure the Webpack Dev Server Add the following to the devServer object of your webpack config: var devServer = { // other fields elided... hot : true , proxy : { // Redirect websocket requests that start with /socket/ to the server on the port 8085 // This is used by Hot Module Replacement '/socket/**' : { target : 'http://localhost:8085' , ws : true } } } 2. Configure webpack module exports Import and create an instance HotModuleReplacementPlugin at the top of the webpack configuration file, and ensure that the plugin is added to module.exports : // Import and create the HMR plugin var { HotModuleReplacementPlugin } = require ( 'webpack' ); var hmrPlugin = new HotModuleReplacementPlugin (); // other configuration... module . exports = { // Add the HMR plugin to the module plugins : [ /* other plugins... */ , hmrPlugin ] } 3. Update your F# client app First, add the Fable.Elmish.Hmr package to the client: dotnet add package Fable . Elmish . Hmr Then, open the Elmish.HMR namespace in your app: # if DEBUG open Elmish.Debug open Elmish.HMR # endif Best practice is to include hot module reloading in debug (not production) mode only, since production applications will not benefit from HMR and will only result in an increased bundle size. Server reloading Server reloading isn't quite as fully automated. If you make a change in the Server code and save your work, the project will automatically rebuild and launch itself. Once this is complete however you will need to refresh your browser to see any visual changes. If you are using the minimal template, you need to make sure you launch the Server using dotnet watch run rather than just dotnet run . The standard template takes care of this step for you using its FAKE build script. If you have already restored your NuGet dependencies, you can get a little boost in restart speed by using dotnet watch run --no-restore as well.","title":"Use hot reload"},{"location":"recipes/developing-and-testing/using-hot-reload/#how-do-i-use-hot-reload","text":"Hot reload is a great time-saving technology and something that every developer will find useful. Whenever changes are made to code, they are immediately reflected in the running application without needing to manually redeploy. The specific way that this is achieved depends on the nature of the application. In a SAFE app we have two distinct components, the Client and the Server. Whether you are using the minimal or standard SAFE template, there is nothing more you need to do in order to get started with hot reload.","title":"How do I use hot reload?"},{"location":"recipes/developing-and-testing/using-hot-reload/#client-reloading","text":"If you deploy your application and then make a change in the Client, after a moment it will be reflected in the browser without a full re-deployment. Importantly, the state of your application will be retained across the deployment, so you can continue where you left off. This is achieved using the hot module replacement functionality provided by webpack .","title":"Client reloading"},{"location":"recipes/developing-and-testing/using-hot-reload/#to-add-hot-module-replacement-manually","text":"If your client project has been hand-rolled, or you simply wish to see how to add it from scratch:","title":"To Add Hot Module Replacement manually"},{"location":"recipes/developing-and-testing/using-hot-reload/#1-configure-the-webpack-dev-server","text":"Add the following to the devServer object of your webpack config: var devServer = { // other fields elided... hot : true , proxy : { // Redirect websocket requests that start with /socket/ to the server on the port 8085 // This is used by Hot Module Replacement '/socket/**' : { target : 'http://localhost:8085' , ws : true } } }","title":"1. Configure the Webpack Dev Server"},{"location":"recipes/developing-and-testing/using-hot-reload/#2-configure-webpack-module-exports","text":"Import and create an instance HotModuleReplacementPlugin at the top of the webpack configuration file, and ensure that the plugin is added to module.exports : // Import and create the HMR plugin var { HotModuleReplacementPlugin } = require ( 'webpack' ); var hmrPlugin = new HotModuleReplacementPlugin (); // other configuration... module . exports = { // Add the HMR plugin to the module plugins : [ /* other plugins... */ , hmrPlugin ] }","title":"2. Configure webpack module exports"},{"location":"recipes/developing-and-testing/using-hot-reload/#3-update-your-f-client-app","text":"First, add the Fable.Elmish.Hmr package to the client: dotnet add package Fable . Elmish . Hmr Then, open the Elmish.HMR namespace in your app: # if DEBUG open Elmish.Debug open Elmish.HMR # endif Best practice is to include hot module reloading in debug (not production) mode only, since production applications will not benefit from HMR and will only result in an increased bundle size.","title":"3. Update your F# client app"},{"location":"recipes/developing-and-testing/using-hot-reload/#server-reloading","text":"Server reloading isn't quite as fully automated. If you make a change in the Server code and save your work, the project will automatically rebuild and launch itself. Once this is complete however you will need to refresh your browser to see any visual changes. If you are using the minimal template, you need to make sure you launch the Server using dotnet watch run rather than just dotnet run . The standard template takes care of this step for you using its FAKE build script. If you have already restored your NuGet dependencies, you can get a little boost in restart speed by using dotnet watch run --no-restore as well.","title":"Server reloading"},{"location":"recipes/javascript/import-js-module/","text":"How do I import a JavaScript module? Sometimes you need to use a JS library directly, instead of using it through a wrapper library that makes it easy to use from F# code. In this case you need to import a module from the library. Here are the most common import patterns used in JS. Default export Setup In most cases components use the default export syntax which is when the the component being exported from the module becomes available. For example, if the module being imported below looked something like: // module-name const foo = () => \"hello\" export default foo We can use the below syntax to have access to the function foo . import foo from 'module-name' // JS let foo = importDefault \"module-name\" // F# Testing the import To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. Browser . Dom . console . log ( \"imported value\" , foo ) Example An example of this in use is how React is imported import React from \"react\" // Although in the newer versions of React this is uneeded Named export Setup In some cases components can use the named export syntax. In the below case \"module-name\" has an object/function/class that is called bar . By referncing it below it is brought into the current scope. For example, if the module below contained something like: export const bar ( x , y ) => x + y We can directly access the function with the below syntax import { bar } from \"module-name\" // JS let bar = import \"bar\" \"module-name\" // F# Testing the import To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. Browser . Dom . console . log ( \"imported value\" , bar ) Example An example of this is how React hooks are imported import { useState } from \"react\" Entire module contents In rare cases you may have to import an entire module's contents and provide an alias in the below case we named it myModule. You can now use dot notation to access anything that is exported from module-name. For example, if the module being imported below includes an export to a function doAllTheAmazingThings() you could access it like: myModule . doAllTheAmazingThings () import * as myModule from 'module-name' // JS let myModule = importAll \"module-name\" // F# Testing the import To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. Browser . Dom . console . log ( \"imported value\" , myModule ) Example An example of this is another way to import React import * as React from \"react\" // Uncommon since importDefault is the standard More information See the Fable docs for more ways to import modules and use JavaScript from Fable.","title":"Import a JavaScript module"},{"location":"recipes/javascript/import-js-module/#how-do-i-import-a-javascript-module","text":"Sometimes you need to use a JS library directly, instead of using it through a wrapper library that makes it easy to use from F# code. In this case you need to import a module from the library. Here are the most common import patterns used in JS.","title":"How do I import a JavaScript module?"},{"location":"recipes/javascript/import-js-module/#default-export","text":"","title":"Default export"},{"location":"recipes/javascript/import-js-module/#setup","text":"In most cases components use the default export syntax which is when the the component being exported from the module becomes available. For example, if the module being imported below looked something like: // module-name const foo = () => \"hello\" export default foo We can use the below syntax to have access to the function foo . import foo from 'module-name' // JS let foo = importDefault \"module-name\" // F#","title":"Setup"},{"location":"recipes/javascript/import-js-module/#testing-the-import","text":"To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. Browser . Dom . console . log ( \"imported value\" , foo )","title":"Testing the import"},{"location":"recipes/javascript/import-js-module/#example","text":"An example of this in use is how React is imported import React from \"react\" // Although in the newer versions of React this is uneeded","title":"Example"},{"location":"recipes/javascript/import-js-module/#named-export","text":"","title":"Named export"},{"location":"recipes/javascript/import-js-module/#setup_1","text":"In some cases components can use the named export syntax. In the below case \"module-name\" has an object/function/class that is called bar . By referncing it below it is brought into the current scope. For example, if the module below contained something like: export const bar ( x , y ) => x + y We can directly access the function with the below syntax import { bar } from \"module-name\" // JS let bar = import \"bar\" \"module-name\" // F#","title":"Setup"},{"location":"recipes/javascript/import-js-module/#testing-the-import_1","text":"To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. Browser . Dom . console . log ( \"imported value\" , bar )","title":"Testing the import"},{"location":"recipes/javascript/import-js-module/#example_1","text":"An example of this is how React hooks are imported import { useState } from \"react\"","title":"Example"},{"location":"recipes/javascript/import-js-module/#entire-module-contents","text":"In rare cases you may have to import an entire module's contents and provide an alias in the below case we named it myModule. You can now use dot notation to access anything that is exported from module-name. For example, if the module being imported below includes an export to a function doAllTheAmazingThings() you could access it like: myModule . doAllTheAmazingThings () import * as myModule from 'module-name' // JS let myModule = importAll \"module-name\" // F#","title":"Entire module contents"},{"location":"recipes/javascript/import-js-module/#testing-the-import_2","text":"To ensure that the import was successful you can console log the value and you should see the value in the browsers console window which you can get to by right-clicking and selecting the Inspect Element. Browser . Dom . console . log ( \"imported value\" , myModule )","title":"Testing the import"},{"location":"recipes/javascript/import-js-module/#example_2","text":"An example of this is another way to import React import * as React from \"react\" // Uncommon since importDefault is the standard","title":"Example"},{"location":"recipes/javascript/import-js-module/#more-information","text":"See the Fable docs for more ways to import modules and use JavaScript from Fable.","title":"More information"},{"location":"recipes/javascript/third-party-react-package/","text":"To use a third-party React library in a SAFE application, you need to write an F# wrapper around it. There are two ways for doing this - using Fable.React or using Feliz . Prerequisites This recipe uses the react-d3-speedometer NPM package for demonstration purposes. Add it to your Client before continuing. Fable.React - Setup 1. Create a new file Create an empty file named ReactSpeedometer.fs in the Client project above Index.fs and insert the following statements at the beginning of the file. module ReactSpeedometer open Fable.Core open Fable.Core.JsInterop open Fable.React 2. Define the Props Prop represents the props of the React component. In this recipe, we're using the props listed here for react-d3-speedometer . We model them in Fable.React using a discriminated union. type Prop = | Value of int | MinValue of int | MaxValue of int | StartColor of string One difference to note is that we use P ascalCase rather than c amelCase. Note that we can model any props here, both simple values and \"event handler\"-style ones. 3. Write the Component Add the following function to the file. Note that the last argument passed into the ofImport function is a list of ReactElements to be used as children of the react component. In this case, we are passing an empty list since the component doesn't have children. let reactSpeedometer ( props : Prop list ) : ReactElement = let propsObject = keyValueList CaseRules . LowerFirst props // converts Props to JS object ofImport \"default\" \"react-d3-speedometer\" propsObject [] // import the default function/object from react-d3-speedometer 4. Use the Component With all these in place, you can use the React element in your client like so: open ReactSpeedometer reactSpeedometer [ Prop . Value 10 // Since Value is already decalred in HTMLAttr you can use Prop.Value to tell the F# compiler its of type Prop and not HTMLAttr MaxValue 100 MinValue 0 StartColor \"red\" ] Feliz - Setup If you don't already have Feliz installed, add it to your client . In the Client projects Index.fs add the following snippets open Fable.Core.JsInterop Within the view function Feliz . Interop . reactApi . createElement ( importDefault \"react-d3-speedometer\" , createObj [ \"minValue\" ==> 0 \"maxValue\" ==> 100 \"value\" ==> 10 ]) createElement from Feliz.ReactApi.IReactApi takes the component you're wrapping react-d3-speedometer, the props that component takes and creates a ReactComponent we can use in F#. importDefault from Fable.Core.JsInterop is giving us access to the component and is equivalent to import ReactSpeedometer from \"react-d3-speedometer\" The reason for using importDefault is the documentation for the component uses a default export \"ReactSpeedometer\". Please find a list of common import statetments at the end of this recipe As a quick check to ensure that the library is being imported and we have no typos you can console.log the following at the top within the view function Browser . Dom . console . log ( \"REACT-D3-IMPORT\" , importDefault \"react-d3-speedometer\" ) In the console window (which can be reached by right-clicking and selecting Insepct Element) you should see some output from the above log. If nothing is being seen you may need a slightly different import statement, please refer to this recipe . createObj from Fable.Core.JsInterop takes a sequence of string * obj which is a prop name and value for the component, you can find the full prop list for react-d3-speedometer here . Using ==> (short hand for prop.custom ) to transform the sequence into a javascript object createObj [ \"minValue\" ==> 0 \"maxValue\" ==> 10 ] Is equivalent to { minValue : 0 , maxValue : 10 } That's the bare minimum needed to get going! Next steps for Feliz Once your component is working you may want to extract out the logic so that it can be used in multiple pages of your app. For a full detailed tutorial head over to this blog post !","title":"Add Support for a Third Party React Library"},{"location":"recipes/javascript/third-party-react-package/#prerequisites","text":"This recipe uses the react-d3-speedometer NPM package for demonstration purposes. Add it to your Client before continuing.","title":"Prerequisites"},{"location":"recipes/javascript/third-party-react-package/#fablereact-setup","text":"","title":"Fable.React - Setup"},{"location":"recipes/javascript/third-party-react-package/#1-create-a-new-file","text":"Create an empty file named ReactSpeedometer.fs in the Client project above Index.fs and insert the following statements at the beginning of the file. module ReactSpeedometer open Fable.Core open Fable.Core.JsInterop open Fable.React","title":"1. Create a new file"},{"location":"recipes/javascript/third-party-react-package/#2-define-the-props","text":"Prop represents the props of the React component. In this recipe, we're using the props listed here for react-d3-speedometer . We model them in Fable.React using a discriminated union. type Prop = | Value of int | MinValue of int | MaxValue of int | StartColor of string One difference to note is that we use P ascalCase rather than c amelCase. Note that we can model any props here, both simple values and \"event handler\"-style ones.","title":"2. Define the Props"},{"location":"recipes/javascript/third-party-react-package/#3-write-the-component","text":"Add the following function to the file. Note that the last argument passed into the ofImport function is a list of ReactElements to be used as children of the react component. In this case, we are passing an empty list since the component doesn't have children. let reactSpeedometer ( props : Prop list ) : ReactElement = let propsObject = keyValueList CaseRules . LowerFirst props // converts Props to JS object ofImport \"default\" \"react-d3-speedometer\" propsObject [] // import the default function/object from react-d3-speedometer","title":"3. Write the Component"},{"location":"recipes/javascript/third-party-react-package/#4-use-the-component","text":"With all these in place, you can use the React element in your client like so: open ReactSpeedometer reactSpeedometer [ Prop . Value 10 // Since Value is already decalred in HTMLAttr you can use Prop.Value to tell the F# compiler its of type Prop and not HTMLAttr MaxValue 100 MinValue 0 StartColor \"red\" ]","title":"4. Use the Component"},{"location":"recipes/javascript/third-party-react-package/#feliz-setup","text":"If you don't already have Feliz installed, add it to your client . In the Client projects Index.fs add the following snippets open Fable.Core.JsInterop Within the view function Feliz . Interop . reactApi . createElement ( importDefault \"react-d3-speedometer\" , createObj [ \"minValue\" ==> 0 \"maxValue\" ==> 100 \"value\" ==> 10 ]) createElement from Feliz.ReactApi.IReactApi takes the component you're wrapping react-d3-speedometer, the props that component takes and creates a ReactComponent we can use in F#. importDefault from Fable.Core.JsInterop is giving us access to the component and is equivalent to import ReactSpeedometer from \"react-d3-speedometer\" The reason for using importDefault is the documentation for the component uses a default export \"ReactSpeedometer\". Please find a list of common import statetments at the end of this recipe As a quick check to ensure that the library is being imported and we have no typos you can console.log the following at the top within the view function Browser . Dom . console . log ( \"REACT-D3-IMPORT\" , importDefault \"react-d3-speedometer\" ) In the console window (which can be reached by right-clicking and selecting Insepct Element) you should see some output from the above log. If nothing is being seen you may need a slightly different import statement, please refer to this recipe . createObj from Fable.Core.JsInterop takes a sequence of string * obj which is a prop name and value for the component, you can find the full prop list for react-d3-speedometer here . Using ==> (short hand for prop.custom ) to transform the sequence into a javascript object createObj [ \"minValue\" ==> 0 \"maxValue\" ==> 10 ] Is equivalent to { minValue : 0 , maxValue : 10 } That's the bare minimum needed to get going!","title":"Feliz - Setup"},{"location":"recipes/javascript/third-party-react-package/#next-steps-for-feliz","text":"Once your component is working you may want to extract out the logic so that it can be used in multiple pages of your app. For a full detailed tutorial head over to this blog post !","title":"Next steps for Feliz"},{"location":"recipes/package-management/add-npm-package-to-client/","text":"How do I add an NPM package to the Client? When you want to call a Javascript library from your Client, it is easy to import and reference it using NPM . Run the following command: npm install name-of-package This will download the package into the solution's node_modules folder. You will also see a reference to the package in the Client's package.json file: \"dependencies\" : { \"name-of-package\" : \"^1.0.0\" }","title":"Add an NPM package to the Client"},{"location":"recipes/package-management/add-npm-package-to-client/#how-do-i-add-an-npm-package-to-the-client","text":"When you want to call a Javascript library from your Client, it is easy to import and reference it using NPM . Run the following command: npm install name-of-package This will download the package into the solution's node_modules folder. You will also see a reference to the package in the Client's package.json file: \"dependencies\" : { \"name-of-package\" : \"^1.0.0\" }","title":"How do I add an NPM package to the Client?"},{"location":"recipes/package-management/add-nuget-package-to-client/","text":"How do I add a Nuget package to the Client? Adding packages to the Client project is a very similar process to the Server , with one important difference: Although the Client code is written in F#, at runtime it is converted into Javascript using Fable . Because of this, we must be careful to only reference libraries which are Fable compatible . There are lots of great libraries available to choose from.","title":"Add a Nuget package to the Client"},{"location":"recipes/package-management/add-nuget-package-to-client/#how-do-i-add-a-nuget-package-to-the-client","text":"Adding packages to the Client project is a very similar process to the Server , with one important difference: Although the Client code is written in F#, at runtime it is converted into Javascript using Fable . Because of this, we must be careful to only reference libraries which are Fable compatible . There are lots of great libraries available to choose from.","title":"How do I add a Nuget package to the Client?"},{"location":"recipes/package-management/add-nuget-package-to-server/","text":"How do I add a Nuget package to the Server? You can add nuget packages to the server to give it more capabilities. You can download a wide variety of packages from the official NuGet site . In this example we will add the FsToolkit ErrorHandling package package. I'm using the standard template (Paket) 1. Add the package Navigate to the root directory of your solution and run: dotnet paket add FsToolkit.ErrorHandling -p Server This will add an entry to both the solution paket.dependencies file and the Server project's paket.reference file, as well as update the lock file with the updated dependency graph. Find information on how you can convert your project from nuget to Paket here . For a detailed explanation of package management using Paket, visit the official docs . I'm using the minimal template (NuGet) 1. Navigate to the Server project directory 2. Add the package Run the following command: dotnet add package FsToolkit.ErrorHandling Once you have done this, you will find an element in your fsproj file which looks like this: <ItemGroup> <PackageReference Include= \"FsToolkit.ErrorHandling\" Version= \"1.4.3\" /> </ItemGroup> You can also achieve the same thing using the Visual Studio Package Manager , the VS Mac Package Manager or the Package Manager Console . For a detailed explanation of package management using Nuget, visit the official docs .","title":"Add a NuGet package to the Server"},{"location":"recipes/package-management/add-nuget-package-to-server/#how-do-i-add-a-nuget-package-to-the-server","text":"You can add nuget packages to the server to give it more capabilities. You can download a wide variety of packages from the official NuGet site . In this example we will add the FsToolkit ErrorHandling package package.","title":"How do I add a Nuget package to the Server?"},{"location":"recipes/package-management/add-nuget-package-to-server/#im-using-the-standard-template-paket","text":"","title":"I'm using the standard template (Paket)"},{"location":"recipes/package-management/add-nuget-package-to-server/#1-add-the-package","text":"Navigate to the root directory of your solution and run: dotnet paket add FsToolkit.ErrorHandling -p Server This will add an entry to both the solution paket.dependencies file and the Server project's paket.reference file, as well as update the lock file with the updated dependency graph. Find information on how you can convert your project from nuget to Paket here . For a detailed explanation of package management using Paket, visit the official docs .","title":"1. Add the package"},{"location":"recipes/package-management/add-nuget-package-to-server/#im-using-the-minimal-template-nuget","text":"","title":"I'm using the minimal template (NuGet)"},{"location":"recipes/package-management/add-nuget-package-to-server/#1-navigate-to-the-server-project-directory","text":"","title":"1. Navigate to the Server project directory"},{"location":"recipes/package-management/add-nuget-package-to-server/#2-add-the-package","text":"Run the following command: dotnet add package FsToolkit.ErrorHandling Once you have done this, you will find an element in your fsproj file which looks like this: <ItemGroup> <PackageReference Include= \"FsToolkit.ErrorHandling\" Version= \"1.4.3\" /> </ItemGroup> You can also achieve the same thing using the Visual Studio Package Manager , the VS Mac Package Manager or the Package Manager Console . For a detailed explanation of package management using Nuget, visit the official docs .","title":"2. Add the package"},{"location":"recipes/package-management/migrate-to-paket/","text":"How do I migrate to Paket from NuGet? Paket is a fully featured package manager that acts as an alternative to the NuGet package manager. It can help you reference libraries from NuGet, Git repositories or Http resources. It also provides precise control over your dependencies, separating direct and transitive references and capturing the exact configuration with each commit. You can find out more at the Paket website. Note that the standard template uses Paket by default. This recipe only applies to the minimal template . 1. Install and restore Paket dotnet tool install paket dotnet tool restore 2. Run the Migration Run this command to move existing Nuget references to Paket from your packages.config or .fsproj file: dotnet paket convert-from-nuget This will add three files to your solution, all of which should be committed to source control: paket.dependencies : This will be at the solution root and contains the top level list of dependencies for your project. It is also used to specify any rules such as where they should be downloaded from and which versions etc. paket.lock : This will also be at the solution root and contains the concrete resolution of all direct and transitive dependencies. paket.references : There will be one of these in each project directory. It simply specifies which packages the project requires. For a more detailed explanation of this process see the official migration guide. In the case where you have added a nuget project to a solution which is already using paket, run this command with the option --force . If you are working in Visual Studio and wish to see your Paket files in the Solution Explorer, you will need to add both the paket.lock and any paket.references files created in your project directories during the last step to your solution.","title":"Migrate to Paket from NuGet"},{"location":"recipes/package-management/migrate-to-paket/#how-do-i-migrate-to-paket-from-nuget","text":"Paket is a fully featured package manager that acts as an alternative to the NuGet package manager. It can help you reference libraries from NuGet, Git repositories or Http resources. It also provides precise control over your dependencies, separating direct and transitive references and capturing the exact configuration with each commit. You can find out more at the Paket website. Note that the standard template uses Paket by default. This recipe only applies to the minimal template .","title":"How do I migrate to Paket from NuGet?"},{"location":"recipes/package-management/migrate-to-paket/#1-install-and-restore-paket","text":"dotnet tool install paket dotnet tool restore","title":"1. Install and restore Paket"},{"location":"recipes/package-management/migrate-to-paket/#2-run-the-migration","text":"Run this command to move existing Nuget references to Paket from your packages.config or .fsproj file: dotnet paket convert-from-nuget This will add three files to your solution, all of which should be committed to source control: paket.dependencies : This will be at the solution root and contains the top level list of dependencies for your project. It is also used to specify any rules such as where they should be downloaded from and which versions etc. paket.lock : This will also be at the solution root and contains the concrete resolution of all direct and transitive dependencies. paket.references : There will be one of these in each project directory. It simply specifies which packages the project requires. For a more detailed explanation of this process see the official migration guide. In the case where you have added a nuget project to a solution which is already using paket, run this command with the option --force . If you are working in Visual Studio and wish to see your Paket files in the Solution Explorer, you will need to add both the paket.lock and any paket.references files created in your project directories during the last step to your solution.","title":"2. Run the Migration"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/","text":"How do I ensure NPM and Nuget packages stay in sync? SAFE Stack uses Fable bindings, which are NuGet packages that provide idiomatic and type-safe wrappers around native JavaScript APIs. These bindings often rely on third-party JavaScript libraries distributed via the NPM registry. This leads to the problem of keeping both the NPM package in sync with its corresponding NuGet F# wrapper. Femto is a dotnet CLI tool that solves this issue. For in-depth information about Femto, see Introducing Femto . 1. Install Femto Navigate to the root folder of the solution and execute the following command: dotnet tool install femto 2. Analyse Dependencies In the root directory, run the following: dotnet femto ./ src / Client alternatively, you can call femto directly from ./src/Client : cd ./ src / Client dotnet femto This will give you a report of discrepancies between the NuGet packages and the NPM packages for the project, as well as steps to take in order to resolve them. 3. Resolve Dependencies To sync your NPM dependencies with your NuGet dependencies, you can either manually follow the steps returned by step 2 , or resolve them automatically using the following command: dotnet femto ./ src / Client - -resolve Done! Keeping your NPM dependencies in sync with your NuGet packages is now as easy as repeating step 3. Of course, you can instead repeat the step 2 and resolve packages manually, too.","title":"Sync NuGet and NPM Packages"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#how-do-i-ensure-npm-and-nuget-packages-stay-in-sync","text":"SAFE Stack uses Fable bindings, which are NuGet packages that provide idiomatic and type-safe wrappers around native JavaScript APIs. These bindings often rely on third-party JavaScript libraries distributed via the NPM registry. This leads to the problem of keeping both the NPM package in sync with its corresponding NuGet F# wrapper. Femto is a dotnet CLI tool that solves this issue. For in-depth information about Femto, see Introducing Femto .","title":"How do I ensure NPM and Nuget packages stay in sync?"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#1-install-femto","text":"Navigate to the root folder of the solution and execute the following command: dotnet tool install femto","title":"1. Install Femto"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#2-analyse-dependencies","text":"In the root directory, run the following: dotnet femto ./ src / Client alternatively, you can call femto directly from ./src/Client : cd ./ src / Client dotnet femto This will give you a report of discrepancies between the NuGet packages and the NPM packages for the project, as well as steps to take in order to resolve them.","title":"2. Analyse Dependencies"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#3-resolve-dependencies","text":"To sync your NPM dependencies with your NuGet dependencies, you can either manually follow the steps returned by step 2 , or resolve them automatically using the following command: dotnet femto ./ src / Client - -resolve","title":"3. Resolve Dependencies"},{"location":"recipes/package-management/sync-nuget-and-npm-packages/#done","text":"Keeping your NPM dependencies in sync with your NuGet packages is now as easy as repeating step 3. Of course, you can instead repeat the step 2 and resolve packages manually, too.","title":"Done!"},{"location":"recipes/storage/use-litedb/","text":"How Do I Use LiteDB? The default template uses in-memory storage. This recipe will show you how to replace the in-memory storage with LiteDB in the form of LiteDB.FSharp . If you're using the minimal template, the first steps will show you how to add a LiteDB database; the remaining section of this recipe are designed to work off the default template's starter app. 1. Add LiteDB.FSharp Add the LiteDB.FSharp NuGet package to the server project . 2. Create the database Replace the use of the ResizeArray in the Storage type with a database and collection: open LiteDB.FSharp open LiteDB type Storage () = let database = let mapper = FSharpBsonMapper () let connStr = \"Filename=Todo.db;mode=Exclusive\" new LiteDatabase ( connStr , mapper ) let todos = database . GetCollection < Todo > \"todos\" LiteDb is a file-based database, and will create the file if it does not exist automatically. This will create a database file Todo.db in the Server folder. The option mode=Exclusive is added for MacOS support (see this issue ). See here for more information on connection string arguments. See the official docs for details on constructor arguments. 3. Implement the rest of the repository Replace the implementations of GetTodos and AddTodo as follows: /// Retrieves all todo items. member _ . GetTodos () = todos . FindAll () |> List . ofSeq /// Tries to add a todo item to the collection. member _ . AddTodo ( todo : Todo ) = if Todo . isValid todo . Description then todos . Insert todo |> ignore Ok () else Error \"Invalid todo\" 4. Initialise the database Modify the existing \"priming\" so that it first checks if there are any records in the database before inserting data: if storage . GetTodos () |> Seq . isEmpty then storage . AddTodo ( Todo . create \"Create new SAFE project\" ) |> ignore storage . AddTodo ( Todo . create \"Write your app\" ) |> ignore storage . AddTodo ( Todo . create \"Ship it !!!\" ) |> ignore 5. Make Todo compatible with LiteDb Add the CLIMutable attribute to the Todo record in Shared.fs [< CLIMutable >] type Todo = { Id : Guid Description : string } This is required to allow LiteDB to hydrate (read) data into F# records. All Done! Run the application. You will see that a database has been created in the Server folder and that you are presented with the standard TODO list. Add an item and restart the application; observe that your data is still there.","title":"Quickly add a database"},{"location":"recipes/storage/use-litedb/#how-do-i-use-litedb","text":"The default template uses in-memory storage. This recipe will show you how to replace the in-memory storage with LiteDB in the form of LiteDB.FSharp . If you're using the minimal template, the first steps will show you how to add a LiteDB database; the remaining section of this recipe are designed to work off the default template's starter app.","title":"How Do I Use LiteDB?"},{"location":"recipes/storage/use-litedb/#1-add-litedbfsharp","text":"Add the LiteDB.FSharp NuGet package to the server project .","title":"1. Add LiteDB.FSharp"},{"location":"recipes/storage/use-litedb/#2-create-the-database","text":"Replace the use of the ResizeArray in the Storage type with a database and collection: open LiteDB.FSharp open LiteDB type Storage () = let database = let mapper = FSharpBsonMapper () let connStr = \"Filename=Todo.db;mode=Exclusive\" new LiteDatabase ( connStr , mapper ) let todos = database . GetCollection < Todo > \"todos\" LiteDb is a file-based database, and will create the file if it does not exist automatically. This will create a database file Todo.db in the Server folder. The option mode=Exclusive is added for MacOS support (see this issue ). See here for more information on connection string arguments. See the official docs for details on constructor arguments.","title":"2. Create the database"},{"location":"recipes/storage/use-litedb/#3-implement-the-rest-of-the-repository","text":"Replace the implementations of GetTodos and AddTodo as follows: /// Retrieves all todo items. member _ . GetTodos () = todos . FindAll () |> List . ofSeq /// Tries to add a todo item to the collection. member _ . AddTodo ( todo : Todo ) = if Todo . isValid todo . Description then todos . Insert todo |> ignore Ok () else Error \"Invalid todo\"","title":"3. Implement the rest of the repository"},{"location":"recipes/storage/use-litedb/#4-initialise-the-database","text":"Modify the existing \"priming\" so that it first checks if there are any records in the database before inserting data: if storage . GetTodos () |> Seq . isEmpty then storage . AddTodo ( Todo . create \"Create new SAFE project\" ) |> ignore storage . AddTodo ( Todo . create \"Write your app\" ) |> ignore storage . AddTodo ( Todo . create \"Ship it !!!\" ) |> ignore","title":"4. Initialise the database"},{"location":"recipes/storage/use-litedb/#5-make-todo-compatible-with-litedb","text":"Add the CLIMutable attribute to the Todo record in Shared.fs [< CLIMutable >] type Todo = { Id : Guid Description : string } This is required to allow LiteDB to hydrate (read) data into F# records.","title":"5. Make Todo compatible with LiteDb"},{"location":"recipes/storage/use-litedb/#all-done","text":"Run the application. You will see that a database has been created in the Server folder and that you are presented with the standard TODO list. Add an item and restart the application; observe that your data is still there.","title":"All Done!"},{"location":"recipes/storage/use-sqlprovider-ssdt/","text":"Using SQLProvider SQL Server SSDT Creating a \"SafeTodo\" Database with Azure Data Studio Connecting to a SQL Server Instance 1) In the \"Connections\" tab, click the \"New Connection\" button 2) Enter your connection details, leaving the \"Database\" dropdown set to <Default> . Creating a new \"SafeTodo\" Database Right click your server and choose \"New Query\" Execute this script: USE master GO IF NOT EXISTS ( SELECT name FROM sys . databases WHERE name = N 'SafeTodo' ) CREATE DATABASE [ SafeTodo ]; GO IF SERVERPROPERTY ( 'ProductVersion' ) > '12' ALTER DATABASE [ SafeTodo ] SET QUERY_STORE = ON ; GO Right click the \"Databases\" folder and choose \"Refresh\" to see the new database. NOTE: Alternatively, if you don't want to manually create the new database, you can install the \"New Database\" extension in Azure Data Studio which gives you a \"New Database\" option when right clicking the \"Databases\" folder. Create a \"Todos\" Table CREATE TABLE [ dbo ].[ Todos ] ( [ Id ] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY , [ Description ] NVARCHAR ( 500 ) NOT NULL , [ IsDone ] BIT NOT NULL ) Creating an SSDT Project (.sqlproj) At this point, you should have a SAFE Stack solution and a minimal \"SafeTodo\" SQL Server database with a \"Todos\" table. Next, we will use Azure Data Studio with the \"SQL Database Projects\" extension to create a new SSDT (SQL Server Data Tools) .sqlproj that will live in our SAFE Stack .sln. 1) Install the \"SQL Database Projects\" extension. 2) Right click the SafeTodo database and choose \"Create Project From Database\" (this option is added by the \"SQL Database Projects\" extension) 3) Configure a path within your SAFE Stack solution folder and a project name and then click \"Create\". NOTE: If you choose to create an \"ssdt\" subfolder as I did, you will need to manually create this subfolder first. 4) You should now be able to view your SQL Project by clicking the \"Projects\" tab in Azure Data Studio. 5) Finally, right click the SafeTodoDB project and select \"Build\". This will create a .dacpac file which we will use in the next step. Create a TodoRepository Using the new SSDT provider in SQLProvider Installing SQLProvider from NuGet Install the SQLProvider NuGet package to the Server project Install the System.Data.SqlClient NuGet package to the Server project Initialize Type Provider Next, we will wire up our type provider to generate database types based on the compiled .dacpac file. 1) In the Server project, create a new file, Database.fs . (this should be above Server.fs ). module Database open FSharp.Data.Sql [< Literal >] let SsdtPath = __ SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Debug/SafeTodoDB.dacpac\" // TO RELOAD SCHEMA: 1) uncomment the line below; 2) save; 3) recomment; 4) save again and wait. //DB.GetDataContext().``Design Time Commands``.ClearDatabaseSchemaCache type DB = SqlDataProvider < Common . DatabaseProviderTypes . MSSQLSERVER_SSDT , SsdtPath = SsdtPath , UseOptionTypes = true > let createContext ( connectionString : string ) = DB . GetDataContext ( connectionString ) 2) Create TodoRepository.fs below Database.fs . module TodoRepository open FSharp.Data.Sql open Database open Shared /// Get all todos that have not been marked as \"done\". let getTodos ( db : DB . dataContext ) = query { for todo in db . Dbo . Todos do where ( not todo . IsDone ) select { Shared . Todo . Id = todo . Id Shared . Todo . Description = todo . Description } } |> List . executeQueryAsync let addTodo ( db : DB . dataContext ) ( todo : Shared . Todo ) = async { let t = db . Dbo . Todos . Create () t . Id <- todo . Id t . Description <- todo . Description t . IsDone <- false do ! db . SubmitUpdatesAsync () } 3) Create TodoController.fs below TodoRepository.fs . module TodoController open Database open Shared let getTodos ( db : DB . dataContext ) = TodoRepository . getTodos db let addTodo ( db : DB . dataContext ) ( todo : Todo ) = async { if Todo . isValid todo . Description then do ! TodoRepository . addTodo db todo return todo else return failwith \"Invalid todo\" } 4) Finally, replace the stubbed todosApi implementation in Server.fs with our type provided implementation. module Server open Fable.Remoting.Server open Fable.Remoting.Giraffe open Saturn open System open Shared open Microsoft.AspNetCore.Http let todosApi = let db = Database . createContext @\"Data Source=.\\SQLEXPRESS;Initial Catalog=SafeTodo;Integrated Security=SSPI;\" { getTodos = fun () -> TodoController . getTodos db addTodo = TodoController . addTodo db } let fableRemotingErrorHandler ( ex : Exception ) ( ri : RouteInfo < HttpContext >) = printfn \"ERROR: %s\" ex . Message Propagate ex . Message let webApp = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder |> Remoting . fromValue todosApi |> Remoting . withErrorHandler fableRemotingErrorHandler |> Remoting . buildHttpHandler let app = application { url \"http://0.0.0.0:8085\" use_router webApp memory_cache use_static \"public\" use_gzip } run app Run the App! From the VS Code terminal in the SafeTodo folder, launch the app (server and client): dotnet run You should now be able to add todos. Deployment When creating a Release build for deployment, it is important to note that SQLProvider SSDT expects that the .dacpac file will be copied to the deployed Server project bin folder. Here are the steps to accomplish this: 1) Modify your Server.fsproj to include the .dacpac file with \"CopyToOutputDirectory\" to ensure that the .dacpac file will always exist in the Server project bin folder. <ItemGroup> <None Include=\"..\\{relative path to SSDT project}\\ssdt\\SafeTodo\\bin\\$(Configuration)\\SafeTodoDB.dacpac\" Link=\"SafeTodoDB.dacpac\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> </None> { other files... } </ItemGroup> 2) In your Server.Database.fs file, you should also modify the SsdtPath binding so that it can build the project in either Debug or Release mode: [< Literal >] # if DEBUG let SsdtPath = __ SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Debug/SafeTodoDB.dacpac\" # else let SsdtPath = __ SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Release/SafeTodoDB.dacpac\" # endif NOTE: This assumes that your SSDT .sqlproj will be built in Release mode. (You can build it manually, or use a FAKE build script to handle this.)","title":"Create a data module using SQLProvider SQL Server SSDT"},{"location":"recipes/storage/use-sqlprovider-ssdt/#using-sqlprovider-sql-server-ssdt","text":"","title":"Using SQLProvider SQL Server SSDT"},{"location":"recipes/storage/use-sqlprovider-ssdt/#creating-a-safetodo-database-with-azure-data-studio","text":"","title":"Creating a \"SafeTodo\" Database with Azure Data Studio"},{"location":"recipes/storage/use-sqlprovider-ssdt/#connecting-to-a-sql-server-instance","text":"1) In the \"Connections\" tab, click the \"New Connection\" button 2) Enter your connection details, leaving the \"Database\" dropdown set to <Default> .","title":"Connecting to a SQL Server Instance"},{"location":"recipes/storage/use-sqlprovider-ssdt/#creating-a-new-safetodo-database","text":"Right click your server and choose \"New Query\" Execute this script: USE master GO IF NOT EXISTS ( SELECT name FROM sys . databases WHERE name = N 'SafeTodo' ) CREATE DATABASE [ SafeTodo ]; GO IF SERVERPROPERTY ( 'ProductVersion' ) > '12' ALTER DATABASE [ SafeTodo ] SET QUERY_STORE = ON ; GO Right click the \"Databases\" folder and choose \"Refresh\" to see the new database. NOTE: Alternatively, if you don't want to manually create the new database, you can install the \"New Database\" extension in Azure Data Studio which gives you a \"New Database\" option when right clicking the \"Databases\" folder.","title":"Creating a new \"SafeTodo\" Database"},{"location":"recipes/storage/use-sqlprovider-ssdt/#create-a-todos-table","text":"CREATE TABLE [ dbo ].[ Todos ] ( [ Id ] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY , [ Description ] NVARCHAR ( 500 ) NOT NULL , [ IsDone ] BIT NOT NULL )","title":"Create a \"Todos\" Table"},{"location":"recipes/storage/use-sqlprovider-ssdt/#creating-an-ssdt-project-sqlproj","text":"At this point, you should have a SAFE Stack solution and a minimal \"SafeTodo\" SQL Server database with a \"Todos\" table. Next, we will use Azure Data Studio with the \"SQL Database Projects\" extension to create a new SSDT (SQL Server Data Tools) .sqlproj that will live in our SAFE Stack .sln. 1) Install the \"SQL Database Projects\" extension. 2) Right click the SafeTodo database and choose \"Create Project From Database\" (this option is added by the \"SQL Database Projects\" extension) 3) Configure a path within your SAFE Stack solution folder and a project name and then click \"Create\". NOTE: If you choose to create an \"ssdt\" subfolder as I did, you will need to manually create this subfolder first. 4) You should now be able to view your SQL Project by clicking the \"Projects\" tab in Azure Data Studio. 5) Finally, right click the SafeTodoDB project and select \"Build\". This will create a .dacpac file which we will use in the next step.","title":"Creating an SSDT Project (.sqlproj)"},{"location":"recipes/storage/use-sqlprovider-ssdt/#create-a-todorepository-using-the-new-ssdt-provider-in-sqlprovider","text":"","title":"Create a TodoRepository Using the new SSDT provider in SQLProvider"},{"location":"recipes/storage/use-sqlprovider-ssdt/#installing-sqlprovider-from-nuget","text":"Install the SQLProvider NuGet package to the Server project Install the System.Data.SqlClient NuGet package to the Server project","title":"Installing SQLProvider from NuGet"},{"location":"recipes/storage/use-sqlprovider-ssdt/#initialize-type-provider","text":"Next, we will wire up our type provider to generate database types based on the compiled .dacpac file. 1) In the Server project, create a new file, Database.fs . (this should be above Server.fs ). module Database open FSharp.Data.Sql [< Literal >] let SsdtPath = __ SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Debug/SafeTodoDB.dacpac\" // TO RELOAD SCHEMA: 1) uncomment the line below; 2) save; 3) recomment; 4) save again and wait. //DB.GetDataContext().``Design Time Commands``.ClearDatabaseSchemaCache type DB = SqlDataProvider < Common . DatabaseProviderTypes . MSSQLSERVER_SSDT , SsdtPath = SsdtPath , UseOptionTypes = true > let createContext ( connectionString : string ) = DB . GetDataContext ( connectionString ) 2) Create TodoRepository.fs below Database.fs . module TodoRepository open FSharp.Data.Sql open Database open Shared /// Get all todos that have not been marked as \"done\". let getTodos ( db : DB . dataContext ) = query { for todo in db . Dbo . Todos do where ( not todo . IsDone ) select { Shared . Todo . Id = todo . Id Shared . Todo . Description = todo . Description } } |> List . executeQueryAsync let addTodo ( db : DB . dataContext ) ( todo : Shared . Todo ) = async { let t = db . Dbo . Todos . Create () t . Id <- todo . Id t . Description <- todo . Description t . IsDone <- false do ! db . SubmitUpdatesAsync () } 3) Create TodoController.fs below TodoRepository.fs . module TodoController open Database open Shared let getTodos ( db : DB . dataContext ) = TodoRepository . getTodos db let addTodo ( db : DB . dataContext ) ( todo : Todo ) = async { if Todo . isValid todo . Description then do ! TodoRepository . addTodo db todo return todo else return failwith \"Invalid todo\" } 4) Finally, replace the stubbed todosApi implementation in Server.fs with our type provided implementation. module Server open Fable.Remoting.Server open Fable.Remoting.Giraffe open Saturn open System open Shared open Microsoft.AspNetCore.Http let todosApi = let db = Database . createContext @\"Data Source=.\\SQLEXPRESS;Initial Catalog=SafeTodo;Integrated Security=SSPI;\" { getTodos = fun () -> TodoController . getTodos db addTodo = TodoController . addTodo db } let fableRemotingErrorHandler ( ex : Exception ) ( ri : RouteInfo < HttpContext >) = printfn \"ERROR: %s\" ex . Message Propagate ex . Message let webApp = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder |> Remoting . fromValue todosApi |> Remoting . withErrorHandler fableRemotingErrorHandler |> Remoting . buildHttpHandler let app = application { url \"http://0.0.0.0:8085\" use_router webApp memory_cache use_static \"public\" use_gzip } run app","title":"Initialize Type Provider"},{"location":"recipes/storage/use-sqlprovider-ssdt/#run-the-app","text":"From the VS Code terminal in the SafeTodo folder, launch the app (server and client): dotnet run You should now be able to add todos.","title":"Run the App!"},{"location":"recipes/storage/use-sqlprovider-ssdt/#deployment","text":"When creating a Release build for deployment, it is important to note that SQLProvider SSDT expects that the .dacpac file will be copied to the deployed Server project bin folder. Here are the steps to accomplish this: 1) Modify your Server.fsproj to include the .dacpac file with \"CopyToOutputDirectory\" to ensure that the .dacpac file will always exist in the Server project bin folder. <ItemGroup> <None Include=\"..\\{relative path to SSDT project}\\ssdt\\SafeTodo\\bin\\$(Configuration)\\SafeTodoDB.dacpac\" Link=\"SafeTodoDB.dacpac\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> </None> { other files... } </ItemGroup> 2) In your Server.Database.fs file, you should also modify the SsdtPath binding so that it can build the project in either Debug or Release mode: [< Literal >] # if DEBUG let SsdtPath = __ SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Debug/SafeTodoDB.dacpac\" # else let SsdtPath = __ SOURCE_DIRECTORY__ + @\"/../../ssdt/SafeTodoDB/bin/Release/SafeTodoDB.dacpac\" # endif NOTE: This assumes that your SSDT .sqlproj will be built in Release mode. (You can build it manually, or use a FAKE build script to handle this.)","title":"Deployment"},{"location":"recipes/ui/add-bulma/","text":"How do I add Bulma to a SAFE project? Bulma is a free open-source UI framework based on flex-box that helps you create modern and responsive layouts. When it comes to using Bulma as your front-end library on a SAFE Stack web application, you have two options. Feliz.Bulma : Feliz.Bulma is a Bulma wrapper for Feliz . Fulma : Fulma provides a wrapper around Bulma for fable-react. By adding either of these to your SAFE project alongside the Bulma stylesheet or the Bulma NPM package , you can take full advantage of Bulma. Using Feliz.Bulma Add the Feliz.Bulma Nuget package to the solution . Start using Feliz.Bulma components in your F# files. open Feliz.Bulma Bulma . button . button [ str \"Click me!\" ] Using Fulma Add the Fulma NuGet package to the solution . Start using Fulma components in your F# files. open Fulma Button . button [] [ str \"Click me!\" ]","title":"Add Bulma support"},{"location":"recipes/ui/add-bulma/#how-do-i-add-bulma-to-a-safe-project","text":"Bulma is a free open-source UI framework based on flex-box that helps you create modern and responsive layouts. When it comes to using Bulma as your front-end library on a SAFE Stack web application, you have two options. Feliz.Bulma : Feliz.Bulma is a Bulma wrapper for Feliz . Fulma : Fulma provides a wrapper around Bulma for fable-react. By adding either of these to your SAFE project alongside the Bulma stylesheet or the Bulma NPM package , you can take full advantage of Bulma.","title":"How do I add Bulma to a SAFE project?"},{"location":"recipes/ui/add-bulma/#using-felizbulma","text":"Add the Feliz.Bulma Nuget package to the solution . Start using Feliz.Bulma components in your F# files. open Feliz.Bulma Bulma . button . button [ str \"Click me!\" ]","title":"Using Feliz.Bulma"},{"location":"recipes/ui/add-bulma/#using-fulma","text":"Add the Fulma NuGet package to the solution . Start using Fulma components in your F# files. open Fulma Button . button [] [ str \"Click me!\" ]","title":"Using Fulma"},{"location":"recipes/ui/add-feliz/","text":"How do I add Feliz to a SAFE project? Feliz is a wrapper for the base React DSL library that emphasises consistency, lightweight formatting, discoverable attributes and full type-safety. The default SAFE Template already uses Feliz. Using Feliz Add Feliz to your project Start using Feliz in your code. open Feliz Html . button [ prop . style [ style . marginLeft 5 ] prop . onClick ( fun _ -> setCount ( count - 1 )) prop . text \"Decrement\" ]","title":"Add Feliz support"},{"location":"recipes/ui/add-feliz/#how-do-i-add-feliz-to-a-safe-project","text":"Feliz is a wrapper for the base React DSL library that emphasises consistency, lightweight formatting, discoverable attributes and full type-safety. The default SAFE Template already uses Feliz.","title":"How do I add Feliz to a SAFE project?"},{"location":"recipes/ui/add-feliz/#using-feliz","text":"Add Feliz to your project Start using Feliz in your code. open Feliz Html . button [ prop . style [ style . marginLeft 5 ] prop . onClick ( fun _ -> setCount ( count - 1 )) prop . text \"Decrement\" ]","title":"Using Feliz"},{"location":"recipes/ui/add-fontawesome/","text":"How Do I Use FontAwesome? FontAwesome is the most popular icon set out there and will provide you with a handful of free icons as well as a multitude of premium icons. The standard SAFE template has out-of-the-box support for FontAwesome. You can just start using it in your Client code like so: open Feliz Html . i [ prop . className \"fas fa-star\" ] This will display a solid star icon. I am Using the Minimal Template If you\u2019re using the minimal template, there are a couple of things to do before you can start using FontAwesome. If you don't need the full features of Feliz we suggest using Fable.FontAwesome.Free . 1. The NuGet Package Add Fable.FontAwesome.Free NuGet Package to the Client project. See How do I add a Nuget package to the Client? . 2. The CDN Link Open the index.html file and add the following line to the head element: < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css\" > 3. Code snippet open Fable.FontAwesome Icon . icon [ Fa . i [ Fa . Solid . Star ] [ ] ] All Done! Now you can use FontAwesome in your code","title":"Add FontAwesome support"},{"location":"recipes/ui/add-fontawesome/#how-do-i-use-fontawesome","text":"FontAwesome is the most popular icon set out there and will provide you with a handful of free icons as well as a multitude of premium icons. The standard SAFE template has out-of-the-box support for FontAwesome. You can just start using it in your Client code like so: open Feliz Html . i [ prop . className \"fas fa-star\" ] This will display a solid star icon.","title":"How Do I Use FontAwesome?"},{"location":"recipes/ui/add-fontawesome/#i-am-using-the-minimal-template","text":"If you\u2019re using the minimal template, there are a couple of things to do before you can start using FontAwesome. If you don't need the full features of Feliz we suggest using Fable.FontAwesome.Free .","title":"I am Using the Minimal Template"},{"location":"recipes/ui/add-fontawesome/#1-the-nuget-package","text":"Add Fable.FontAwesome.Free NuGet Package to the Client project. See How do I add a Nuget package to the Client? .","title":"1. The NuGet Package"},{"location":"recipes/ui/add-fontawesome/#2-the-cdn-link","text":"Open the index.html file and add the following line to the head element: < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css\" >","title":"2. The CDN Link"},{"location":"recipes/ui/add-fontawesome/#3-code-snippet","text":"open Fable.FontAwesome Icon . icon [ Fa . i [ Fa . Solid . Star ] [ ] ]","title":"3. Code snippet"},{"location":"recipes/ui/add-fontawesome/#all-done","text":"Now you can use FontAwesome in your code","title":"All Done!"},{"location":"recipes/ui/add-style/","text":"How Do I Use stylesheets with SAFE? If you wish to use your own CSS or SASS stylesheets with SAFE apps, you can embed either through webpack. The template already includes all required NPM packages you may need, so you will only need to configure webpack to reference your stylesheet and include in the outputs. Adding the Stylesheet First, create a CSS file in the src/Client folder of your solution e.g style.css . The same approach can be taken for .scss files. Configuring WebPack I'm using the Standard Template 1. Link to the stylesheet Inside the webpack.config.js file, add the following variable to the CONFIG object, which points to the style file you created previously. cssEntry : './src/Client/style.css' , 2. Embed CSS into outputs Find the entry field in the module.exports object at the bottom of the file, and replace it with the following: entry : isProduction ? { app : [ resolve ( CONFIG . fsharpEntry ), resolve ( CONFIG . cssEntry )] } : { app : resolve ( CONFIG . fsharpEntry ), style : resolve ( CONFIG . cssEntry ) }, This combines the css and F# outputs into a single bundle for production, and separately for dev. I'm using the Minimal Template 1. Embed CSS into outputs Find the entry field in the module.exports object at the bottom of the file, and replace it with the following: entry : { app : [ resolve ( './src/Client/Client.fsproj' ), resolve ( './src/Client/style.css' ) ] }, There you have it! You can now style your app by writing to the style.css file.","title":"Add Stylesheet support"},{"location":"recipes/ui/add-style/#how-do-i-use-stylesheets-with-safe","text":"If you wish to use your own CSS or SASS stylesheets with SAFE apps, you can embed either through webpack. The template already includes all required NPM packages you may need, so you will only need to configure webpack to reference your stylesheet and include in the outputs.","title":"How Do I Use stylesheets with SAFE?"},{"location":"recipes/ui/add-style/#adding-the-stylesheet","text":"First, create a CSS file in the src/Client folder of your solution e.g style.css . The same approach can be taken for .scss files.","title":"Adding the Stylesheet"},{"location":"recipes/ui/add-style/#configuring-webpack","text":"","title":"Configuring WebPack"},{"location":"recipes/ui/add-style/#im-using-the-standard-template","text":"","title":"I'm using the Standard Template"},{"location":"recipes/ui/add-style/#1-link-to-the-stylesheet","text":"Inside the webpack.config.js file, add the following variable to the CONFIG object, which points to the style file you created previously. cssEntry : './src/Client/style.css' ,","title":"1. Link to the stylesheet"},{"location":"recipes/ui/add-style/#2-embed-css-into-outputs","text":"Find the entry field in the module.exports object at the bottom of the file, and replace it with the following: entry : isProduction ? { app : [ resolve ( CONFIG . fsharpEntry ), resolve ( CONFIG . cssEntry )] } : { app : resolve ( CONFIG . fsharpEntry ), style : resolve ( CONFIG . cssEntry ) }, This combines the css and F# outputs into a single bundle for production, and separately for dev.","title":"2. Embed CSS into outputs"},{"location":"recipes/ui/add-style/#im-using-the-minimal-template","text":"","title":"I'm using the Minimal Template"},{"location":"recipes/ui/add-style/#1-embed-css-into-outputs","text":"Find the entry field in the module.exports object at the bottom of the file, and replace it with the following: entry : { app : [ resolve ( './src/Client/Client.fsproj' ), resolve ( './src/Client/style.css' ) ] },","title":"1. Embed CSS into outputs"},{"location":"recipes/ui/add-style/#there-you-have-it","text":"You can now style your app by writing to the style.css file.","title":"There you have it!"},{"location":"recipes/ui/cdn-to-npm/","text":"How do I migrate from a CDN stylesheet to an NPM package? Though the SAFE template default for referencing a stylesheet is to use a CDN, it\u2019s quite reasonable to want to use an NPM package instead. One common case is that it enables you to further customise Bulma themes by overriding Sass variables. 1. Remove the CDN Reference Find the following line in src/Client/index.html and delete it before moving on: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\" > 2. Add the NPM Package Go ahead and add the Bulma NPM package to your project. See: How do I add an NPM package to the client? 3. Load the Stylesheets There are two ways for loading the stylesheets: Fable Interop A quick and easy way to reference this NPM package in an F# file is to insert the following couple of lines: open Fable.Core.JsInterop importAll \"bulma/bulma.sass\" You can use this approach for any NPM package. b. Using Sass Add a Sass stylesheet to your project using this recipe . Add the following line to your Sass file to bring in Bulma @import \"~bulma/bulma.sass\"","title":"Migrate from a CDN stylesheet to an NPM package"},{"location":"recipes/ui/cdn-to-npm/#how-do-i-migrate-from-a-cdn-stylesheet-to-an-npm-package","text":"Though the SAFE template default for referencing a stylesheet is to use a CDN, it\u2019s quite reasonable to want to use an NPM package instead. One common case is that it enables you to further customise Bulma themes by overriding Sass variables.","title":"How do I migrate from a CDN stylesheet to an NPM package?"},{"location":"recipes/ui/cdn-to-npm/#1-remove-the-cdn-reference","text":"Find the following line in src/Client/index.html and delete it before moving on: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\" >","title":"1. Remove the CDN Reference"},{"location":"recipes/ui/cdn-to-npm/#2-add-the-npm-package","text":"Go ahead and add the Bulma NPM package to your project. See: How do I add an NPM package to the client?","title":"2. Add the NPM Package"},{"location":"recipes/ui/cdn-to-npm/#3-load-the-stylesheets","text":"There are two ways for loading the stylesheets:","title":"3. Load the Stylesheets"},{"location":"recipes/ui/cdn-to-npm/#fable-interop","text":"A quick and easy way to reference this NPM package in an F# file is to insert the following couple of lines: open Fable.Core.JsInterop importAll \"bulma/bulma.sass\" You can use this approach for any NPM package.","title":"Fable Interop"},{"location":"recipes/ui/cdn-to-npm/#b-using-sass","text":"Add a Sass stylesheet to your project using this recipe . Add the following line to your Sass file to bring in Bulma @import \"~bulma/bulma.sass\"","title":"b. Using Sass"},{"location":"recipes/ui/use-different-bulma-themes/","text":"How Do I Use Different Bulma Themes? Bulmaswatch Bulmaswatch is a great website for finding free Bulma themes. However, once you decide on what theme to use, visit this website to get a CDN link to its CSS file. For this recipe, I will use the Nuclear theme . I am Using the Standard Template The standard template uses a CDN (Content Delivery Network) link to reference the Bulma theme that it uses. Changing the theme then, is as simple as changing this link. Since the class names Bulma uses to style HTML elements remain the same, we don\u2019t need to change anything else. 1. Find the Link In your index.html , find the line that references the Bulma stylesheet that\u2019s used in the template through a CDN link. It will look like the following: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\" > 2. Change the Link Go ahead and replace this link with the link to the theme that you want to use, which in my case is Nuclear: < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/bulmaswatch/0.8.1/nuclear/bulmaswatch.min.css\" > I am Using the Minimal Template 1. Add Link to CDN In your index.html , add the following line anywhere between the opening and closing head tags: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\" > 2. Add Fulma or Feliz.Bulma to the Solution Read this recipe for the rest of the instructions. And that\u2019s it. You should now see your app styled in accordance with the Bulma theme you\u2019ve just switched to.","title":"Use different Bulma Themes"},{"location":"recipes/ui/use-different-bulma-themes/#how-do-i-use-different-bulma-themes","text":"","title":"How Do I Use Different Bulma Themes?"},{"location":"recipes/ui/use-different-bulma-themes/#bulmaswatch","text":"Bulmaswatch is a great website for finding free Bulma themes. However, once you decide on what theme to use, visit this website to get a CDN link to its CSS file. For this recipe, I will use the Nuclear theme .","title":"Bulmaswatch"},{"location":"recipes/ui/use-different-bulma-themes/#i-am-using-the-standard-template","text":"The standard template uses a CDN (Content Delivery Network) link to reference the Bulma theme that it uses. Changing the theme then, is as simple as changing this link. Since the class names Bulma uses to style HTML elements remain the same, we don\u2019t need to change anything else.","title":"I am Using the Standard Template"},{"location":"recipes/ui/use-different-bulma-themes/#1-find-the-link","text":"In your index.html , find the line that references the Bulma stylesheet that\u2019s used in the template through a CDN link. It will look like the following: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\" >","title":"1. Find the Link"},{"location":"recipes/ui/use-different-bulma-themes/#2-change-the-link","text":"Go ahead and replace this link with the link to the theme that you want to use, which in my case is Nuclear: < link rel = \"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/bulmaswatch/0.8.1/nuclear/bulmaswatch.min.css\" >","title":"2. Change the Link"},{"location":"recipes/ui/use-different-bulma-themes/#i-am-using-the-minimal-template","text":"","title":"I am Using the Minimal Template"},{"location":"recipes/ui/use-different-bulma-themes/#1-add-link-to-cdn","text":"In your index.html , add the following line anywhere between the opening and closing head tags: < link rel = \"stylesheet\" href = \"https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css\" >","title":"1. Add Link to CDN"},{"location":"recipes/ui/use-different-bulma-themes/#2-add-fulma-or-felizbulma-to-the-solution","text":"Read this recipe for the rest of the instructions. And that\u2019s it. You should now see your app styled in accordance with the Bulma theme you\u2019ve just switched to.","title":"2. Add Fulma or Feliz.Bulma to the Solution"},{"location":"recipes/upgrading/v2-to-v3/","text":"How do I upgrade from SAFE v2 to v3? There have been a number of changes between the second and third major versions of the SAFE template. This guide shows you how to upgrade your v2 project to v3. If you haven't done so already then you will need to install the prequisites listed in the Quick Start guide. Terminology for this Recipe: \"Overwrite\" : Take the file from the \"new\" V3 template and copy it over the equivalent file in your existing project. \"Delete\" : Delete the file from your existing project. It is no longer required. \"Add\" : Add the file to your existing project. It is a new file added in V3. 1. Install the v3 template Download and install the latest SAFE Stack V3 template by running the following command: dotnet new -i SAFE.Template 2. Create a v3 project Create a new SAFE project in the safetemp folder. We will use this as a basis for our conversion. dotnet new SAFE - o safetemp 3. Branch your code We advise committing or stashing any unsaved changes to your code and making a new branch to perform the upgrade. You can then test it in isolation and then safely merge back in. 4. Update dotnet tools This file lists any custom dotnet tools used. Overwrite the .config/dotnet-tools.json file. Important ! If you have installed extra dotnet tools, you will need to add them back in manually. 5. Update global.json Overwrite the global.json file 6. Update Paket dependencies Overwrite the paket.dependencies file in the root of the solution. Overwrite the paket.lock file. Overwrite all paket.references files. Important If you have installed extra NuGet packages, you will need to add them back in manually to the dependencies and references files. Run paket to update project references: dotnet paket install If you have added any extra NuGet packages, this command will also generate a new paket.lock file. 7. Update the npm dependancies Overwite the package.json file Overwite the package-lock.json file Important If you have installed extra npm packages, you will need to add them back in manually to the dependencies. 8. Update .gitignore Overwite the .gitignore file in the root of the solution 9. Update the build process Delete the build.fsx FAKE script. Add the Build.fs file Add the Helpers.fs file Add the Build.fsproj project Important If you have made any modifications to the build script e.g. extra targets, you will need to add them back in manually. 10. Update the webpack config Overwrite the webpack.config.js file. Overwrite the webpack.tests.config.js file Important If you have made any modifications to the webpack file, you will need to apply them back in manually. If you were using a CSS files, make sure to follow the Stylesheet recipe to add them back in. 11. Update TargetFramework in all projects Overwite the Client.fsproj Overwite the Server.fsproj Overwite the Shared.fsproj 12. Check that it runs Run dotnet run at the root of the solution to launch the app and check everything is working as expected. If you have problems loading your website, carefully check that you haven't missed out any javascript or nuget packages when overwriting the paket and package files. The console output will usually give you a good guide if this is the case.","title":"Upgrade from V2 to V3"},{"location":"recipes/upgrading/v2-to-v3/#how-do-i-upgrade-from-safe-v2-to-v3","text":"There have been a number of changes between the second and third major versions of the SAFE template. This guide shows you how to upgrade your v2 project to v3. If you haven't done so already then you will need to install the prequisites listed in the Quick Start guide.","title":"How do I upgrade from SAFE v2 to v3?"},{"location":"recipes/upgrading/v2-to-v3/#terminology-for-this-recipe","text":"\"Overwrite\" : Take the file from the \"new\" V3 template and copy it over the equivalent file in your existing project. \"Delete\" : Delete the file from your existing project. It is no longer required. \"Add\" : Add the file to your existing project. It is a new file added in V3.","title":"Terminology for this Recipe:"},{"location":"recipes/upgrading/v2-to-v3/#1-install-the-v3-template","text":"Download and install the latest SAFE Stack V3 template by running the following command: dotnet new -i SAFE.Template","title":"1. Install the v3 template"},{"location":"recipes/upgrading/v2-to-v3/#2-create-a-v3-project","text":"Create a new SAFE project in the safetemp folder. We will use this as a basis for our conversion. dotnet new SAFE - o safetemp","title":"2. Create a v3 project"},{"location":"recipes/upgrading/v2-to-v3/#3-branch-your-code","text":"We advise committing or stashing any unsaved changes to your code and making a new branch to perform the upgrade. You can then test it in isolation and then safely merge back in.","title":"3. Branch your code"},{"location":"recipes/upgrading/v2-to-v3/#4-update-dotnet-tools","text":"This file lists any custom dotnet tools used. Overwrite the .config/dotnet-tools.json file. Important ! If you have installed extra dotnet tools, you will need to add them back in manually.","title":"4. Update dotnet tools"},{"location":"recipes/upgrading/v2-to-v3/#5-update-globaljson","text":"Overwrite the global.json file","title":"5. Update global.json"},{"location":"recipes/upgrading/v2-to-v3/#6-update-paket-dependencies","text":"Overwrite the paket.dependencies file in the root of the solution. Overwrite the paket.lock file. Overwrite all paket.references files. Important If you have installed extra NuGet packages, you will need to add them back in manually to the dependencies and references files. Run paket to update project references: dotnet paket install If you have added any extra NuGet packages, this command will also generate a new paket.lock file.","title":"6. Update Paket dependencies"},{"location":"recipes/upgrading/v2-to-v3/#7-update-the-npm-dependancies","text":"Overwite the package.json file Overwite the package-lock.json file Important If you have installed extra npm packages, you will need to add them back in manually to the dependencies.","title":"7. Update the npm dependancies"},{"location":"recipes/upgrading/v2-to-v3/#8-update-gitignore","text":"Overwite the .gitignore file in the root of the solution","title":"8. Update .gitignore"},{"location":"recipes/upgrading/v2-to-v3/#9-update-the-build-process","text":"Delete the build.fsx FAKE script. Add the Build.fs file Add the Helpers.fs file Add the Build.fsproj project Important If you have made any modifications to the build script e.g. extra targets, you will need to add them back in manually.","title":"9. Update the build process"},{"location":"recipes/upgrading/v2-to-v3/#10-update-the-webpack-config","text":"Overwrite the webpack.config.js file. Overwrite the webpack.tests.config.js file Important If you have made any modifications to the webpack file, you will need to apply them back in manually. If you were using a CSS files, make sure to follow the Stylesheet recipe to add them back in.","title":"10. Update the webpack config"},{"location":"recipes/upgrading/v2-to-v3/#11-update-targetframework-in-all-projects","text":"Overwite the Client.fsproj Overwite the Server.fsproj Overwite the Shared.fsproj","title":"11. Update TargetFramework in all projects"},{"location":"recipes/upgrading/v2-to-v3/#12-check-that-it-runs","text":"Run dotnet run at the root of the solution to launch the app and check everything is working as expected. If you have problems loading your website, carefully check that you haven't missed out any javascript or nuget packages when overwriting the paket and package files. The console output will usually give you a good guide if this is the case.","title":"12. Check that it runs"},{"location":"v2-recipes/build/add-build-script/","text":"How do I add a build script to the project? FAKE Fake is a DSL for build tasks that is modular, extensible and easy to start with. Fake allows you to easily build, bundle, deploy your app and more by executing a single command. The standard template comes with a FAKE script by default, and this recipe only applies to the minimal template . Paket Before moving on, we recommend migrating to Paket . In fact, this is a prerequisite for this recipe . It is possible to use FAKE without Paket by creating an executable instead of a script file, however this will not be covered in this recipe. If you\u2019re not using Paket to handle your dependencies, go through the Migrate to Paket recipe before continuing. 1. The Build Dependencies Paste the following at the end of your paket.dependencies file, which is at the root of the solution. group Build source https://api.nuget.org/v3/index.json framework: netstandard2.0 storage: none nuget FSharp.Core nuget Fake.Core.Target nuget Fake.DotNet.Cli nuget Fake.IO.FileSystem Then, execute paket install to install these dependencies. 2. Fake CLI Tool Run the following commands at the root folder of your solution to install FAKE as a local tool: dotnet tool install fake-cli dotnet tool restore 3. The Build Script Add an F# script file to the root folder of your solution named build.fsx and paste the following code into it. The script builds and publishes the client and server applications in their production / release modes, and copies the outputs of both into a deploy folder at the root of the repository. To learn more about targets and FAKE in general, see Getting Started with FAKE . # r \"paket: groupref build //\" # load \"./.fake/build.fsx/intellisense.fsx\" # r \"netstandard\" open Fake.Core open Fake.Core.TargetOperators open Fake.DotNet open Fake.IO Target . initEnvironment () let serverPath = Path . getFullName \"./src/Server\" let clientPath = Path . getFullName \"./src/Client\" let deployDir = Path . getFullName \"./deploy\" let npm args workingDir = let npmPath = ProcessUtils . tryFindFileOnPath \"npm\" |> Option . get let arguments = args |> String . split ' ' |> Arguments . OfArgs Command . RawCommand ( npmPath , arguments ) |> CreateProcess . fromCommand |> CreateProcess . withWorkingDirectory workingDir |> CreateProcess . ensureExitCode |> Proc . run |> ignore let dotnet cmd workingDir = DotNet . exec ( DotNet . Options . withWorkingDirectory workingDir ) cmd \"\" Target . create \"Bundle\" ( fun _ -> Shell . cleanDir deployDir npm \"install\" clientPath dotnet ( sprintf \"publish -c Release -o \\\" %s \\\" \" deployDir ) serverPath npm \"run build\" clientPath ) \"Clean\" ==> \"InstallClient\" ==> \"Bundle\" Target . runOrDefaultWithArguments \"Bundle\" 4. Build the Application You can now build your application by running the following command at the root directory of your solution: dotnet fake build","title":"Add build automation"},{"location":"v2-recipes/build/add-build-script/#how-do-i-add-a-build-script-to-the-project","text":"","title":"How do I add a build script to the project?"},{"location":"v2-recipes/build/add-build-script/#fake","text":"Fake is a DSL for build tasks that is modular, extensible and easy to start with. Fake allows you to easily build, bundle, deploy your app and more by executing a single command. The standard template comes with a FAKE script by default, and this recipe only applies to the minimal template .","title":"FAKE"},{"location":"v2-recipes/build/add-build-script/#paket","text":"Before moving on, we recommend migrating to Paket . In fact, this is a prerequisite for this recipe . It is possible to use FAKE without Paket by creating an executable instead of a script file, however this will not be covered in this recipe. If you\u2019re not using Paket to handle your dependencies, go through the Migrate to Paket recipe before continuing.","title":"Paket"},{"location":"v2-recipes/build/add-build-script/#1-the-build-dependencies","text":"Paste the following at the end of your paket.dependencies file, which is at the root of the solution. group Build source https://api.nuget.org/v3/index.json framework: netstandard2.0 storage: none nuget FSharp.Core nuget Fake.Core.Target nuget Fake.DotNet.Cli nuget Fake.IO.FileSystem Then, execute paket install to install these dependencies.","title":"1. The Build Dependencies"},{"location":"v2-recipes/build/add-build-script/#2-fake-cli-tool","text":"Run the following commands at the root folder of your solution to install FAKE as a local tool: dotnet tool install fake-cli dotnet tool restore","title":"2. Fake CLI Tool"},{"location":"v2-recipes/build/add-build-script/#3-the-build-script","text":"Add an F# script file to the root folder of your solution named build.fsx and paste the following code into it. The script builds and publishes the client and server applications in their production / release modes, and copies the outputs of both into a deploy folder at the root of the repository. To learn more about targets and FAKE in general, see Getting Started with FAKE . # r \"paket: groupref build //\" # load \"./.fake/build.fsx/intellisense.fsx\" # r \"netstandard\" open Fake.Core open Fake.Core.TargetOperators open Fake.DotNet open Fake.IO Target . initEnvironment () let serverPath = Path . getFullName \"./src/Server\" let clientPath = Path . getFullName \"./src/Client\" let deployDir = Path . getFullName \"./deploy\" let npm args workingDir = let npmPath = ProcessUtils . tryFindFileOnPath \"npm\" |> Option . get let arguments = args |> String . split ' ' |> Arguments . OfArgs Command . RawCommand ( npmPath , arguments ) |> CreateProcess . fromCommand |> CreateProcess . withWorkingDirectory workingDir |> CreateProcess . ensureExitCode |> Proc . run |> ignore let dotnet cmd workingDir = DotNet . exec ( DotNet . Options . withWorkingDirectory workingDir ) cmd \"\" Target . create \"Bundle\" ( fun _ -> Shell . cleanDir deployDir npm \"install\" clientPath dotnet ( sprintf \"publish -c Release -o \\\" %s \\\" \" deployDir ) serverPath npm \"run build\" clientPath ) \"Clean\" ==> \"InstallClient\" ==> \"Bundle\" Target . runOrDefaultWithArguments \"Bundle\"","title":"3. The Build Script"},{"location":"v2-recipes/build/add-build-script/#4-build-the-application","text":"You can now build your application by running the following command at the root directory of your solution: dotnet fake build","title":"4. Build the Application"},{"location":"v2-recipes/build/bundle-app/","text":"How do I bundle my SAFE application? When developing your SAFE application, the local runtime experience uses WebPack to run the client and redirect API calls to the server on a different port . However, when you deploy your application, you'll need to run your Saturn server which will serve up statically-built client resources (HTML, JavaScript, CSS etc.). I'm using the standard template 1. Run the FAKE script If you created your SAFE app using the recommended defaults, your application already has a FAKE script which will do the bundling for you. You can create a bundle using the following command: dotnet fake build This will build and package up both the client and server and place them into the /deploy folder at the root of the repository. See here for more details on this build target. I'm using the minimal template If you created your SAFE app using the minimal option, you need to bundle up the client and server separately. 1. Bundle the Client (Fable) application Execute the following commands: npm run build This will build the client project and copy all outputs into /deploy/public . The run build command run webpack using the Production config, and the webpack.config.js file specifies its output as /deploy/public . 2. Bundle the Server (Saturn) application Execute the following commands: cd src/Server dotnet publish -c release -o ../../deploy This will bundle the server project and copy all outputs into the deploy folder. Testing the bundle Navigate to the deploy folder at the root of your repository. Run the Server.exe application. Navigate in your browser to http://localhost:8085 . You should now see your SAFE application. Further reading See this article for more information on architectural concerns regarding the move from dev to production and bundling SAFE Stack applications.","title":"Package my SAFE app for deployment"},{"location":"v2-recipes/build/bundle-app/#how-do-i-bundle-my-safe-application","text":"When developing your SAFE application, the local runtime experience uses WebPack to run the client and redirect API calls to the server on a different port . However, when you deploy your application, you'll need to run your Saturn server which will serve up statically-built client resources (HTML, JavaScript, CSS etc.).","title":"How do I bundle my SAFE application?"},{"location":"v2-recipes/build/bundle-app/#im-using-the-standard-template","text":"","title":"I'm using the standard template"},{"location":"v2-recipes/build/bundle-app/#1-run-the-fake-script","text":"If you created your SAFE app using the recommended defaults, your application already has a FAKE script which will do the bundling for you. You can create a bundle using the following command: dotnet fake build This will build and package up both the client and server and place them into the /deploy folder at the root of the repository. See here for more details on this build target.","title":"1. Run the FAKE script"},{"location":"v2-recipes/build/bundle-app/#im-using-the-minimal-template","text":"If you created your SAFE app using the minimal option, you need to bundle up the client and server separately.","title":"I'm using the minimal template"},{"location":"v2-recipes/build/bundle-app/#1-bundle-the-client-fable-application","text":"Execute the following commands: npm run build This will build the client project and copy all outputs into /deploy/public . The run build command run webpack using the Production config, and the webpack.config.js file specifies its output as /deploy/public .","title":"1. Bundle the Client (Fable) application"},{"location":"v2-recipes/build/bundle-app/#2-bundle-the-server-saturn-application","text":"Execute the following commands: cd src/Server dotnet publish -c release -o ../../deploy This will bundle the server project and copy all outputs into the deploy folder.","title":"2. Bundle the Server (Saturn) application"},{"location":"v2-recipes/build/bundle-app/#testing-the-bundle","text":"Navigate to the deploy folder at the root of your repository. Run the Server.exe application. Navigate in your browser to http://localhost:8085 . You should now see your SAFE application.","title":"Testing the bundle"},{"location":"v2-recipes/build/bundle-app/#further-reading","text":"See this article for more information on architectural concerns regarding the move from dev to production and bundling SAFE Stack applications.","title":"Further reading"},{"location":"v2-recipes/build/docker-image/","text":"How do I build with docker? Using Docker makes it possible to deploy your application as a docker container or release an image on docker hub. This recipe walks you through creating a Dockerfile and automating the build and test process with Docker Hub . 1. Create a .dockerignore file Create a .dockerignore file with the same contents as .gitignore Linux cp .gitignore .dockerignore Windows copy .gitignore .dockerignore Now, add the following lines to the .dockerignore file: .git 2. Create the dockerfile Create a Dockerfile with the following contents: FROM mcr.microsoft.com/dotnet/core/sdk:3.1 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY . . RUN dotnet tool restore RUN dotnet fake build -t Bundle FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine COPY --from = build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ] This uses multistage builds to keep the final image small. Using the minimal template? If you created your SAFE app using the minimal option, a FAKE script is not included by default so you need to bundle up the client and server separately. Replace the line RUN dotnet fake build -t Bundle with RUN npm run build RUN cd src/Server && dotnet publish -c release -o ../../deploy 3. Building and running with docker locally Build the image docker build -t my-safe-app . Run the container docker run -it -p 8085:8085 my-safe-app Because the build is done entirely in docker, Docker Hub automated builds can be setup to automatically build and push the docker image. 4. Testing the server Create a docker-compose.server.test.yml file with the following contents: sut: build: context: . target: build command: cd tests/Server && dotnet run If you added tests to the minimal template according to the testing the server recipe, change the command to cd src/Server.Tests && dotnet run Docker Hub can also run automated tests for you. The template is not currently setup for automating the client tests. Follow the instructions to enable Autotest on docker hub. 5. Making the docker build faster Not recommended for most applications If you often build with docker locally, you may wish to make the build faster by optimising the Dockerfile for caching. For example, it is not necessary to download all paket and npm dependencies on every build unless there have been changes to the dependencies. Furthermore, the client and server can be built in separate build stages so that they are cached independently. Enable Docker BuildKit to build them concurrently. This comes at the expense of making the dockerfile more complex; if any changes are made to the build such as adding new projects or migrating package managers, the dockerfile must be updated accordingly. The following should be a good starting point but is not guarenteed to work. FROM mcr.microsoft.com/dotnet/core/sdk:3.1 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY .config .config RUN dotnet tool restore COPY .paket .paket COPY paket.dependencies paket.lock ./ RUN dotnet paket restore FROM build as server-build COPY src/Shared src/Shared COPY src/Server src/Server RUN cd src/Server && dotnet publish -c release -o ../../deploy FROM build as client-build COPY package.json package-lock.json ./ RUN npm install COPY webpack.config.js ./ COPY src/Shared src/Shared COPY src/Client src/Client RUN npm run build FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine COPY --from = server-build /workspace/deploy /app COPY --from = client-build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ]","title":"Create a docker image"},{"location":"v2-recipes/build/docker-image/#how-do-i-build-with-docker","text":"Using Docker makes it possible to deploy your application as a docker container or release an image on docker hub. This recipe walks you through creating a Dockerfile and automating the build and test process with Docker Hub .","title":"How do I build with docker?"},{"location":"v2-recipes/build/docker-image/#1-create-a-dockerignore-file","text":"Create a .dockerignore file with the same contents as .gitignore","title":"1. Create a .dockerignore file"},{"location":"v2-recipes/build/docker-image/#linux","text":"cp .gitignore .dockerignore","title":"Linux"},{"location":"v2-recipes/build/docker-image/#windows","text":"copy .gitignore .dockerignore Now, add the following lines to the .dockerignore file: .git","title":"Windows"},{"location":"v2-recipes/build/docker-image/#2-create-the-dockerfile","text":"Create a Dockerfile with the following contents: FROM mcr.microsoft.com/dotnet/core/sdk:3.1 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY . . RUN dotnet tool restore RUN dotnet fake build -t Bundle FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine COPY --from = build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ] This uses multistage builds to keep the final image small.","title":"2. Create the dockerfile"},{"location":"v2-recipes/build/docker-image/#using-the-minimal-template","text":"If you created your SAFE app using the minimal option, a FAKE script is not included by default so you need to bundle up the client and server separately. Replace the line RUN dotnet fake build -t Bundle with RUN npm run build RUN cd src/Server && dotnet publish -c release -o ../../deploy","title":"Using the minimal template?"},{"location":"v2-recipes/build/docker-image/#3-building-and-running-with-docker-locally","text":"Build the image docker build -t my-safe-app . Run the container docker run -it -p 8085:8085 my-safe-app Because the build is done entirely in docker, Docker Hub automated builds can be setup to automatically build and push the docker image.","title":"3. Building and running with docker locally"},{"location":"v2-recipes/build/docker-image/#4-testing-the-server","text":"Create a docker-compose.server.test.yml file with the following contents: sut: build: context: . target: build command: cd tests/Server && dotnet run If you added tests to the minimal template according to the testing the server recipe, change the command to cd src/Server.Tests && dotnet run Docker Hub can also run automated tests for you. The template is not currently setup for automating the client tests. Follow the instructions to enable Autotest on docker hub.","title":"4. Testing the server"},{"location":"v2-recipes/build/docker-image/#5-making-the-docker-build-faster","text":"Not recommended for most applications If you often build with docker locally, you may wish to make the build faster by optimising the Dockerfile for caching. For example, it is not necessary to download all paket and npm dependencies on every build unless there have been changes to the dependencies. Furthermore, the client and server can be built in separate build stages so that they are cached independently. Enable Docker BuildKit to build them concurrently. This comes at the expense of making the dockerfile more complex; if any changes are made to the build such as adding new projects or migrating package managers, the dockerfile must be updated accordingly. The following should be a good starting point but is not guarenteed to work. FROM mcr.microsoft.com/dotnet/core/sdk:3.1 as build # Install node RUN curl -sL https://deb.nodesource.com/setup_14.x | bash RUN apt-get update && apt-get install -y nodejs WORKDIR /workspace COPY .config .config RUN dotnet tool restore COPY .paket .paket COPY paket.dependencies paket.lock ./ RUN dotnet paket restore FROM build as server-build COPY src/Shared src/Shared COPY src/Server src/Server RUN cd src/Server && dotnet publish -c release -o ../../deploy FROM build as client-build COPY package.json package-lock.json ./ RUN npm install COPY webpack.config.js ./ COPY src/Shared src/Shared COPY src/Client src/Client RUN npm run build FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine COPY --from = server-build /workspace/deploy /app COPY --from = client-build /workspace/deploy /app WORKDIR /app EXPOSE 8085 ENTRYPOINT [ \"dotnet\" , \"Server.dll\" ]","title":"5. Making the docker build faster"},{"location":"v2-recipes/build/remove-fake/","text":"How do I remove the use of FAKE? FAKE is a tool for build automation. The standard SAFE template comes with a ready-made build script at the root of the solution that provides support for many common SAFE tasks. If you would prefer not to use FAKE, you can of course simply ignore it, but this recipes shows how to completely remove it from your repository. It is important to note that having removed FAKE, you will have to follow a more manual approach to each of these processes. This recipe will only include instructions on how to build and deploy the application after removing FAKE. Note that the minimal template does not have FAKE installed by default, and this recipe only applies to the standard template . 1. Build Script Delete build.fsx at the root of the solution. 2. Dependencies Find the following block of code inside the paket.dependencies file that\u2019s also at the root of the solution and delete it. group Build source https : //api.nuget.org/v3/index.json framework : netstandard2 . 0 storage : none nuget FSharp . Core nuget Fake . Core . ReleaseNotes nuget Fake . Core . Target nuget Fake . DotNet . Cli nuget Fake . IO . FileSystem nuget Farmer 3. Paket Install Then, execute paket install in your terminal at the root of the solution. This will remove the dependencies whose names were included in the Build group. 4. Fake Tool The final step is to delete the FAKE tool. Execute the following command at the root of the solution to do this: dotnet tool uninstall fake-cli Running the App Now that you have FAKE removed, you will have to separately run the server and the client. 1. Start the Client Execute npm start inside a terminal at the root of the solution . 2. Start the Server Navigate to src/Server inside a terminal and execute dotnet run . The app will now be running at http://0.0.0.0:8080/ . Navigate to this address in a browser to see your app running. Bundling the App See this guide to learn how to package a SAFE application for deployment to e.g. Azure. You can now find the outcome of the bundling process in the deploy folder at the root of the solution.","title":"Remove FAKE from my project"},{"location":"v2-recipes/build/remove-fake/#how-do-i-remove-the-use-of-fake","text":"FAKE is a tool for build automation. The standard SAFE template comes with a ready-made build script at the root of the solution that provides support for many common SAFE tasks. If you would prefer not to use FAKE, you can of course simply ignore it, but this recipes shows how to completely remove it from your repository. It is important to note that having removed FAKE, you will have to follow a more manual approach to each of these processes. This recipe will only include instructions on how to build and deploy the application after removing FAKE. Note that the minimal template does not have FAKE installed by default, and this recipe only applies to the standard template .","title":"How do I remove the use of FAKE?"},{"location":"v2-recipes/build/remove-fake/#1-build-script","text":"Delete build.fsx at the root of the solution.","title":"1. Build Script"},{"location":"v2-recipes/build/remove-fake/#2-dependencies","text":"Find the following block of code inside the paket.dependencies file that\u2019s also at the root of the solution and delete it. group Build source https : //api.nuget.org/v3/index.json framework : netstandard2 . 0 storage : none nuget FSharp . Core nuget Fake . Core . ReleaseNotes nuget Fake . Core . Target nuget Fake . DotNet . Cli nuget Fake . IO . FileSystem nuget Farmer","title":"2. Dependencies"},{"location":"v2-recipes/build/remove-fake/#3-paket-install","text":"Then, execute paket install in your terminal at the root of the solution. This will remove the dependencies whose names were included in the Build group.","title":"3. Paket Install"},{"location":"v2-recipes/build/remove-fake/#4-fake-tool","text":"The final step is to delete the FAKE tool. Execute the following command at the root of the solution to do this: dotnet tool uninstall fake-cli","title":"4. Fake Tool"},{"location":"v2-recipes/build/remove-fake/#running-the-app","text":"Now that you have FAKE removed, you will have to separately run the server and the client.","title":"Running the App"},{"location":"v2-recipes/build/remove-fake/#1-start-the-client","text":"Execute npm start inside a terminal at the root of the solution .","title":"1. Start the Client"},{"location":"v2-recipes/build/remove-fake/#2-start-the-server","text":"Navigate to src/Server inside a terminal and execute dotnet run . The app will now be running at http://0.0.0.0:8080/ . Navigate to this address in a browser to see your app running.","title":"2. Start the Server"},{"location":"v2-recipes/build/remove-fake/#bundling-the-app","text":"See this guide to learn how to package a SAFE application for deployment to e.g. Azure. You can now find the outcome of the bundling process in the deploy folder at the root of the solution.","title":"Bundling the App"},{"location":"v2-recipes/build/support-older-browsers/","text":"How Do I Add Support for Older Browsers? What Is A Polyfill? Simply put, a polyfill is a block of code that implements a feature on web browsers that do not support that feature. All we need to use polyfills where necessary is to tell Babel and Fable to do so in our webpack config file. Note that the standard template uses polyfills by default, and this recipe only applies to the minimal template . 1. NPM Package First, add @babel/preset-env NPM package to the Client. You can find out more about this package here . Also, see: How Do I Add an NPM Package to the Client . 2. Configuration Object Add the following object to the webpack.config.js file. The useBuiltIns option configures how @babel/preset-env handles polyfills. You can find out more about this option here . var babelOptions = { presets : [ [ '@babel/preset-env' , { modules : false , useBuiltIns : 'usage' , corejs : 3 }] ], } 3. Fable Loader Make the following modifications to the fable-loader object, which you can find at the bottom of webpack.config inside the module field of the module.exports object: { test : /\\.fs(x|proj)?$/ , use : { loader : 'fable-loader' , // <- Add a comma here. options : { babel : babelOptions } // <- Add this line. } }, 4. Babel Loader Make the following modifications to the babel-loader object, which you can find right below fable-loader . { test : /\\.js$/ , exclude : /node_modules/ , use : { loader : 'babel-loader' , // <- Add a comma here. options : babelOptions // <- Add this line, } }, Done! Babel will now use polyfills only where necessary to both enable your code to be run on older browsers and achieve optimal performance when they are not needed.","title":"Support older browsers"},{"location":"v2-recipes/build/support-older-browsers/#how-do-i-add-support-for-older-browsers","text":"","title":"How Do I Add Support for Older Browsers?"},{"location":"v2-recipes/build/support-older-browsers/#what-is-a-polyfill","text":"Simply put, a polyfill is a block of code that implements a feature on web browsers that do not support that feature. All we need to use polyfills where necessary is to tell Babel and Fable to do so in our webpack config file. Note that the standard template uses polyfills by default, and this recipe only applies to the minimal template .","title":"What Is A Polyfill?"},{"location":"v2-recipes/build/support-older-browsers/#1-npm-package","text":"First, add @babel/preset-env NPM package to the Client. You can find out more about this package here . Also, see: How Do I Add an NPM Package to the Client .","title":"1. NPM Package"},{"location":"v2-recipes/build/support-older-browsers/#2-configuration-object","text":"Add the following object to the webpack.config.js file. The useBuiltIns option configures how @babel/preset-env handles polyfills. You can find out more about this option here . var babelOptions = { presets : [ [ '@babel/preset-env' , { modules : false , useBuiltIns : 'usage' , corejs : 3 }] ], }","title":"2. Configuration Object"},{"location":"v2-recipes/build/support-older-browsers/#3-fable-loader","text":"Make the following modifications to the fable-loader object, which you can find at the bottom of webpack.config inside the module field of the module.exports object: { test : /\\.fs(x|proj)?$/ , use : { loader : 'fable-loader' , // <- Add a comma here. options : { babel : babelOptions } // <- Add this line. } },","title":"3. Fable Loader"},{"location":"v2-recipes/build/support-older-browsers/#4-babel-loader","text":"Make the following modifications to the babel-loader object, which you can find right below fable-loader . { test : /\\.js$/ , exclude : /node_modules/ , use : { loader : 'babel-loader' , // <- Add a comma here. options : babelOptions // <- Add this line, } },","title":"4. Babel Loader"},{"location":"v2-recipes/build/support-older-browsers/#done","text":"Babel will now use polyfills only where necessary to both enable your code to be run on older browsers and achieve optimal performance when they are not needed.","title":"Done!"},{"location":"v2-recipes/client-server/fable-remoting/","text":"How Do I Add Support for Fable Remoting? Fable Remoting is a type-safe RPC communication layer for SAFE apps. It uses HTTP behind the scenes, but allows you to program against protocols that exist across the application without needing to think about the HTTP plumbing, and is a great fit for the majority of SAFE applications. Note that the standard template uses Fable Remoting. This recipe only applies to the minimal template . 1. Install NuGet Packages Add Fable.Remoting.Giraffe to the Server and Fable.Remoting.Client to the Client. See How Do I Add a NuGet Package to the Server and How Do I Add a NuGet Package to the Client . 2. Create the API protocol You now need to create the protocol, or contract, of the API we\u2019ll be creating. Insert the following below the Route module in Shared.fs : type IMyApi = { hello : unit -> Async < string > } 3. Create the routing function We need to provide a basic routing function in order to ensure client and server communicate on the same endpoint. Find the Route module in src/Shared/Shared.fs and replace it with the following: module Route = let builder typeName methodName = sprintf \"/api/%s/%s\" typeName methodName 4. Create the protocol implementation We now need to provide an implementation of the protocol on the server. Open src/Server/Server.fs and insert the following right after the open statements: let myApi = { hello = fun () -> async { return \"Hello from SAFE!\" } } 5. Hook into ASP.NET We now need to \"adapt\" Fable Remoting into the ASP.NET pipeline by converting it into a Giraffe HTTP Handler. Don't worry - this is not hard. Find webApp in Server.fs and replace it with the following: open Fable.Remoting.Server open Fable.Remoting.Giraffe let webApp = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder // use the routing function from step 3 |> Remoting . fromValue myApi // use the myApi implementation from step 4 |> Remoting . buildHttpHandler // adapt it to Giraffe's HTTP Handler 6. Create the Client proxy We now need a corresponding client proxy in order to be able to connect to the server. Open src/Client/Client.fs and insert the following right after the Msg type: open Fable.Remoting.Client let myApi = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder |> Remoting . buildProxy < IMyApi > 7. Make calls to the Server Replace the following two lines in the init function in Client.fs : let getHello () = Fetch . get < unit , string > Route . hello let cmd = Cmd . OfPromise . perform getHello () GotHello with this: let cmd = Cmd . OfAsync . perform myApi . hello () GotHello Done! At this point, the app should work just as it did before. Now, expanding the API and adding a new endpoint is as easy as adding a new field to the API protocol we defined in Shared.fs , editing the myApi record in Server.fs with the implementation, and finally making calls from the proxy.","title":"Add support for Fable Remoting"},{"location":"v2-recipes/client-server/fable-remoting/#how-do-i-add-support-for-fable-remoting","text":"Fable Remoting is a type-safe RPC communication layer for SAFE apps. It uses HTTP behind the scenes, but allows you to program against protocols that exist across the application without needing to think about the HTTP plumbing, and is a great fit for the majority of SAFE applications. Note that the standard template uses Fable Remoting. This recipe only applies to the minimal template .","title":"How Do I Add Support for Fable Remoting?"},{"location":"v2-recipes/client-server/fable-remoting/#1-install-nuget-packages","text":"Add Fable.Remoting.Giraffe to the Server and Fable.Remoting.Client to the Client. See How Do I Add a NuGet Package to the Server and How Do I Add a NuGet Package to the Client .","title":"1. Install NuGet Packages"},{"location":"v2-recipes/client-server/fable-remoting/#2-create-the-api-protocol","text":"You now need to create the protocol, or contract, of the API we\u2019ll be creating. Insert the following below the Route module in Shared.fs : type IMyApi = { hello : unit -> Async < string > }","title":"2. Create the API protocol"},{"location":"v2-recipes/client-server/fable-remoting/#3-create-the-routing-function","text":"We need to provide a basic routing function in order to ensure client and server communicate on the same endpoint. Find the Route module in src/Shared/Shared.fs and replace it with the following: module Route = let builder typeName methodName = sprintf \"/api/%s/%s\" typeName methodName","title":"3. Create the routing function"},{"location":"v2-recipes/client-server/fable-remoting/#4-create-the-protocol-implementation","text":"We now need to provide an implementation of the protocol on the server. Open src/Server/Server.fs and insert the following right after the open statements: let myApi = { hello = fun () -> async { return \"Hello from SAFE!\" } }","title":"4. Create the protocol implementation"},{"location":"v2-recipes/client-server/fable-remoting/#5-hook-into-aspnet","text":"We now need to \"adapt\" Fable Remoting into the ASP.NET pipeline by converting it into a Giraffe HTTP Handler. Don't worry - this is not hard. Find webApp in Server.fs and replace it with the following: open Fable.Remoting.Server open Fable.Remoting.Giraffe let webApp = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder // use the routing function from step 3 |> Remoting . fromValue myApi // use the myApi implementation from step 4 |> Remoting . buildHttpHandler // adapt it to Giraffe's HTTP Handler","title":"5. Hook into ASP.NET"},{"location":"v2-recipes/client-server/fable-remoting/#6-create-the-client-proxy","text":"We now need a corresponding client proxy in order to be able to connect to the server. Open src/Client/Client.fs and insert the following right after the Msg type: open Fable.Remoting.Client let myApi = Remoting . createApi () |> Remoting . withRouteBuilder Route . builder |> Remoting . buildProxy < IMyApi >","title":"6. Create the Client proxy"},{"location":"v2-recipes/client-server/fable-remoting/#7-make-calls-to-the-server","text":"Replace the following two lines in the init function in Client.fs : let getHello () = Fetch . get < unit , string > Route . hello let cmd = Cmd . OfPromise . perform getHello () GotHello with this: let cmd = Cmd . OfAsync . perform myApi . hello () GotHello","title":"7. Make calls to the Server"},{"location":"v2-recipes/client-server/fable-remoting/#done","text":"At this point, the app should work just as it did before. Now, expanding the API and adding a new endpoint is as easy as adding a new field to the API protocol we defined in Shared.fs , editing the myApi record in Server.fs with the implementation, and finally making calls from the proxy.","title":"Done!"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/","text":"How do I debug a SAFE app? I'm using Visual Studio In order to debug Server code from Visual Studio, we need set the correct URLs in the project's debug properties. Debugging the Server 1. Configure launch settings You can do this through the Server project's Properties/Debug editor or by editing the launchSettings.json file which is in the properties folder. After selecting the debug profile that you wish to edit ( IIS Express or Server ), you will need to set the App URL field to http://localhost:8085 and Launch browser field to http://localhost:8080 . The process is very similar for VS Mac. Once this is done, you can expect your launchSettings.json file to look something like this: { \"iisSettings\" : { \"windowsAuthentication\" : false , \"anonymousAuthentication\" : true , \"iisExpress\" : { \"applicationUrl\" : \"http://localhost:8085/\" , \"sslPort\" : 44330 } }, \"profiles\" : { \"IIS Express\" : { \"commandName\" : \"IISExpress\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080/\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } }, \"Server\" : { \"commandName\" : \"Project\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" }, \"applicationUrl\" : \"http://localhost:8085\" } } } 2. Start the Client Since you will be running the server directly through Visual Studio, you cannot use a FAKE script to start the application, so launch the client directly using e.g. npm run start . 3. Debug the Server Set the server as your Startup project, either using the drop-down menu at the top of the IDE or by right clicking on the project itself and selecting Set as Startup Project . Select the profile that you set up earlier and wish to launch from the drop-down at the top of the IDE. Either press the Play button at the top of the IDE or hit F5 on your keyboard to start the Server debugging and launch a browser pointing at the website. Debugging the Client Although we write our client-side code using F#, it is being converted into Javascript at runtime by Fable and executed in the browser. However, we can still debug it via the magic of source mapping. If you are using Visual Studio, you cannot directly connect to the browser debugger. You can, however, debug your client F# code using the browser's development tools. 1. Set breakpoints in Client code The exact instructions will depend on your browser, but essentially it simply involves: Opening the Developer tools panel (usually by hitting F12). Finding the F# file you want to add breakpoints to in the source of the website (look inside the webpack folder). Add breakpoints to it in your browser inspector. I'm using VS Code VS Code allows \"full stack\" debugging i.e. both F# on the client and server. Prerequisites that you should install: 0. Install Prerequisites Install either Google Chrome or Microsoft Edge : Enables client-side debugging. Configure your browser with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code. Debugger for Edge : Provides integrated client-side debugging in Code. 1. Create a launch.json file Open the Command Palette using Ctrl+Shift+P and run Debug: Open launch.json . This will ask you to choose a platform; select .NET Core . This will create a launch.json file in the root of your solution and also open it in the editor. 2. Add a Configuration Click the \"Add Configuration...\" button and choose Launch .NET Core Console Application . The only change required is to point it at the Server application, by replacing the program line with this: \"program\" : \"${workspaceFolder}/src/Server/bin/Debug/netcoreapp3.1/Server.dll\" , 3. Configure a build task From the Command Palette, choose Configure Task . Select Create tasks.json file from template . This will show you a list of pre-configured templates. Select .NET Core . 4. Debug the Server Either hit F5 or open the Debugging pane and press the Play button to build and launch the Server with the debugger attached. Observe that the Debug Console panel will show output from the server. The server is now running and you can set breakpoints and view the callstack etc. 5. Debug the Client Start the Client using e.g. npm run start . Open the Command Palette and run Debug: Open Link . When prompted for a url, type http://localhost:8080/ . This will launch a browser which is pointed at the URL and connect the debugger to it. You can now set breakpoints in your Client within VS Code. Select the appropriate Debug Console you wish to view. If you find that your breakpoints aren't being hit, try stopping the Client, disconnecting the debugger and re-launching them both. To find out more about the VS Code debugger, see here .","title":"Debug a SAFE app"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#how-do-i-debug-a-safe-app","text":"","title":"How do I debug a SAFE app?"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#im-using-visual-studio","text":"In order to debug Server code from Visual Studio, we need set the correct URLs in the project's debug properties.","title":"I'm using Visual Studio"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#debugging-the-server","text":"","title":"Debugging the Server"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#1-configure-launch-settings","text":"You can do this through the Server project's Properties/Debug editor or by editing the launchSettings.json file which is in the properties folder. After selecting the debug profile that you wish to edit ( IIS Express or Server ), you will need to set the App URL field to http://localhost:8085 and Launch browser field to http://localhost:8080 . The process is very similar for VS Mac. Once this is done, you can expect your launchSettings.json file to look something like this: { \"iisSettings\" : { \"windowsAuthentication\" : false , \"anonymousAuthentication\" : true , \"iisExpress\" : { \"applicationUrl\" : \"http://localhost:8085/\" , \"sslPort\" : 44330 } }, \"profiles\" : { \"IIS Express\" : { \"commandName\" : \"IISExpress\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080/\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" } }, \"Server\" : { \"commandName\" : \"Project\" , \"launchBrowser\" : true , \"launchUrl\" : \"http://localhost:8080\" , \"environmentVariables\" : { \"ASPNETCORE_ENVIRONMENT\" : \"Development\" }, \"applicationUrl\" : \"http://localhost:8085\" } } }","title":"1. Configure launch settings"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#2-start-the-client","text":"Since you will be running the server directly through Visual Studio, you cannot use a FAKE script to start the application, so launch the client directly using e.g. npm run start .","title":"2. Start the Client"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#3-debug-the-server","text":"Set the server as your Startup project, either using the drop-down menu at the top of the IDE or by right clicking on the project itself and selecting Set as Startup Project . Select the profile that you set up earlier and wish to launch from the drop-down at the top of the IDE. Either press the Play button at the top of the IDE or hit F5 on your keyboard to start the Server debugging and launch a browser pointing at the website.","title":"3. Debug the Server"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#debugging-the-client","text":"Although we write our client-side code using F#, it is being converted into Javascript at runtime by Fable and executed in the browser. However, we can still debug it via the magic of source mapping. If you are using Visual Studio, you cannot directly connect to the browser debugger. You can, however, debug your client F# code using the browser's development tools.","title":"Debugging the Client"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#1-set-breakpoints-in-client-code","text":"The exact instructions will depend on your browser, but essentially it simply involves: Opening the Developer tools panel (usually by hitting F12). Finding the F# file you want to add breakpoints to in the source of the website (look inside the webpack folder). Add breakpoints to it in your browser inspector.","title":"1. Set breakpoints in Client code"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#im-using-vs-code","text":"VS Code allows \"full stack\" debugging i.e. both F# on the client and server. Prerequisites that you should install:","title":"I'm using VS Code"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#0-install-prerequisites","text":"Install either Google Chrome or Microsoft Edge : Enables client-side debugging. Configure your browser with the following extensions: Redux Dev Tools : Provides improved debugging support in Chrome with Elmish and access to Redux debugging. React Developer Tools : Provides access to React debugging in Chrome. Configure VS Code with the following extensions: Ionide : Provides F# support to Code. C# : Provides .NET Core debugging support. Debugger for Chrome : Provides integrated client-side debugging in Code. Debugger for Edge : Provides integrated client-side debugging in Code.","title":"0. Install Prerequisites"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#1-create-a-launchjson-file","text":"Open the Command Palette using Ctrl+Shift+P and run Debug: Open launch.json . This will ask you to choose a platform; select .NET Core . This will create a launch.json file in the root of your solution and also open it in the editor.","title":"1. Create a launch.json file"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#2-add-a-configuration","text":"Click the \"Add Configuration...\" button and choose Launch .NET Core Console Application . The only change required is to point it at the Server application, by replacing the program line with this: \"program\" : \"${workspaceFolder}/src/Server/bin/Debug/netcoreapp3.1/Server.dll\" ,","title":"2. Add a Configuration"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#3-configure-a-build-task","text":"From the Command Palette, choose Configure Task . Select Create tasks.json file from template . This will show you a list of pre-configured templates. Select .NET Core .","title":"3. Configure a build task"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#4-debug-the-server","text":"Either hit F5 or open the Debugging pane and press the Play button to build and launch the Server with the debugger attached. Observe that the Debug Console panel will show output from the server. The server is now running and you can set breakpoints and view the callstack etc.","title":"4. Debug the Server"},{"location":"v2-recipes/developing-and-testing/debug-safe-app/#5-debug-the-client","text":"Start the Client using e.g. npm run start . Open the Command Palette and run Debug: Open Link . When prompted for a url, type http://localhost:8080/ . This will launch a browser which is pointed at the URL and connect the debugger to it. You can now set breakpoints in your Client within VS Code. Select the appropriate Debug Console you wish to view. If you find that your breakpoints aren't being hit, try stopping the Client, disconnecting the debugger and re-launching them both. To find out more about the VS Code debugger, see here .","title":"5. Debug the Client"},{"location":"v2-recipes/developing-and-testing/testing-the-client/","text":"How do I test the client? Testing on the client is a little different than on the server. This is because the code which is ultimately being executed in the browser is Javascript, translated from F# by Fable, and so it must be tested in a Javascript environment. Furthermore, code that is shared between the Client and Server must be tested in both a dotnet environment and a Javascript environment. The SAFE template uses a library called Fable.Mocha which allows us to run the same tests in both environments. It mirrors the Expecto API and works in much the same way. I'm using the standard template If you are using the standard template then there is nothing more you need to do in order to start testing your Client. You will find a folder in the solution named tests . Inside this there is a project, Client.Tests , which contains a single script demonstrating how to use Mocha to test the TODO sample. Note the compiler directive here which makes sure that the Shared tests are only included when executing in a Javascript (Fable) context. They are covered by Expecto under dotnet as you can see in Server.Tests.fs . 1. Launch the test server In order to run the tests, instead of starting your application using dotnet fake build -t run you should instead use dotnet fake build -t runtests 2. View the results Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this: This command builds and runs the Server test project too. If you want to run the Client tests alone, you can simply launch the test server using npm run test:live , which executes a command stored in package.json . I'm using the minimal template If you are using the minimal template, you will need to first configure a test project as none are included. 1. Add a test project In the src folder, create a create a .Net Standard library called Client.Tests . cd src dotnet new ClassLib -lang F # -o Client.Tests cd .. dotnet sln add src / Client . Tests 2. Reference the Client project Reference the Client project from the Client.Tests project: dotnet add Client . Tests reference Client 3. Add the Fable.Mocha package to Test project Run the following command: dotnet add Client . Tests package Fable . Mocha 4. Add a test Delete the Library.fs file and replace it with a new file called Tests.fs to your test project. Add the following code to it: module Tests open Fable.Mocha open Index let client = testList \"Client\" [ testCase \"Hello received\" <| fun _ -> let hello = \"Hello Test!\" let model , _ = init () let model , _ = update ( GotHello hello ) model Expect . equal hello model . Hello \"The hello should be set\" ] let all = testList \"All\" [ client ] [< EntryPoint >] let main _ = Mocha . runTests all 5. Add Test web page Add a file called index.html to the root of the test project and add the following content to it: <!DOCTYPE html> < html > < head > < title > SAFE Client Tests </ title > </ head > < body > </ body > </ html > 6. Add test webpack config Add a new file root directory called webpack.tests.config.js . Populate it with the contents of a Fable-compatible webpack config template such as this . 7. Update the test webpack config Replace the CONFIG value in the webpack file you just created with the following: var CONFIG = { indexHtmlTemplate : ' ./ src / Client . Tests / index . html' , fsharpEntry : ' ./ src / Client . Tests / Client . Tests . fsproj' , outputDir : ' ./ src / Client . Tests' , assetsDir : ' ./ src / Client . Tests' , devServerPort : 8081 , devServerProxy : undefined , babel : undefined } Remove all references and code from the webpack file that refers to MiniCssExtractPlugin or CONFIG.cssEntry. 8. Add launch command Add the following entry to the scripts element in the Client project's package.json file: \"test:live\" : \"webpack-dev-server --config webpack.tests.config.js\" 9. Build the Tests Save all changes and build the Client.Test project. 9. Launch the test website Run the command npm install followed by npm run test : live Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this:","title":"Test the Client"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#how-do-i-test-the-client","text":"Testing on the client is a little different than on the server. This is because the code which is ultimately being executed in the browser is Javascript, translated from F# by Fable, and so it must be tested in a Javascript environment. Furthermore, code that is shared between the Client and Server must be tested in both a dotnet environment and a Javascript environment. The SAFE template uses a library called Fable.Mocha which allows us to run the same tests in both environments. It mirrors the Expecto API and works in much the same way.","title":"How do I test the client?"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#im-using-the-standard-template","text":"If you are using the standard template then there is nothing more you need to do in order to start testing your Client. You will find a folder in the solution named tests . Inside this there is a project, Client.Tests , which contains a single script demonstrating how to use Mocha to test the TODO sample. Note the compiler directive here which makes sure that the Shared tests are only included when executing in a Javascript (Fable) context. They are covered by Expecto under dotnet as you can see in Server.Tests.fs .","title":"I'm using the standard template"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#1-launch-the-test-server","text":"In order to run the tests, instead of starting your application using dotnet fake build -t run you should instead use dotnet fake build -t runtests","title":"1. Launch the test server"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#2-view-the-results","text":"Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this: This command builds and runs the Server test project too. If you want to run the Client tests alone, you can simply launch the test server using npm run test:live , which executes a command stored in package.json .","title":"2. View the results"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#im-using-the-minimal-template","text":"If you are using the minimal template, you will need to first configure a test project as none are included.","title":"I'm using the minimal template"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#1-add-a-test-project","text":"In the src folder, create a create a .Net Standard library called Client.Tests . cd src dotnet new ClassLib -lang F # -o Client.Tests cd .. dotnet sln add src / Client . Tests","title":"1. Add a test project"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#2-reference-the-client-project","text":"Reference the Client project from the Client.Tests project: dotnet add Client . Tests reference Client","title":"2. Reference the Client project"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#3-add-the-fablemocha-package-to-test-project","text":"Run the following command: dotnet add Client . Tests package Fable . Mocha","title":"3. Add the Fable.Mocha package to Test project"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#4-add-a-test","text":"Delete the Library.fs file and replace it with a new file called Tests.fs to your test project. Add the following code to it: module Tests open Fable.Mocha open Index let client = testList \"Client\" [ testCase \"Hello received\" <| fun _ -> let hello = \"Hello Test!\" let model , _ = init () let model , _ = update ( GotHello hello ) model Expect . equal hello model . Hello \"The hello should be set\" ] let all = testList \"All\" [ client ] [< EntryPoint >] let main _ = Mocha . runTests all","title":"4. Add a test"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#5-add-test-web-page","text":"Add a file called index.html to the root of the test project and add the following content to it: <!DOCTYPE html> < html > < head > < title > SAFE Client Tests </ title > </ head > < body > </ body > </ html >","title":"5. Add Test web page"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#6-add-test-webpack-config","text":"Add a new file root directory called webpack.tests.config.js . Populate it with the contents of a Fable-compatible webpack config template such as this .","title":"6. Add test webpack config"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#7-update-the-test-webpack-config","text":"Replace the CONFIG value in the webpack file you just created with the following: var CONFIG = { indexHtmlTemplate : ' ./ src / Client . Tests / index . html' , fsharpEntry : ' ./ src / Client . Tests / Client . Tests . fsproj' , outputDir : ' ./ src / Client . Tests' , assetsDir : ' ./ src / Client . Tests' , devServerPort : 8081 , devServerProxy : undefined , babel : undefined } Remove all references and code from the webpack file that refers to MiniCssExtractPlugin or CONFIG.cssEntry.","title":"7. Update the test webpack config"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#8-add-launch-command","text":"Add the following entry to the scripts element in the Client project's package.json file: \"test:live\" : \"webpack-dev-server --config webpack.tests.config.js\"","title":"8. Add launch command"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#9-build-the-tests","text":"Save all changes and build the Client.Test project.","title":"9. Build the Tests"},{"location":"v2-recipes/developing-and-testing/testing-the-client/#9-launch-the-test-website","text":"Run the command npm install followed by npm run test : live Once the build is complete and the website is running, navigate to http://localhost:8081/ in a web browser. You should see a test results page that looks like this:","title":"9. Launch the test website"},{"location":"v2-recipes/developing-and-testing/testing-the-server/","text":"How do I test the Server? Testing your Server code in a SAFE app is just the same as in any other dotnet app, and you can use the same tools and frameworks that you are familiar with. These include all of the usual suspects such as NUnit , XUnit , FSUnit , Expecto , FSCheck , AutoFixture etc. In this guide we will look at using Expecto , as this is included with the standard SAFE template. I'm using the standard template Using the Expecto runner If you are using the standard template, then there is nothing more you need to do in order to start testing your Server code. You will find a folder in the solution named tests . Inside this, there is a project named Server.Tests that contains a single script demonstrating how to use Expecto to test the TODO sample. In order to run the tests, instead of starting your application using dotnet fake build -t run you should instead use dotnet fake build -t runtests This will execute the tests and print the results into the console window. This method builds and runs the Client test project too, which can be slow. If you want to run the Server tests alone, you can simply navigate to the Server.Tests directory and run the project using dotnet run . Using dotnet test or the Visual Studio Test runner If you would like to use dotnet tests from the command line or the test runner that comes with Visual Studio, there are a couple of extra steps to follow. 1. Install the Test Adapters Run the following commands at the root of your solution: dotnet paket add Microsoft . NET . Test . Sdk -p Server . Tests dotnet paket add YoloDev . Expecto . TestSdk -p Server . Tests 2. Disable EntryPoint generation Open your ServerTests.fsproj file and add the following element: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup> 3. Discover tests To allow your tests to be discovered, you will need to decorate them with a [<Tests>] attribute. The provided test would look like this: [< Tests >] let server = testList \"Server\" [ testCase \"Adding valid Todo\" <| fun _ -> let storage = Storage () let validTodo = Todo . create \"TODO\" let expectedResult = Ok () let result = storage . AddTodo validTodo Expect . equal result expectedResult \"Result should be ok\" Expect . contains ( storage . GetTodos () ) validTodo \"Storage should contain new todo\" ] 4. Run tests There are now two ways to run these tests. From the command line, you can just run dotnet test from the root of your solution. Alternatively, if you are using Visual Studio or VS Mac you can make use of the built-in test explorers. I'm using the minimal template If you are using the minimal template, you will need to first configure a test project as none are included. 1. Add a test project In the src folder, create a create a .Net Core library called Server.Tests . cd src dotnet new console -lang F # -o Server.Tests cd .. dotnet sln add src / Server . Tests 2. Reference the Server project Reference the Server project from the Server.Tests project: dotnet add Server . Tests reference Server 3. Add Expecto to the Test project Run the following command: dotnet add Server . Tests package Expecto You will see a warning that a Program.fs file might be generated which will need deleting, so do that if necessary. You can prevent this reoccuring by adding an entry to your test project file: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup> 4. Add something to test Update the Server.fs file in the Server project to extract the message logic from the router like so: let getMessage () = \"Hello from SAFE!\" let webApp = router { get Route . hello ( getMessage () |> json ) } 5. Add a test Delete the Library.fs file in your test project and replace it with a new file called Tests.fs . Add the following code to it: module Server.Tests open Expecto let server = testList \"Server\" [ testCase \"Message returned correctly\" <| fun _ -> let expectedResult = \"Hello from SAFE!\" let result = Server . getMessage () Expect . equal result expectedResult \"Result should be ok\" ] [< EntryPoint >] let main _ = runTests defaultConfig server 6. Run the test Navigate to the Test project directory and execute it using dotnet run This will print out the results in the console window 7. Using dotnet test or the Visual Studio Test Explorer Navigate to the Test project directory and add the test runners using the following commands: dotnet add package Microsoft . NET . Test . Sdk and dotnet add package YoloDev . Expecto . TestSdk You can now add [<Test>] attributes to your tests so that they can be discovered, and then run them using the dotnet tooling in the same way as explained earlier for the standard template.","title":"Test the Server"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#how-do-i-test-the-server","text":"Testing your Server code in a SAFE app is just the same as in any other dotnet app, and you can use the same tools and frameworks that you are familiar with. These include all of the usual suspects such as NUnit , XUnit , FSUnit , Expecto , FSCheck , AutoFixture etc. In this guide we will look at using Expecto , as this is included with the standard SAFE template.","title":"How do I test the Server?"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#im-using-the-standard-template","text":"","title":"I'm using the standard template"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#using-the-expecto-runner","text":"If you are using the standard template, then there is nothing more you need to do in order to start testing your Server code. You will find a folder in the solution named tests . Inside this, there is a project named Server.Tests that contains a single script demonstrating how to use Expecto to test the TODO sample. In order to run the tests, instead of starting your application using dotnet fake build -t run you should instead use dotnet fake build -t runtests This will execute the tests and print the results into the console window. This method builds and runs the Client test project too, which can be slow. If you want to run the Server tests alone, you can simply navigate to the Server.Tests directory and run the project using dotnet run .","title":"Using the Expecto runner"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#using-dotnet-test-or-the-visual-studio-test-runner","text":"If you would like to use dotnet tests from the command line or the test runner that comes with Visual Studio, there are a couple of extra steps to follow.","title":"Using dotnet test or the Visual Studio Test runner"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#1-install-the-test-adapters","text":"Run the following commands at the root of your solution: dotnet paket add Microsoft . NET . Test . Sdk -p Server . Tests dotnet paket add YoloDev . Expecto . TestSdk -p Server . Tests","title":"1. Install the Test Adapters"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#2-disable-entrypoint-generation","text":"Open your ServerTests.fsproj file and add the following element: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup>","title":"2. Disable EntryPoint generation"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#3-discover-tests","text":"To allow your tests to be discovered, you will need to decorate them with a [<Tests>] attribute. The provided test would look like this: [< Tests >] let server = testList \"Server\" [ testCase \"Adding valid Todo\" <| fun _ -> let storage = Storage () let validTodo = Todo . create \"TODO\" let expectedResult = Ok () let result = storage . AddTodo validTodo Expect . equal result expectedResult \"Result should be ok\" Expect . contains ( storage . GetTodos () ) validTodo \"Storage should contain new todo\" ]","title":"3. Discover tests"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#4-run-tests","text":"There are now two ways to run these tests. From the command line, you can just run dotnet test from the root of your solution. Alternatively, if you are using Visual Studio or VS Mac you can make use of the built-in test explorers.","title":"4. Run tests"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#im-using-the-minimal-template","text":"If you are using the minimal template, you will need to first configure a test project as none are included.","title":"I'm using the minimal template"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#1-add-a-test-project","text":"In the src folder, create a create a .Net Core library called Server.Tests . cd src dotnet new console -lang F # -o Server.Tests cd .. dotnet sln add src / Server . Tests","title":"1. Add a test project"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#2-reference-the-server-project","text":"Reference the Server project from the Server.Tests project: dotnet add Server . Tests reference Server","title":"2. Reference the Server project"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#3-add-expecto-to-the-test-project","text":"Run the following command: dotnet add Server . Tests package Expecto You will see a warning that a Program.fs file might be generated which will need deleting, so do that if necessary. You can prevent this reoccuring by adding an entry to your test project file: <PropertyGroup> <GenerateProgramFile> false </GenerateProgramFile> </PropertyGroup>","title":"3. Add Expecto to the Test project"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#4-add-something-to-test","text":"Update the Server.fs file in the Server project to extract the message logic from the router like so: let getMessage () = \"Hello from SAFE!\" let webApp = router { get Route . hello ( getMessage () |> json ) }","title":"4. Add something to test"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#5-add-a-test","text":"Delete the Library.fs file in your test project and replace it with a new file called Tests.fs . Add the following code to it: module Server.Tests open Expecto let server = testList \"Server\" [ testCase \"Message returned correctly\" <| fun _ -> let expectedResult = \"Hello from SAFE!\" let result = Server . getMessage () Expect . equal result expectedResult \"Result should be ok\" ] [< EntryPoint >] let main _ = runTests defaultConfig server","title":"5. Add a test"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#6-run-the-test","text":"Navigate to the Test project directory and execute it using dotnet run This will print out the results in the console window","title":"6. Run the test"},{"location":"v2-recipes/developing-and-testing/testing-the-server/#7-using-dotnet-test-or-the-visual-studio-test-explorer","text":"Navigate to the Test project directory and add the test runners using the following commands: dotnet add package Microsoft . NET . Test . Sdk and dotnet add package YoloDev . Expecto . TestSdk You can now add [<Test>] attributes to your tests so that they can be discovered, and then run them using the dotnet tooling in the same way as explained earlier for the standard template.","title":"7. Using dotnet test or the Visual Studio Test Explorer"},{"location":"v2-recipes/package-management/migrate-to-yarn/","text":"How do I migrate to Yarn from NPM? Yarn is an alternative Javascript package manager created by Facebook. When it was first released it provided several features which were absent from NPM at the time such as offline caching and deterministic dependency resolution . Today however, NPM has largely gained feature parity with Yarn, although they still do things slightly differently and therefore many people prefer one over the other. The SAFE template uses NPM out of the box, but it is easy to migrate to Yarn if you wish. Switching to Yarn 1. Install Yarn You will need to install Yarn on your machine. Please note: Version 2 of Yarn is not currently supported . 2. Migrate from NPM Simply run the command: yarn 3. Sync package versions If you want to make sure that Yarn is using the same package versions that NPM had in its lock file, run yarn import Once this process is complete you can remove the NPM package-lock.json as it is no longer needed. For more details on migration see the official docs . Running the application Now that you have switched to using Yarn, you will need to modify the way in which the client application is built and launched. The way in which you do this depends on whether you have started with the minimal or full template, as the latter uses FAKE to manage its build process. Launching the application from the minimal template 1. Start the Client Run the command yarn run start 2. Start the Server Navigate to the Server project directory and run: dotnet run Launching the application from the full template 1. Update FAKE build script Open the build.fsx file that is in the root of the solution directory and replace all instances of \"npm\" with \"yarn\" (both in strings and in value names). 2. Update install args Replace Target . create \"InstallClient\" ( fun _ -> yarn \"install\" clientPath ) with Target . create \"InstallClient\" ( fun _ -> yarn \"install --frozen-lockfile\" clientPath ) 3. Launch the application At the root of your solution you can now just run dotnet fake build -t run as usual to launch both the Client and Server at the same time.","title":"Migrate to Yarn from NPM"},{"location":"v2-recipes/package-management/migrate-to-yarn/#how-do-i-migrate-to-yarn-from-npm","text":"Yarn is an alternative Javascript package manager created by Facebook. When it was first released it provided several features which were absent from NPM at the time such as offline caching and deterministic dependency resolution . Today however, NPM has largely gained feature parity with Yarn, although they still do things slightly differently and therefore many people prefer one over the other. The SAFE template uses NPM out of the box, but it is easy to migrate to Yarn if you wish.","title":"How do I migrate to Yarn from NPM?"},{"location":"v2-recipes/package-management/migrate-to-yarn/#switching-to-yarn","text":"","title":"Switching to Yarn"},{"location":"v2-recipes/package-management/migrate-to-yarn/#1-install-yarn","text":"You will need to install Yarn on your machine. Please note: Version 2 of Yarn is not currently supported .","title":"1. Install Yarn"},{"location":"v2-recipes/package-management/migrate-to-yarn/#2-migrate-from-npm","text":"Simply run the command: yarn","title":"2. Migrate from NPM"},{"location":"v2-recipes/package-management/migrate-to-yarn/#3-sync-package-versions","text":"If you want to make sure that Yarn is using the same package versions that NPM had in its lock file, run yarn import Once this process is complete you can remove the NPM package-lock.json as it is no longer needed. For more details on migration see the official docs .","title":"3. Sync package versions"},{"location":"v2-recipes/package-management/migrate-to-yarn/#running-the-application","text":"Now that you have switched to using Yarn, you will need to modify the way in which the client application is built and launched. The way in which you do this depends on whether you have started with the minimal or full template, as the latter uses FAKE to manage its build process.","title":"Running the application"},{"location":"v2-recipes/package-management/migrate-to-yarn/#launching-the-application-from-the-minimal-template","text":"","title":"Launching the application from the minimal template"},{"location":"v2-recipes/package-management/migrate-to-yarn/#1-start-the-client","text":"Run the command yarn run start","title":"1. Start the Client"},{"location":"v2-recipes/package-management/migrate-to-yarn/#2-start-the-server","text":"Navigate to the Server project directory and run: dotnet run","title":"2. Start the Server"},{"location":"v2-recipes/package-management/migrate-to-yarn/#launching-the-application-from-the-full-template","text":"","title":"Launching the application from the full template"},{"location":"v2-recipes/package-management/migrate-to-yarn/#1-update-fake-build-script","text":"Open the build.fsx file that is in the root of the solution directory and replace all instances of \"npm\" with \"yarn\" (both in strings and in value names).","title":"1. Update FAKE build script"},{"location":"v2-recipes/package-management/migrate-to-yarn/#2-update-install-args","text":"Replace Target . create \"InstallClient\" ( fun _ -> yarn \"install\" clientPath ) with Target . create \"InstallClient\" ( fun _ -> yarn \"install --frozen-lockfile\" clientPath )","title":"2. Update install args"},{"location":"v2-recipes/package-management/migrate-to-yarn/#3-launch-the-application","text":"At the root of your solution you can now just run dotnet fake build -t run as usual to launch both the Client and Server at the same time.","title":"3. Launch the application"},{"location":"v2-recipes/upgrading/v1-to-v2/","text":"How do I upgrade from SAFE v1 to v2? There have been a number of changes between the first and second major versions of the SAFE template. This guide shows you how to upgrade your v1 project to v2. If you haven't done so already then you will need to install the prequisites listed in the Quick Start guide. Terminology for this Recipe: \"Overwrite\" : Take the file from the \"new\" V2 template and copy it over the equivalent file in your existing project. \"Delete\" : Delete the file from your existing project. It is no longer required. \"Add\" : Add the file to your existing project. It is a new file added in V2. 1. Install the v2 template Download and install the latest SAFE Stack V2 template by running the following command: dotnet new -i SAFE.Template 2. Create a v2 project Create a new SAFE project in the safetemp folder. We will use this as a basis for our conversion. dotnet new SAFE - o safetemp 3. Branch your code We advise committing or stashing any unsaved changes to your code and making a new branch to perform the upgrade. You can then test it in isolation and then safely merge back in. 4. Update dotnet tools This file lists any custom dotnet tools used. Overwrite the .config/dotnet-tools.json file. Important ! If you have installed extra dotnet tools,you will need to add them back in manually. 4. Replace Yarn with NPM The v2 template no longer uses Yarn to manage JavaScript dependencies, and instead uses NPM. Delete the yarn.lock file. Overwrite the package.json file. Overwrite the package-lock.json file. Important ! If you have installed extra NPM packages, you will need to add them back in manually. If you have added any extra NPM packages, run this command to generate a new package-lock.json . npm install 5. Update Paket dependencies Overwrite the paket.dependencies file in the root of the solution. Overwrite the paket.lock file. Overwrite all paket.references files. Important If you have installed extra NuGet packages, you will need to add them back in manually to the dependencies and references files. There are no longer separate groups for the Client and Server dependency graphs. Simply include any custom packages in the main group. Run paket to update project references: dotnet paket install If you have added any extra NuGet packages, this command will also generate a new paket.lock file. 6. Update FAKE build script Overwrite the build.fsx FAKE script. Important If you have made any modifications to the build script e.g. extra targets, you will need to add them back in manually. The v2 FAKE script includes targets which build its Client and Server Test projects. If you are not planning on importing the Test projects to the v1 project you are upgrading then you can remove these targets. The v2 FAKE script includes a target for Azure deployment using Farmer. If you are not using Azure deployments, you can safely delete this target. 7. Update webpack config Overwrite the webpack.config.js file. Important If you have made any modifications to the webpack file, you will need to apply them back in manually. If you were using a CSS files, make sure to follow the Stylesheet recipe to add them back in. 8. Switch to a project for Shared files The v1 template used shared files to allow code reuse between the Server and Client. The v2 template now has a dedicated project for shared content. Add a new .Net Standard project to the solution by running cd src dotnet new ClassLib -lang F# -o Shared cd .. dotnet sln add src/Shared Remove the Library.fs module from the project and include any shared files you have been using (such as Shared.fs ). Reference the Shared project from the Server and Client projects (and any others which need to access shared content): cd src dotnet add Client reference Shared dotnet add Server reference Shared 9. Update Saturn application Open the Server.fs module at the root of the Server project (or whatever module contains your Saturn application expression). Delete the following content: let tryGetEnv key = match Environment . GetEnvironmentVariable key with | x when String . IsNullOrWhiteSpace x -> None | x -> Some x let publicPath = Path . GetFullPath \"../Client/public\" let port = \"SERVER_PORT\" |> tryGetEnv |> Option . map uint16 |> Option . defaultValue 8085us In the Saturn application expression, overwrite url ( \"http://0.0.0.0:\" + port . ToString () + \"/\" ) use_static publicPath with url \"http://0.0.0.0:8085\" use_static \"public\" 10. Check that it runs Run dotnet fake build -t run at the root of the solution to launch the app and check everything is working as expected. If you have problems loading your website, carefully check that you haven't missed out any javascript or nuget packages when overwriting the paket and package files. The console output will usually give you a good guide if this is the case.","title":"Upgrade from V1 to V2"},{"location":"v2-recipes/upgrading/v1-to-v2/#how-do-i-upgrade-from-safe-v1-to-v2","text":"There have been a number of changes between the first and second major versions of the SAFE template. This guide shows you how to upgrade your v1 project to v2. If you haven't done so already then you will need to install the prequisites listed in the Quick Start guide.","title":"How do I upgrade from SAFE v1 to v2?"},{"location":"v2-recipes/upgrading/v1-to-v2/#terminology-for-this-recipe","text":"\"Overwrite\" : Take the file from the \"new\" V2 template and copy it over the equivalent file in your existing project. \"Delete\" : Delete the file from your existing project. It is no longer required. \"Add\" : Add the file to your existing project. It is a new file added in V2.","title":"Terminology for this Recipe:"},{"location":"v2-recipes/upgrading/v1-to-v2/#1-install-the-v2-template","text":"Download and install the latest SAFE Stack V2 template by running the following command: dotnet new -i SAFE.Template","title":"1. Install the v2 template"},{"location":"v2-recipes/upgrading/v1-to-v2/#2-create-a-v2-project","text":"Create a new SAFE project in the safetemp folder. We will use this as a basis for our conversion. dotnet new SAFE - o safetemp","title":"2. Create a v2 project"},{"location":"v2-recipes/upgrading/v1-to-v2/#3-branch-your-code","text":"We advise committing or stashing any unsaved changes to your code and making a new branch to perform the upgrade. You can then test it in isolation and then safely merge back in.","title":"3. Branch your code"},{"location":"v2-recipes/upgrading/v1-to-v2/#4-update-dotnet-tools","text":"This file lists any custom dotnet tools used. Overwrite the .config/dotnet-tools.json file. Important ! If you have installed extra dotnet tools,you will need to add them back in manually.","title":"4. Update dotnet tools"},{"location":"v2-recipes/upgrading/v1-to-v2/#4-replace-yarn-with-npm","text":"The v2 template no longer uses Yarn to manage JavaScript dependencies, and instead uses NPM. Delete the yarn.lock file. Overwrite the package.json file. Overwrite the package-lock.json file. Important ! If you have installed extra NPM packages, you will need to add them back in manually. If you have added any extra NPM packages, run this command to generate a new package-lock.json . npm install","title":"4. Replace Yarn with NPM"},{"location":"v2-recipes/upgrading/v1-to-v2/#5-update-paket-dependencies","text":"Overwrite the paket.dependencies file in the root of the solution. Overwrite the paket.lock file. Overwrite all paket.references files. Important If you have installed extra NuGet packages, you will need to add them back in manually to the dependencies and references files. There are no longer separate groups for the Client and Server dependency graphs. Simply include any custom packages in the main group. Run paket to update project references: dotnet paket install If you have added any extra NuGet packages, this command will also generate a new paket.lock file.","title":"5. Update Paket dependencies"},{"location":"v2-recipes/upgrading/v1-to-v2/#6-update-fake-build-script","text":"Overwrite the build.fsx FAKE script. Important If you have made any modifications to the build script e.g. extra targets, you will need to add them back in manually. The v2 FAKE script includes targets which build its Client and Server Test projects. If you are not planning on importing the Test projects to the v1 project you are upgrading then you can remove these targets. The v2 FAKE script includes a target for Azure deployment using Farmer. If you are not using Azure deployments, you can safely delete this target.","title":"6. Update FAKE build script"},{"location":"v2-recipes/upgrading/v1-to-v2/#7-update-webpack-config","text":"Overwrite the webpack.config.js file. Important If you have made any modifications to the webpack file, you will need to apply them back in manually. If you were using a CSS files, make sure to follow the Stylesheet recipe to add them back in.","title":"7. Update webpack config"},{"location":"v2-recipes/upgrading/v1-to-v2/#8-switch-to-a-project-for-shared-files","text":"The v1 template used shared files to allow code reuse between the Server and Client. The v2 template now has a dedicated project for shared content. Add a new .Net Standard project to the solution by running cd src dotnet new ClassLib -lang F# -o Shared cd .. dotnet sln add src/Shared Remove the Library.fs module from the project and include any shared files you have been using (such as Shared.fs ). Reference the Shared project from the Server and Client projects (and any others which need to access shared content): cd src dotnet add Client reference Shared dotnet add Server reference Shared","title":"8. Switch to a project for Shared files"},{"location":"v2-recipes/upgrading/v1-to-v2/#9-update-saturn-application","text":"Open the Server.fs module at the root of the Server project (or whatever module contains your Saturn application expression). Delete the following content: let tryGetEnv key = match Environment . GetEnvironmentVariable key with | x when String . IsNullOrWhiteSpace x -> None | x -> Some x let publicPath = Path . GetFullPath \"../Client/public\" let port = \"SERVER_PORT\" |> tryGetEnv |> Option . map uint16 |> Option . defaultValue 8085us In the Saturn application expression, overwrite url ( \"http://0.0.0.0:\" + port . ToString () + \"/\" ) use_static publicPath with url \"http://0.0.0.0:8085\" use_static \"public\"","title":"9. Update Saturn application"},{"location":"v2-recipes/upgrading/v1-to-v2/#10-check-that-it-runs","text":"Run dotnet fake build -t run at the root of the solution to launch the app and check everything is working as expected. If you have problems loading your website, carefully check that you haven't missed out any javascript or nuget packages when overwriting the paket and package files. The console output will usually give you a good guide if this is the case.","title":"10. Check that it runs"}]}